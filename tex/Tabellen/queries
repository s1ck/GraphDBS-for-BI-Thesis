# Query 0
# Zufällige Auswahl von Produkten und Nutzern und laden ihrer Attribute.

# Cypher


# Gremlin

# Query 1 (Traversierung, Gruppierung, Aggregation)
# Produkte, für die Freunde oder deren Freunde ein Review geschrieben haben gruppiert nach
# Produktname und sortiert nach durchschnittlicher Bewertung

# Cypher
START n=node(42)
MATCH n-[:FRIEND_OF*1..2]-()<-[r:REVIEWED_BY]-p   
RETURN p.title, (sum(r.rating) * 1.0 / count(p)) as weight   
ORDER BY weight DESC;

# Gremlin
a.both('FRIEND_OF').both('FRIEND_OF').inE('REVIEWED_BY').groupBy{it.outV.next().title}{it.rating}{it.sum() * 1.0 / it.size()}.cap.orderMap(T.decr);


# Query 2
# Kürzester Pfad zwischen zwei Nutzern unter Verwendung der FRIEND_OF,
# REVIEWED_BY und SIMILAR_TO-Beziehung

# Cypher
START a=node(42), b=node(20) 
MATCH p=shortestPath(a-[:FRIEND_OF|:REVIEWED_BY|:SIMILAR_TO*..5]-b)  
RETURN EXTRACT(n in NODES(p): n.__type__), LENGTH(p); // 4

# Gremlin
a = g.v(42);
b = g.v(20);
visited=[a];
a.both('FRIEND_OF', 'REVIEWED_BY', 'SIMILAR_TO').except(visited).store(visited).loop(3){it.object != b && it.loops < 6}.retain([b]).path

# Query 3 (Traviersierung unter Berücksichtigung von Attributen)
# Produkte, die von Freunden anderen Geschlechts bewertet wurden und die ähnlich zu den eigenen,
# bewerteten Produkten sind

# Cypher

START a=node(47041)

MATCH a-[:FRIEND_OF*..2]-b<-[:REVIEWED_BY]-p-[:REVIEWED_BY]->a

RETURN DISTINCT p.title;

# Gremlin



# Helping stuff

g = TitanFactory.open('../../master_thesis/benchmark/out/titan-graph_100_4_2');
a = g.V('__id__', 'A16MCCBGBZIZVR').next();
b = g.V('__id__', 'A29QUUI26CAZO3').next();

// non-unique foaf
START n=node(42) MATCH n-[:FRIEND_OF*..2]-p return count(p); // 496
v.both('FRIEND_OF').both('FRIEND_OF').count(); // 496

// unique foaf
START n=node(42) MATCH n-[:FRIEND_OF]-()-[:FRIEND_OF]-p return count(distinct p); // 169
v.both('FRIEND_OF').dedup.both('FRIEND_OF').dedup.count(); // 169

// non unique products
START n=node(42) MATCH n-[:FRIEND_OF*1..2]-()<-[:REVIEWED_BY]-p return count(p); // 19
v.both('FRIEND_OF').both('FRIEND_OF').in('REVIEWED_BY').count(); // 19


// unique products
START n=node(42) MATCH n-[:FRIEND_OF*1..2]-()<-[:REVIEWED_BY]-p return count(distinct p); // 4
v.both('FRIEND_OF').both('FRIEND_OF').in('REVIEWED_BY').dedup.count(); // 4

// Gremlin
// number of incoming edges for products
v.both('FRIEND_OF').both('FRIEND_OF').inE('REVIEWED_BY').as('r').outV.groupCount().cap()


// top 5 degree
START n=node(*)
MATCH n-[r]-()
RETURN n, count(r) as degree
ORDER BY degree DESC
LIMIT 10;


