/**
* Query "Import" (import)
*
* Importieren der Datenbasis in das GDBMS unter Verwendung von Bulk-
* Load-Mechanismen.
*
*/

/**
* Query "Random Nodes" (random_read)
*
* Selektion zufällig ausgewählter Produkte und Nutzer sowie Auslesen
* ihrer Attribute.
* 
* Lokal, Einfache Leseanfrage
*
*/

// Cypher
START a=node(42) RETURN *;

// Gremlin
g.v(42).map();

/**
* Query "Similar Products" (sim_products)
*
* Selektion der Titel aller ähnlichen Produkte mit Abstand <= 2. Jeder
* Titel soll einmalig in der Ergebnismenge sein.
* 
* Lokal, Traversierung
*
*/

// Cypher
START n=node(22) MATCH n-[:SIMILAR_TO*..2]-s RETURN DISTINCT s.title AS title;

// Gremlin
p.both('SIMILAR_TO').loop(1){it.loops <= 2}.dedup().title

/**
* Query "FOAF-Products" (foaf_products)
*
* Selektion der Produkte, die von Freunden (anderen Geschlechts) bewertet 
* wurden und die ähnlich zu den eigenen, bewerteten Produkten sind.
*
* 
* Lokal, Traviersierung unter Berücksichtigung von Attributen
*
*/

// Cypher
// trifft auf 4 (100_4_2) Nutzer zu:
// {'A3QFLHQ6P91TX2', 'A1J1QS7I60O018', 'AFP8L7OE57R3K', 'A202FGBQHO5638'}
// {40050, 43113, 97676, 128304}

START a=node(40050)
MATCH a-[:FRIEND_OF*..2]-b<-[:REVIEWED_BY]-p-[:REVIEWED_BY]->a
WHERE b.gender <> a.gender
RETURN DISTINCT a; 

// trifft auf 18 (100_4_2) Nutzer zu:
START a=node(40050)
MATCH a-[:FRIEND_OF*..2]-b<-[:REVIEWED_BY]-p-[:REVIEWED_BY]->a
RETURN DISTINCT a;

* Gremlin
a = g.v(160200);
a.both('FRIEND_OF').loop(1){it.loops <=2}.in('REVIEWED_BY').out('REVIEWED_BY').retain([a]).dedup();


/**
* Query "FOAF-Reviews" (foaf_reviews)
*
* Selektion der Produkte, für die Freunde oder deren Freunde ein Review
* geschrieben haben gruppiert nach Titel und sortiert nach 
* durchschnittlicher Bewertung.
* 
* Lokal, Traversierung, Gruppierung, Aggregation
*
*/

* Cypher
START n=node(42)
MATCH n-[:FRIEND_OF*1..2]-()<-[r:REVIEWED_BY]-p   
RETURN p.title AS title, avg(r.rating) AS weight  
ORDER BY weight DESC;

* Gremlin
a.both('FRIEND_OF').both('FRIEND_OF').inE('REVIEWED_BY').groupBy{it.outV.next().title}{it.rating}{it.sum() * 1.0 / it.size()}.cap.orderMap(T.decr);

/**
* Query "All Paths" (path_all)
*
* Berechnen der Pfade der Länge <= 4 zwischen einem Nutzer und einem 
* Produkt unter Verwendung der Beziehungstypen FRIEND_OF, REVIEWED_BY
* und SIMILAR_TO. Es wird die Anzahl der Pfade gruppiert nach Länge ausgegeben.
*
* Lokal, Erreichbarkeit
*
*/

* Cypher

START a=node(48089), b=node(22) 
MATCH p=a-[:FRIEND_OF|SIMILAR_TO|REVIEWED_BY*..4]-b 
RETURN length(p) AS length, count(p) AS cnt;

* Gremlin
a = g.V('__id__', 'A44FUIZX7CUVN').next();
b = g.V('__id__', '0231096704').next();
visited=[a];
a.both('FRIEND_OF','REVIEWED_BY','SIMILAR_TO').loop(1){it.object != b && it.loops < 5}.retain([b]).path._().transform{it.size() - 1}.groupCount().cap();

/**
* Query "Shortest Path" (path_shortest)
*
* Berechnung des kürzesten Pfades zwischen zwei Nutzern unter Verwendung
* der Beziehungstypen FRIEND_OF, REVIEWED_BY und SIMILAR_TO. Die maximale
* Pfadlänge beträgt 5. Es werden die __id__ Attribute der Knoten innerhalb der
* Pfadinstanzen ausgegeben.
*
* Lokal, Erreichbarkeit
*
*/

* Cypher (3)
START a=node(48089), b=node(22)
MATCH p=shortestPath(a-[:FRIEND_OF|:REVIEWED_BY|:SIMILAR_TO*..5]-b)
RETURN EXTRACT(n in NODES(p): n.__id__) AS path;

==>["A44FUIZX7CUVN","0679724699","0520078748","0231096704"]

* Gremlin
a = g.V('__id__', 'A44FUIZX7CUVN').next();
b = g.V('__id__', '0231096704').next();
visited=[a];
a.both('FRIEND_OF', 'REVIEWED_BY', 'SIMILAR_TO').except(visited).store(visited).loop(3){it.object != b && it.loops < 6}.retain([b]).path{it.__id__};

==>[A44FUIZX7CUVN, 0679724699, 0520078748, 0231096704]

/**
* Query "Reading Regions" (top_regions)
*
* Berechnen der Anzahl Bücher mit Salesrank < 500000 gruppiert nach Region,
* absteigend sortiert nach Anzahl und limitiert auf 10 Ergebnisse.
*
* Lokal, Traversierung, Aggregation / Gruppierung, Attributeinschränkung
*
*/

* Cypher
START g=node(2)
MATCH g<-[:BELONGS_TO]-p-[r:REVIEWED_BY]->u
WHERE p.salesrank < 500000
RETURN u.region AS region, count(u) AS cnt
ORDER BY cnt DESC
LIMIT 10;

* Gremlin
group = g.V('__id__', 'g_0').next();
group.in('BELONGS_TO').filter{it.salesrank < 500000}.out('REVIEWED_BY').groupCount{it.region}.cap().orderMap(T.decr)[0..9];

/**
* Query "Similar Reviews Pattern" (sim_pattern)
*
* Selektion alle Subgraphen in denen ausgehend von einem Nutzer die Freunde für n > 0
* übereinstimmende Produkte Reviews geschrieben haben.
*
* Global, Mustersuche (Dreiecke) mit Bindung an Datenbasis und
* Attributeinschränkung
*
*/

// Cypher

// with neo4j ids
START user=node(*)
MATCH user:User-[:FRIEND_OF]-friends1:User<-[:REVIEWED_BY]-products:Product,
products:Product-[:REVIEWED_BY]->friends2:User
WITH user, products, collect(distinct id(friends1)) as f1, collect(distinct id(friends2)) as f2
WITH user, products, filter(x in f1 : x in f2) as intersect
WITH user, products, count(products) as n, intersect, length(intersect) as intersect_cnt
WHERE intersect_cnt > 1 and n > 0
RETURN id(user) as user_id, n, id(products) as product_id, intersect as friends, intersect_cnt
ORDER BY n DESC, intersect_cnt DESC, product_id
LIMIT 25;

// with original ids
START user=node(*)
MATCH user:User-[:FRIEND_OF]-friends1:User<-[:REVIEWED_BY]-products:Product,
products:Product-[:REVIEWED_BY]->friends2:User
WITH user, products, collect(distinct friends1.__id__) as f1, collect(distinct friends2.__id__) as f2
WITH user, products, filter(x in f1 : x in f2) as intersect
WITH user, products, count(products) as n, intersect, length(intersect) as intersect_cnt
WHERE intersect_cnt > 1 and n > 0
RETURN user.__id__ as user_id, n, products.__id__ as product_id, intersect as friends, intersect_cnt
ORDER BY n DESC, intersect_cnt DESC, product_id
LIMIT 25;

// Gremlin

g = TitanFactory.open('../../master_thesis/benchmark/out/titan-graph_611_50_4_2');
u=g.V('__id__', 'A3B4D5T8N1Q33Y').next();

u.both('FRIEND_OF').dedup().inE('REVIEWED_BY').groupCount{it.outV.next().__id__}.cap

/**
* Query "Triangle Pattern 2" (triangle_pattern_2)
*
* Finden aller Dreicksbeziehungen folgender Art: Ein Produkt p besitzt 
* eine Bewertung r die für mindestens 10 Personen hilfreich war. 
* Der bewertende Nutzer u1 ist mit einem weiteren Nutzer u2 befreundet, 
* der älter als 20 Jahre alt ist und ebenfalls das Produkt p bewertet 
* hat. Es sollen p, u1, u2 und r bestimmt werden.
*
* Global, Mustersuche (Dreiecke) mit Bindung an Datenbasis und
* Attributeinschränkung
*
*/

// Cypher

// Gremlin

/**
* Helping stuff
*/

g = TitanFactory.open('../../master_thesis/benchmark/out/titan-graph_611_50_4_2');
a = g.V('__id__', 'A16MCCBGBZIZVR').next(); // user
b = g.V('__id__', 'A29QUUI26CAZO3').next(); // user
c = g.V('__id__', 'A44FUIZX7CUVN').next(); // user
p = g.V('__id__', '0231096704').next(); // product (neo id: 22)

// non-unique foaf
START n=node(42) MATCH n-[:FRIEND_OF*..2]-p return count(p); // 496
v.both('FRIEND_OF').both('FRIEND_OF').count(); // 496

// unique foaf
START n=node(42) MATCH n-[:FRIEND_OF]-()-[:FRIEND_OF]-p return count(distinct p); // 169
v.both('FRIEND_OF').dedup.both('FRIEND_OF').dedup.count(); // 169

// non unique products
START n=node(42) MATCH n-[:FRIEND_OF*1..2]-()<-[:REVIEWED_BY]-p return count(p); // 19
v.both('FRIEND_OF').both('FRIEND_OF').in('REVIEWED_BY').count(); // 19


// unique products
START n=node(42) MATCH n-[:FRIEND_OF*1..2]-()<-[:REVIEWED_BY]-p return count(distinct p); // 4
v.both('FRIEND_OF').both('FRIEND_OF').in('REVIEWED_BY').dedup.count(); // 4

// Gremlin
// number of incoming edges for products
v.both('FRIEND_OF').both('FRIEND_OF').inE('REVIEWED_BY').as('r').outV.groupCount().cap()


// top 5 degree
START n=node(*)
MATCH n-[r]-()
RETURN n, count(r) as degree
ORDER BY degree DESC
LIMIT 10;


