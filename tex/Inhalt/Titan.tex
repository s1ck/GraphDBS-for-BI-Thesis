\section{Titan}

Das vierte System, welches im Rahmen der Evaluation betrachtet wird, ist Titan, ein quelloffenes, unter Apache 2.0 lizenziertes GDBMS. Es wird von der Firma Aurelius\footnote{\url{http://thinkaurelius.com/}} entwickelt und ist im Vergleich zu den bisher betrachteten Systemen ein sehr junges Projekt. Die erste Veröffentlichung erfolgte im September 2012, seit Mai 2013 ist die stabile Version 0.3.2 aktuell. Aurelius arbeitet eng mit dem TinkerPop-Projekt zusammen und implementiert die darin definierte Blueprints API. Titan selbst ist ausschließlich in Java umgesetzt, die Ausführung ist somit auf kompatiblen Plattformen möglich. Es handelt sich um ein GDBMS, in dem Modellierung und Verwendung der Daten nativ sind, Speicherung und Verarbeitung sind hingegen nicht-nativ: Der Graph wird analog zu HyperGraphDB auf ein Key-Value-Datenmodell abgebildet. Das verwendete Speichersystem ist austauschbar, Titan unterstützt aktuell die spaltenorientierten, verteilten Datenbanken Apache Cassandra\footnote{\url{http://cassandra.apache.org/}} und Apache HBase\footnote{\url{http://hbase.apache.org/}} sowie die bereits vorgestellte, zentrale Key-Value-Datenbank BerkeleyDB Java Edition. Die genannten Speichersysteme sind disk-orientiert, Titan bietet jedoch auch eine integrierte hauptspeicher-zentrierte Implementierung an. Die Verwendung des GDBMS erfolgt entweder eingebettet innerhalb von Java-Anwendungen oder im Client-Server-Betrieb.

Im Gegensatz zu den bisher betrachteten Systemen wird Titan primär für den Einsatz als verteiltes GDBMS entwickelt. Dabei nutzt es die Eigenschaften und Vorteile vorhandener Speichertechnologien für die horizontale Skalierung sowohl paralleler Zugriffe in als auch des Datenvolumens von umfangreichen Graphen. Aurelius definiert Graphen als umfangreich, wenn diese mehrere Milliarden Knoten und Kanten aufweisen.\footnote{Im Mai 2013 veröffentlichte Aurelius einen beeindruckenden Benchmark in dem die Performance paralleler Zugriffe auf einen Graph mit ca. 6 Milliarden Knoten und 121 Milliarden Kanten auf einem Titan-Cassandra-Cluster gemessen wurde. Die Ergebnisse können unter \cite{titan_bench:2013} eingesehen werden.} Entsprechend der vorgestellten Kategorisierung handelt es sich somit um eine Kombination aus Graphdatenbanksystem und Graph Processing System, welches Zugriffe mit lokalem Bezug auf umfangreichen Graphen ermöglicht. Eine weitere Besonderheit von Titan ist die Verwendung von Indizes an Knoten. Diese versprechen einen effizienteren Zugriff auf inzidente Kanten bei Knoten mit hohem Grad.

Die nachfolgenden Erläuterungen beziehen sich auf Version 0.3.2 des GDBMS in Verbindung mit BerkeleyDB. Dies ermöglicht im nachfolgenden Benchmark den direkten Vergleich mit HyperGraphDB. Die verteilte Konfiguration der GDBMS wird im Benchmark nicht betrachtet, auf die Eigenschaften von Apache Cassandra und Apache HBase wird jedoch kurz in Abschnitt \ref{subsec:titan_verteilung} eingegangen. Die Informationen stammen vorrangig aus der offiziellen Dokumentation zu Titan\cite{titan_doku:2013} und Gremlin\cite{gremlin_doku:2013} sowie aus der offiziellen Mailing-Liste\cite{titan_mail:2013} des GDBMS.

\subsection{Datenmodell und Typsystem}

Titan implementiert das Property-Graph-Modell: Attribute können an Knoten und Kanten gespeichert werden, Kanten besitzen grundsätzlich eine Richtung und einen Bezeichner. Attributschlüssel sind vom Typ \texttt{String} während für Attributwerte sämtliche primitiven Java-Datentypen sowie Arrays, Collections und Maps zulässig sind.\footnote{Titan verwendet die Java-Bibliothek Kryo für die (De-)Serialisierung von Objekten. Eine vollständige Liste der unterstützten Datentypen kann unter \url{https://code.google.com/p/kryo/} eingesehen werden.} Abgesehen von Kantenbezeichnern ist die Definition eines festen Knoten- bzw. Kantenschemas nicht möglich. Ungeachtet dessen lassen sich verschiedene Einschränkungen festlegen, welche zum Teil auf das Modellieren einer Anwendungsdomäne, in erster Linie jedoch auf das effiziente Verwalten des Graphen ausgerichtet sind.

Das GDBMS verwendet spezielle Datentypen für Attributschlüssel und Kantenbezeichner: \texttt{TitanKey} und \texttt{TitanLabel}. Diese lassen sich entweder manuell festlegen oder bei erstmaliger Verwendung eines Schlüssels oder Bezeichners automatisch durch das System erzeugen. Das manuelle Vorgehen bietet mehrere Vorteile: Die Möglichkeit zur Definition von Integritätsbedingungen, eine verbesserte Speichereffizienz sowie eine erhöhte Performance. Die genannten Typen definieren kein Knoten- oder Kantenschema; weist jedoch eine Instanz ein typisiertes Attribut oder Label auf, so müssen die geforderten Integritätsbedingungen eingehalten werden.

Typen besitzen einen systemweit eindeutigen Namen, dieser entspricht dem Attributschlüssel bzw. dem Kantenbezeichner. Instanzen von \texttt{TitanKey} und \texttt{TitanLabel} können als \texttt{UNIQUE} deklariert werden: Für Attributschlüssel kann dies entweder auf einen einzelnen Knoten bzw. eine einzelne Kante oder auf den gesamten Graphen angewendet werden. Im ersten Fall darf dem entsprechend typisierten Attributschlüssel an einer Knoten- oder Kanteninstanz höchstens ein Wert zugeordnet sein, im zweiten Fall gilt die Einmaligkeit eines Schlüssel-Wert-Paares systemweit und ermöglicht folglich die Definition anwendungsbezogener Primärschlüssel. Standardmäßig kann ein Attributschlüssel mehrfach an einem Knoten vorkommen.\\
Für Kantenbezeichner legt die \texttt{UNIQUE}-Bedingung hingegen fest, dass entsprechend bezeichnete Instanzen innerhalb der Nachbarschaft einer Knoteninstanz höchstens einmal vorkommen dürfen. Hierbei kann zwischen eingehenden und ausgehenden Kanten unterschieden werden.\footnote{Der Name eines Mitarbeiters ist ein Beispiel für ein einmaliges Attribut an einem Knoten während die Personalnummer innerhalb der gesamten Knotenmenge eindeutig sein muss. Ein Beispiel für eine einmalige Kante ist die Beziehung vom Angestellten zum Vorgesetzten.} Sowohl Attributschlüssel als auch Kantenbezeichner können gruppiert werden, dies ermöglicht ein effizienteres Abfragen von Attributen und Beziehungen eines Knotens.\footnote{Eine mögliche Gruppierung von Kanten sind zum Beispiel die Beziehungen zwischen Mitarbeiter und Projekt gruppiert nach Abteilung.} 

Darüber hinaus definiert ein \texttt{TitanKey} den Datentyp des zugeordneten Attributwertes, was zum Einen dessen Wertebereich festlegt und zum Anderen die effizientere Speicherung ermöglicht. Des Weiteren können Attributschlüssel indexiert und somit der direkte, effiziente Zugriff auf die zugehörigen Instanzen unter Angabe von Schlüssel-Wert-Paaren realisiert werden. Im Unterschied dazu lässt sich an einem \texttt{TitanLabel} ein Primärschlüssel festlegen. Weist eine Kante das entsprechende Attribut auf, erlaubt dies das effizientere Auslesen inzidenter Kanten unter Angabe eines Wertes oder Wertebereiches.\footnote{Besitzt eine Beziehung vom Mitarbeiter zum Projekt einen Zeitstempel, welcher den Beitritt des Mitarbeiters datiert, und ist dieser Zeitstempel ein Primärschlüssel, dann lassen sich Anfragen wie zum Beispiel \textit{An welchen Projekten hat Mitarbeiter x im Mai 2013 mitgearbeitet?} effizienter beantworten.} Dies ist ein Alleinstellungsmerkmal von Titan und verspricht eine höhere Performance beim Traversieren des Graphen. Aurelius bezeichnet dieses Konzept als \textit{vertex-centric indices}. Neben dem Primärschlüssel kann ein Kantenbezeichner eine Signatur besitzen, die angibt, welche Attribute dies zugehörigen Kanteninstanzen besitzen bzw. voraussichtlich besitzen. Dies verspricht ein effizienteres Speichern und Laden von Kanteninstanzen. Kanten sind standardmäßig gerichtet und können in beiden Richtungen traversiert werden. Titan bietet hierfür jedoch eine Einschränkung: Kanten können uni-direktional sein und nur vom Start- zum Zielknoten traversiert werden. Hierdurch kann Speicherplatz am Zielknoten gespart werden, zu beachten ist jedoch, dass ein Löschen des Zielknotens nicht das Löschen der Kante erfordert und das Einhalten der referentiellen Integrität somit in der Verantwortung der Anwendung liegt.

% Identität
Die Identität von Knoten- und Kanteninstanzen wird analog zu Neo4j durch eine 64-Bit-Ganzzahl festgelegt.\footnote{Nachzuvollziehen unter \url{https://github.com/thinkaurelius/titan/blob/0.3.2/titan-core/src/main/java/com/thinkaurelius/titan/core/TitanElement.java\#L52}.} Diese wird vom GDBMS vergeben und kann nach dem Löschen von Instanzen wiederverwendet werden. Unter Angabe einer Identität lässt sich auf die Instanzen zugreifen, sie entspricht somit der Definition eines Primärschlüssels.

% Anzahl der Datenbanken (wie Partitionierung)
Titan verwaltet genau eine Graphdatenbank, dieser sind alle Knoten und Kanten zugeordnet. Eine anwendungsseitige Partitionierung der Knoten- oder Kantenmenge zur unabhängigen Verwaltung von Teilgraphen ist ausschließlich durch die Verwendung dedizierter Attribute möglich.

% Flexiblität
Aus den Ausführungen geht hervor, dass Titan sehr flexibel bezüglich der expliziten Definition, Änderung und Verwendung eines Schemas ist. Analog zu Neo4j ist die Definition im Gegensatz zur Berücksichtigung von Kantenbezeichnern obligatorisch. Überlässt man dem GDBMS das Erzeugen der Typen für Attributschlüssel und Kantenbezeichner, so entspricht das Datenmodell exakt der Definition des PGM. Attribute lassen sich zur Laufzeit hinzufügen, ändern und entfernen, Kantenbezeichner können hinzugefügt, jedoch nicht geändert oder gelöscht werden. Analog zu den bisher betrachteten GDBMS empfiehlt jedoch auch Aurelius die manuelle Typ-Definition um von den genannten Vorteilen zu profitieren.



\subsection{Zugriffsmechanismen, Transaktionen und Indexverwaltung}

% Varianten nennen (eingebettet, remote)
% Blueprints-Stack kurz erklären
	- Integration in Neo4j, OrientDB, Dex, InfiniteGraph

% CRUD-Operationen analog zu OrientDB (+Typdefinition)
	% Unterschiede zu OrientDB aufzeigen (z.B. Typen statt Strings)
	% beliebig durch API
	% angebotene Algorithmen (entsprechend OrientDB im Furnace Paket)
	% imperativ
% Gremlin als wesentlicher Inhalt
	- Gremlin = DSL auf Basis von Groovy\footnote{\url{http://groovy.codehaus.org/}}, einer dynamischen Programmiersprache für die Java-Plattform
	- Titan erweitert Gremlin mit Hilfsmethoden
	% Paradigma (imperativ)
	% standardisiert (quasi-standard)
		% von allen GDBMS nutzbar, welche die Blueprints API implementieren
	% Definition
	% Manipulation (Einfügen Knoten / Kante)
	% Traversierung
	% Mustersuche
	- https://github.com/tinkerpop/gremlin/wiki/SPARQL-vs.-Gremlin --> Testen
	% DSL
	- Groovy ermöglicht DSL\footnote{\url{http://thinkaurelius.com/2013/07/25/developing-a-domain-specific-language-in-gremlin/}}
	
\paragraph*{Transaktionen}

% obligatorisch
% Erzeugen (implizit, explizit)
% Schachtelung
% BerkeleyDB siehe OrientDB
	% Dauerhaftigkeit ist standardmäßig aktiviert (Quelltext)
	% REPEATABLE READ (keine Mehrbenutzeranomalien)
	% Behandlung von Deadlocks
% Transaktionen innerhalb von Titan?
- nur für inkonsistente Speichersysteme
	- MVCC
- Locks auf Unique Typen

Since edges and properties of unique labels and keys must be unique per vertex, inconsistencies could arise when two TitanGraph instances try to update the same unique edge or property concurrently, since one may overwrite the change of the other. To avoid such inconsistencies, Titan will acquire locks on unique edges and properties by default. Acquiring locks, however, can be very expensive depending on the storage backend. In cases where concurrent modifications can be excluded or blind overwrites are acceptable, a unique TitanType can be configured to not acquire locks by passing in UniquenessConsistency.NO\_LOCK as a second argument to TypeMaker.unique(). This configuration option should be used with care and only if the extra performance gain is needed.
	

% Anmerkung zu Cassandra und HBase

\paragraph*{Indexverwaltung}

% Primary Key
% Property-Index
- interne Indexstrukturen auf Attributen
\texttt{g.createKeyIndex("name", Vertex.class)}
	- Graph.query()
	- Besonderheiten: Geosuche, Volltextsuche

- externe Indeximplementierungen
	- ElasticSearch
	- Lucene

	% Aktualisierung (autmatische, manuelle Indizes)
	% Beispiel
% Vertex-centric Index!
- Vertex-Centric Indices
	- Supernode-Problem (Hubs, große Nachbarschaft, sehr großer Knotengrad)
	- B-Baum zur Indizierung inzidenter Knoten ermöglicht schnellen Lookup bei Einschränkung auf Richtung, Kantenbezeichner und -attribute
		- disk-zentriertes Sortieren und Indexierung ->mehrdimensionaler Index
			- Kantenbezeichner -> Attribut
		- Vertex.query()
	- \texttt{final TitanKey time = graph.makeType().name(\string"time\string").dataType(Integer.class).makePropertyKey();}
	- \texttt{graph.makeType().name(\string"battled\string").primaryKey(time).makeEdgeLabel();}
	- $\mathcal{O}(\log(\left|N_v\right|))$
	

% Erweiterung?

\subsection{Persistenz- und Cacheverwaltung}

% https://groups.google.com/forum/?hl=de#!searchin/aureliusgraphs/storage$20single$20machine/aureliusgraphs/qO9Bi-y7uLs/EG5Ol-ulHjAJ

- Data Management
	- immutable atomic edges
	- OCC
	- feingranulares Locking auf Knoten- und Kantenebene
- Edge Compression

- Vertex-Centric Indizes
% BerkeleyDB: B-Baum, Transaktions-Log
% Abbildung des Graphen auf KV-Store (reicht!)
- Kantenkompression
	- Speicherung der ID-Differenz zwischen Ziel- und Startknoten
% Komplexität Nachbarschaft / Traversierung
- abhängig vom Speichersystem
	- BerkeleyDB logarithmisch

\paragraph*{Cacheverwaltung}

% BerkeleyDB
% eigene Caches

\subsection{Verteilung und Skalierbarkeit}
\label{subsec:titan_verteilung}

% BerkeleyDB ausschließlich zentral
% Replikation und Partitionierung via Cassandra / HBase
- Cassandra
	- Hochverfügbarkeit (Replikation)
	- Peer-To-Peer Verteilung (Distributed Hashtable)
	- Caching
	- Eventual Consistency
- HBase
	- lineare Skalierbarkeit
	- Strong Consistency
	
% vielleicht kurz beschreiben (+Skalierbarkeit)