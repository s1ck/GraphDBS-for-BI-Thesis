\section{Titan}

Das vierte System, welches im Rahmen der Evaluation betrachtet wird, ist Titan, ein quelloffenes, unter Apache 2.0 lizenziertes GDBMS. Es wird von der Firma Aurelius\footnote{\url{http://thinkaurelius.com/}} entwickelt und ist im Vergleich zu den bisher betrachteten Systemen ein sehr junges Projekt. Die erste Veröffentlichung erfolgte im September 2012, seit Mai 2013 ist die stabile Version 0.3.2 aktuell. Aurelius arbeitet eng mit dem TinkerPop-Projekt zusammen und implementiert die darin definierte Blueprints API. Titan selbst ist ausschließlich in Java umgesetzt, die Ausführung ist somit auf kompatiblen Plattformen möglich. Es handelt sich um ein GDBMS, in dem Modellierung und Verwendung der Daten nativ sind, Speicherung und Verarbeitung sind hingegen nicht-nativ: Der Graph wird analog zu HyperGraphDB auf ein Key-Value-Datenmodell abgebildet. Das verwendete Speichersystem ist austauschbar, Titan unterstützt aktuell die spaltenorientierten, verteilten Datenbanken Apache Cassandra\footnote{\url{http://cassandra.apache.org/}} und Apache HBase\footnote{\url{http://hbase.apache.org/}} sowie die bereits vorgestellte, zentrale Key-Value-Datenbank BerkeleyDB Java Edition. Die genannten Speichersysteme sind disk-orientiert, Titan bietet jedoch auch eine integrierte hauptspeicher-zentrierte Implementierung an. Die Verwendung des GDBMS erfolgt entweder eingebettet innerhalb von Java-Anwendungen oder im Client-Server-Betrieb.

Im Gegensatz zu den bisher betrachteten Systemen wird Titan primär für den Einsatz als verteiltes GDBMS  zur Verwaltung umfangreicher Graphen entwickelt. Dabei nutzt es die Eigenschaften und Vorteile vorhandener Speichertechnologien um eine horizontale Skalierbarkeit paralleler Zugriffe und Datenvolumen zu gewährleisten. Aurelius definiert Graphen als umfangreich, wenn diese mehrere Milliarden Knoten und Kanten aufweisen.\footnote{Im Mai 2013 veröffentlichte Aurelius einen beeindruckenden Benchmark in dem die Performance paralleler Zugriffe auf einen Graph mit ca. 6 Milliarden Knoten und 121 Milliarden Kanten auf einem Titan-Cassandra-Cluster gemessen wurde. Die Ergebnisse können unter \cite{titan_bench:2013} eingesehen werden.} Entsprechend der vorgestellten Kategorisierung handelt es sich somit um eine Kombination aus Graphdatenbanksystem und Graph Processing System, welches Zugriffe mit lokalem Bezug auf umfangreichen Graphen ermöglicht. Eine weitere Besonderheit von Titan ist die Verwendung von Indizes an Knoten. Diese versprechen einen effizienteren Zugriff auf inzidente Kanten bei Knoten mit hohem Grad.

Die nachfolgenden Erläuterungen beziehen sich auf Version 0.3.2 des GDBMS in Verbindung mit BerkeleyDB. Dies ermöglicht im nachfolgenden Benchmark den direkten Vergleich mit HyperGraphDB. Die verteilte Konfiguration der GDBMS wird im Benchmark nicht betrachtet, auf die Eigenschaften von Apache Cassandra und Apache HBase wird jedoch kurz in Abschnitt \ref{subsec:titan_verteilung} eingegangen. Die Informationen stammen vorrangig aus der offiziellen Dokumentation zu Titan\cite{titan_doku:2013} und Gremlin\cite{gremlin_doku:2013} sowie aus der offiziellen Mailing-Liste\cite{titan_mail:2013} des Herstellers.

\subsection{Datenmodell und Typsystem}

Titan implementiert das Property-Graph-Modell: Attribute können an Knoten und Kanten gespeichert werden, Kanten besitzen grundsätzlich eine Richtung und einen Bezeichner. Attributschlüssel sind vom Typ \texttt{String} während für Attributwerte sämtliche primitiven Java-Datentypen sowie Arrays, Collections und Maps zulässig sind.\footnote{Titan verwendet die Java-Bibliothek Kryo für die (De-)Serialisierung von Objekten. Eine vollständige Liste der unterstützten Datentypen kann unter \url{https://code.google.com/p/kryo/} eingesehen werden.} Abgesehen von Kantenbezeichnern ist die Definition eines festen Knoten- bzw. Kantenschemas nicht möglich. Ungeachtet dessen lassen sich verschiedene Einschränkungen festlegen, welche zum Teil auf das Modellieren einer Anwendungsdomäne, in erster Linie jedoch auf das effizientere Verwalten des Graphen ausgerichtet sind.

Das GDBMS verwendet spezielle Datentypen für Attributschlüssel und Kantenbezeichner: \texttt{TitanKey} und \texttt{TitanLabel}. Diese lassen sich entweder manuell festlegen oder bei erstmaliger Verwendung eines Schlüssels oder Bezeichners automatisch durch das System erzeugen. Das manuelle Vorgehen bietet mehrere Vorteile: Die Möglichkeit zur Definition von Integritätsbedingungen, eine verbesserte Speichereffizienz sowie eine erhöhte Performance. Die genannten Typen definieren kein Knoten- oder Kantenschema; weist jedoch eine Instanz ein typisiertes Attribut oder Label auf, so müssen die geforderten Integritätsbedingungen eingehalten werden.

Typen besitzen einen systemweit eindeutigen Namen, dieser entspricht dem Attributschlüssel bzw. dem Kantenbezeichner. Instanzen von \texttt{TitanKey} und \texttt{TitanLabel} können als \texttt{UNIQUE} deklariert werden: Für Attributschlüssel lässt sich die Bedingung entweder auf einen einzelnen Knoten bzw. eine einzelne Kante oder auf den gesamten Graphen anwenden. Im ersten Fall darf dem entsprechend typisierten Attributschlüssel an einer Knoten- oder Kanteninstanz höchstens ein Wert zugeordnet sein, im zweiten Fall gilt die Einmaligkeit eines Schlüssel-Wert-Paares systemweit und ermöglicht folglich die Definition anwendungsbezogener Primärschlüssel. Standardmäßig kann ein Attributschlüssel mehrfach an einem Knoten vorkommen.\\
Für Kantenbezeichner legt die \texttt{UNIQUE}-Bedingung hingegen fest, dass zugehörige Instanzen innerhalb der Nachbarschaft eines Knotens höchstens einmal vorkommen dürfen. Hierbei kann zwischen eingehenden und ausgehenden Kanten unterschieden werden.\footnote{Der Name eines Mitarbeiters ist ein Beispiel für ein einmaliges Attribut an einem Knoten während die Personalnummer innerhalb der gesamten Knotenmenge eindeutig sein muss. Ein Beispiel für eine einmalige Kante ist die Beziehung vom Angestellten zum Vorgesetzten.} Folglich lassen sich die Kardinalitäten der an einer Beziehung beteiligten Entitäten festlegen: Das Weglassen der \texttt{UNIQUE}-Bedingung definiert eine $n:m$-Beziehung, der Standard im PGM. Gilt die Bedingung in ausgehender Richtung, modelliert dies eine $1:n$-, in eingehender Richtung eine $n:1$-Beziehung. Gilt die \texttt{UNIQUE}-Bedingung in beiden Richtungen, so entspricht dies einer $1:1$-Beziehung. Sowohl Attributschlüssel als auch Kantenbezeichner lassen sich gruppieren, dies ermöglicht ein effizienteres Abfragen von Attributen und Beziehungen.\footnote{Eine mögliche Gruppierung von Kanten sind zum Beispiel die Beziehungen zwischen Mitarbeiter und Projekt gruppiert nach Abteilung.} 

Neben dem Namen und der Eindeutigkeit definiert ein \texttt{TitanKey} den Datentyp des zugeordneten Attributwertes, was zum Einen dessen Wertebereich festlegt und zum Anderen die effizientere Speicherung ermöglicht. Des Weiteren können Attributschlüssel indexiert und somit der direkte, effiziente Zugriff auf die zugehörigen Instanzen unter Angabe von Schlüssel-Wert-Paaren realisiert werden.\\
Im Gegensatz dazu lässt sich an einem \texttt{TitanLabel} ein Primärschlüssel festlegen: Weist eine Kante das entsprechende Attribut auf, erlaubt dies das effizientere Auslesen inzidenter Kanten unter Angabe eines Wertes oder Wertebereiches.\footnote{Besitzt eine Beziehung vom Mitarbeiter zum Projekt einen Zeitstempel, welcher den Beitritt des Mitarbeiters datiert, und ist dieser Zeitstempel ein Primärschlüssel, dann lassen sich Anfragen wie zum Beispiel \textit{An welchen Projekten hat Mitarbeiter x im Mai 2013 mitgearbeitet?} effizienter beantworten.} Dies ist ein Alleinstellungsmerkmal von Titan und verspricht eine höhere Performance beim Traversieren des Graphen. Aurelius bezeichnet dieses Konzept als \textit{vertex-centric indices}. Neben dem Primärschlüssel kann ein Kantenbezeichner eine Signatur definieren: Diese gibt an, welche Attribute die zugehörigen Kanteninstanzen besitzen bzw. voraussichtlich besitzen und verspricht ein effizienteres Speichern und Laden von Attributen.\\
Kanten sind standardmäßig gerichtet und können in beiden Richtungen traversiert werden. Titan bietet hierfür jedoch eine Einschränkung: Kanten können uni-direktional sein, was bedeutet, dass sich diese nur vom Start- zum Zielknoten traversieren lassen. Hierdurch kann Speicherplatz am Zielknoten gespart werden, zu beachten ist jedoch, dass ein Löschen des Zielknotens nicht das Löschen der Kante erfordert und das Einhalten der referentiellen Integrität damit in der Verantwortung der Anwendung liegt.

% Identität
Die Identität von Knoten- und Kanteninstanzen wird analog zu Neo4j durch eine 64-Bit-Ganzzahl repräsentiert.\footnote{Nachzuvollziehen unter \url{https://github.com/thinkaurelius/titan/blob/0.3.2/titan-core/src/main/java/com/thinkaurelius/titan/core/TitanElement.java\#L52}.} Diese wird vom GDBMS vergeben und nach dem Löschen von Instanzen wiederverwendet. Unter Angabe einer Identität lässt sich auf die zugehörige Instanz zugreifen, dies entspricht der Definition eines Primärschlüssels.

% Anzahl der Datenbanken (wie Partitionierung)
Titan verwaltet genau eine Graphdatenbank, dieser sind alle Knoten und Kanten zugeordnet. Eine anwendungsseitige Partitionierung der Knoten- und Kantenmenge zur unabhängigen Verwaltung von Teilgraphen ist ausschließlich unter Verwendung dedizierter Attribute möglich.

% Flexiblität
Aus den Ausführungen geht hervor, dass Titan sehr flexibel bezüglich der Definition, Änderung und Verwendung eines Schemas ist. Analog zu Neo4j ist die Definition von Kantenbezeichnern im Gegensatz zu ihrer Berücksichtigung innerhalb von Anfragen obligatorisch. Die hinterlegten Nutzdaten sind semi-strukturiert und lassen sich dynamisch zur Laufzeit manipulieren. Wird auf das manuelle Erzeugen von \texttt{TitanKeys} verzichtet, können einem Attributschlüssel Attributwerte verschiedenen Datentyps zugeordnet sein. Wie die bisher betrachteten GDBMS empfiehlt jedoch auch Titan die manuelle Typ-Definition um von den genannten Vorteilen zu profitieren.


\subsection{Zugriffsmechanismen, Transaktionen und Indexverwaltung}

Titan implementiert ebenfalls die Blueprints API\footnote{An dieser Stelle sei angemerkt, dass es sich bei der Blueprints API um einen Quasi-Standard für GDBMS handelt. Viele Anbieter, u.a. Neo4j, Dex und InfiniteGraph, bieten neben ihren proprietären APIs eine Implementierung der Blueprints API an. Diese Implementierung bildet CRUD-Operationen auf die proprietäre API ab und stellt somit eine zusätzliche Indirektion im Aufruf dar. Teilweise kann hierdurch nicht der volle Funktionsumfang des GDBMS genutzt werden. OrientDB und Titan implementieren die Blueprints API hingegen nativ, was bedeutet, dass Aufrufe unmittelbar an das GDBMS weitergegeben werden und der komplette Funktionsumfang zur Verfügung steht.} und stellt somit hinsichtlich CRUD-Operationen den gleichen Funktionsumfang wie OrientDB zur Verfügung. Analog zu Letztgenannter erweitert Titan die API um Funktionen zum Erzeugen von Typen. Diese sind Instanzen von \texttt{TitanKey} bzw. \texttt{TitanLabel} und lassen sich unter Anwendung der beschriebenen Einschränkungen definieren. Ein Beispiel hierfür findet sich in Anhang \ref{anh:titan_blueprints_api}. Aufgrund der Implementierung der Blueprints API können alle im Rahmen des TinkerPop-Projektes angebotenen Werkzeuge in Titan verwendet werden. Neben der bereits im Zusammenhang mit OrientDB beschrieben Algorithmensammlung Furnace ist dies u.a. Gremlin, eine Sprache zur Traversierung und Mustersuche in Property-Graphen.

\paragraph*{CRUD-Operationen via Gremlin}

Gremlin ist eine imperative, graphenorientierte Anfragesprache für den lesenden und schreibenden Zugriff auf die Datenbasis. Das TinkerPop-Projekt bietet Gremlin für verschiedene JVM-Sprachen an, in den nachfolgenden Beispielen wird die Groovy-Syntax verwendet.\footnote{Groovy ist eine dynamische Programmiersprache für die Java-Plattform: \url{http://groovy.codehaus.org/}.} Aufgrund ihrer Kernfunktion, dem Beschreiben abstrakter Wege zur Traversierung des Graphen, wird Gremlin als  \textit{graph traversal language} bezeichnet. Das Finden von Mustern innerhalb der Datenbasis ist jedoch ebenfalls möglich. Analog zu Cypher handelt es sich um eine nicht standardisierte Sprache, sie kann jedoch in allen GDBMS eingesetzt werden, welche die Blueprints API implementieren und wird von Titan als primäre Anfragesprache angeboten. Nachfolgend werden die grundlegenden Komponenten erläutert, die vollständige Beschreibung der Sprache kann der offiziellen Dokumentation entnommen werden\cite{gremlin_doku:2013}.
	
\begin{figure}[h] 
	\centering
		\includegraphics[scale=1]{titan_example.pdf}
	\caption[Titan: Beispielgraph]{Erweitertes Beispiel eines Property-Graphen. Kanten mit ausgefüllter Spitze modellieren eine $n:m$- Beziehung und können mehrfach innerhalb der Nachbarschaft eines Knotens vorkommen. Kanten mit leerer Spitze modellieren eine $1:n$-, Kanten mit einem Karo am Startknoten eine $n:1$-Beziehung. Mitarbeiter können folglich mit beliebig vielen Kollegen zusammenarbeiten, jedoch nur an einem Projekt mitwirken. Nur ein Mitarbeiter darf für ein Projekt verantwortlich sein, dieser darf jedoch nicht die Verantwortung über weitere Projekte übernehmen. Hervorgehobene Attributschlüssel sind indexiert, Knoten können unter Angabe eines entsprechenden Schlüssel-Wert-Paares direkt gelesen werden.}
	\label{fig:titan_example}
\end{figure}	

% Manipulation (Einfügen Knoten / Kante)

Abbildung \ref{fig:titan_example} zeigt eine mögliche Realisierung des Mitarbeiter-Projekt-Beispiels in Titan. Zu beachten sind dabei die zusätzlichen Einschränkungen an einzelnen Beziehungsarten. Für die Definition von Typen für Attributschlüssel und Kantenbezeichner erweitert Titan die Sprache um Hilfsfunktionen.  Zum Beispiel lässt sich ein \texttt{TitanKey} für den Attributschlüssel \texttt{name} wie folgt definieren:

\texttt{g.makeType().name('name').unique(OUT).indexed(Vertex.class)}\newline
\texttt{.dataType(String.class).makePropertyKey();}

In Gremlin werden Befehle durch die Verkettung bzw. Komposition von Funktionen gebildet, ein Befehl wird immer von links nach rechts gelesen: Im Beispiel ist \texttt{g} eine Referenz auf den verwalteten Graphen; die Funktion \texttt{name('name')} definiert den global eindeutigen Attributschlüssel; \texttt{unique(OUT)} legt die Eindeutigkeit des Attributes auf Instanzebene fest; die Funktion \texttt{indexed(Vertex.class)} erzeugt einen Index für Knoteninstanzen mit dem entsprechenden Attribut; \texttt{dataType(String.class)} legt den Datentyp des Attributwertes fest und \texttt{makePropertyKey()} erzeugt den Typen innerhalb der Datenbasis.

Ein \texttt{TitanLabel} lässt sich ebenfalls durch die Verkettung der benötigen Funktionen definieren. Soll zum Beispiel der Kantenbezeichner \texttt{WORKS\_IN} für die zugehörige $n:1$-Beziehung zwischen Mitarbeiter und Projekt erzeugt werden, so erfolgt dies mit der Anweisung:

\texttt{g.makeType().name('WORKS\_IN').unique(OUT).makeEdgeLabel();}

Für Kantenbezeichner legt die Funktion \texttt{unique(OUT)} fest, dass eine entsprechend deklarierte Kanteninstanz in der Menge ausgehender Kanten eines Startknotens höchstens einmal vorkommen darf; \texttt{makeEdgeLabel()} erzeugt den Typen innerhalb der Datenbasis. Anzumerken ist, dass bei der Definition eines Kantenbezeichners keine Festlegung auf bestimmte Knotentypen für Start- oder Zielknoten erfolgt.

Gremlin ermöglicht die Manipulation der Datenbasis und stellt Funktionen für das Anlegen und Löschen von Knoten und Kanten zur Verfügung. Nachfolgend wird beispielhaft eine Knoteninstanz für den Mitarbeiter \texttt{Eve} angelegt und an eine Variable gebunden:

\texttt{eve = g.addVertex([type:\string'Employee',name:'Eve',age:27]);}

Titan unterstützt keine Knotenbezeichner, ist eine Unterscheidung der Instanzen erforderlich, muss hierfür ein dediziertes Attribut definiert werden. Im gezeigten Beispiel ist dies der Attributschlüssel \texttt{type}. Das Aktualisieren von Knoten- und Kantenattributen ist ebenfalls möglich und erfolgt direkt an der Instanz.

Beim Erzeugen einer Kante, gibt die Reihenfolge der Parameter die Richtung vor, der Kantenbezeichner wird als Zeichenkette an die Funktion übergeben. Existiert keine zugehörige \texttt{TitanLabel}-Instanz, erzeugt das GDBMS diese mit Standardeinstellungen. Der Befehl

\texttt{g.addEdge(eve,projectX,'WORKS\_IN');}

fügt der Datenbasis eine gerichtete Kante von \texttt{Eve} nach \texttt{ProjectX} hinzu. Kantenattribute können, wie bereits für Knoten gezeigt, ebenfalls an die Funktion übergeben werden.

\paragraph*{Traversierung via Gremlin}
% Selektion von Instanzen
Gremlin ermöglicht das algorithmische Durchlaufen des Graphen entweder ausgehend von einer einzelnen Knoten- bzw. Kanteninstanz oder von einer Instanzmenge. Dabei erlaubt eine Referenz auf den Graphen mit der Anweisung \texttt{g.V} bzw. \texttt{g.E} den Zugriff auf die gesamte Knoten- bzw. Kantenmenge. Die Auswahl einzelner oder mehrerer Instanzen erfolgt entweder explizit unter Angabe einer Identität oder mengenorientiert anhand eines Schlüssel-Wert-Paares:

\texttt{bob = g.V(23) // direct access via ID 23} \newline 
\texttt{employees = g.V('type','Employee') // set oriented access} 

Die erste Anweisung bindet die Knoteninstanz mit der Identität 23 an die Variable \texttt{bob} während in der zweiten Anweisung die Menge aller Mitarbeiter der Variable \texttt{employees} zugewiesen wird. Das Auslesen der Attributwerte erfolgt entweder durch die direkte Verkettung mit dem Attributschlüssel (z.B. \texttt{bob.name}) oder durch Anwendung der \texttt{map}-Funktion (z.B. \texttt{bob.map('name','age')}).

% Traversierung = Funktionsverkettung
Das Konzept der Komposition wird in Gremlin zur Definition abstrakter Wege innerhalb des Graphen genutzt. Hierfür stellt die Sprache entsprechende Funktionen, sog. \texttt{steps} zur Verfügung.\footnote{Eine Übersicht über alle verfügbaren Funktionen findet sich unter \url{https://github.com/tinkerpop/gremlin/wiki/Gremlin-Steps}.} Jeder Funktionsaufruf kann als Schritt innerhalb des Pfades interpretiert werden und wird auf die Ergebnismenge des vorhergehenden Schrittes angewendet. Eine komplette Anweisung verkettet einzelne Schritte zu einem abstrakten Weg. Sollen beispielsweise die ausgehenden Kanten des Mitarbeiters \texttt{Bob} traversiert werden, ist dies mit folgender Verkettung möglich:

\texttt{bob.out}

Das Ergebnis dieser einfachen Traversierung ist eine Menge von Knoten-Identitäten, welche über eine ausgehende Kante mit \texttt{Bob} verbunden sind. Letzteres wird durch die Richtungsfunktion \texttt{out} formuliert. Soll direkt auf Attributwerte der adjazenten Knoten zugegriffen werden, erfordert dies das Anfügen des entsprechenden Attributschlüssels\footnote{Die Ausgabe berücksichtigt nur jene Knoten die das entsprechende Attribut aufweisen.} (z.B. \texttt{bob.out.name}). Aus Sicht eines Knotens lässt sich darüber hinaus mit Hilfe der Richtungsfunktion \texttt{in} bzw. \texttt{both} auf adjazente Knoten zugreifen, die über eine eingehende Kante bzw. über eine Kante beliebiger Richtung mit einem Knoten verbunden sind. Die Funktionen \texttt{outE}, \texttt{inE} und \texttt{bothE} ermitteln die zu einem Knoten inzidenten Kanten, welche wiederum mittels \texttt{outV} bzw. \texttt{inV} das Abrufen ihres jeweiligen Start- bzw. Zielknotens erlauben. Die Traversierungen \texttt{bob.out} und \texttt{bob.outE.inV} sind folglich äquivalent.

% Einschränkung Kantenbezeichner
Die Einschränkung zu traversierender Kanten ist durch die Angabe von Kantenbezeichnern möglich. Diese werden als Parameter an die entsprechende Richtungsfunktion übergeben. Sollen zum Beispiel die Namen der Mitarbeiter bestimmt werden, die an einem Projekt arbeiten, für das \texttt{Bob} verantwortlich ist, so lässt sich dies mit folgender Anweisung realisieren:

\texttt{bob.out('RESPONSIBLE\_FOR').in('WORKS\_IN').name}

Dabei werden im ersten Schritt die Projekte traversiert für die \texttt{Bob} direkt verantwortlich ist. Im zweiten Schritt werden ausgehend von jedem Projekt die eingehenden Kanten vom Typ \texttt{WORKS\_IN} traversiert um zu den entsprechenden Mitarbeitern zu gelangen.

% Einschränkung Attribute
Neben der Einschränkung der Kantenbezeichner kann in Gremlin auch auf Grundlage der Attribute entschieden werden, ob eine Instanz bei der Traversierung berücksichtigt wird. Die Sprache bietet hierfür die Funktion \texttt{filter}: Diese ermöglicht das Definieren eines sog. Closure, mit dem sich für jedes Element einer Ergebnismenge entscheiden lässt, ob es im nächsten Schritt berücksichtigt wird. Sollen zum Beispiel alle Kollegen von \texttt{Bob} selektiert werden, welche seit 2012 mit ihm zusammenarbeiten und älter als 25 sind, so ist dies wie folgt möglich:

\texttt{bob.bothE('WORKS\_WITH').filter\{it.since > 2011\}.bothV.filter\{it.age > 25\}}

Ausgehend vom Startknoten werden zunächst unter Verwendung von \texttt{bothE} aus- und eingehende Kanten mit dem Bezeichner \texttt{WORKS\_WITH} traversiert. Aus der Menge der inzidenten Kanten werden mittels \texttt{filter\{it.since > 2011\}} jene Instanzen ausgewählt, welche das Prädikat erfüllen. Die Variable \texttt{it} referenziert dabei ein Element in der Ergebnismenge des vorhergehenden Schrittes. Anschließend liest \texttt{bothV} Start- und Zielknoten der Kante aus und filtert jene, die älter als 25 sind. Knoten- und Kanteninstanzen werden in Gremlin standardmäßig mehrfach besucht. Bei genauer Betrachtung des Beispiels wird deutlich, dass ein Berücksichtigen von Start- und Zielknoten auch \texttt{Bob} in die Ergebnismenge der Traversierung einschließt. Dies lässt sich mit der Funktion \texttt{except} vermeiden:

\texttt{bob.bothE('WORKS\_WITH').filter\{it.since > 2011\}.bothV.except([bob])}\newline
\texttt{.filter\{it.age > 25\}}

Innerhalb der Filterbedingung können verschiedene mathematische, boolesche und string-basierte Funktionen verwendet und kombiniert werden. Entscheidend ist lediglich, dass der Rückgabewert ein Wahrheitswert ist.
	
% feste / variable Pfadlängen (Erreichbarkeit)
Die bisher betrachteten abstrakten Wege sind statisch definiert und besitzen eine feste Länge. Für das Traversieren von Wegen beliebiger Länge bietet Gremlin die \texttt{loop}-Funktion. Diese erlaubt es, definierte Abschnitte innerhalb eines Weges zu wiederholen. Soll zum Beispiel bestimmt werden, welche Mitarbeiter zwei Schritte von \texttt{Bob} entfernt sind, so ist dies mit folgender Anweisung realisierbar:

\texttt{bob.as('b').out('WORKS\_WITH').loop('b')\{it.loops < 3\}}

Die Funktion \texttt{as('b')} legt dabei den Beginn, \texttt{loop('b')} das Ende des zu wiederholenden Abschnittes fest. Die Anzahl der Wiederholungen wird durch eine \texttt{while}-Bedingung definiert, \texttt{it.loops} referenziert dabei eine Laufvariable zu einer konkreten Pfadinstanz. Das Ergebnis der Traversierung ist die Menge der Endknoten der gefundenen Pfadinstanzen. Alternativ können durch Anfügen der Funktion \texttt{path} die Pfadinstanzen als Ergebnis zurückgegeben werden. In Verbindung mit einem zusätzlichen Abbruchkriterium an der \texttt{loop}-Funktion ermöglicht dies das Berechnen von Pfaden zwischen zwei Instanzen:

\texttt{alice.as('a').out.loop('a')\{it.loops < 4\}\{it.object.name == 'ProjectX'\}.path}

Das Ergebnis ist eine Menge von Pfaden, mit einer maximalen Länge von Drei zwischen \texttt{Alice} und \texttt{ProjectX}. Das Auswählen des kürzesten Pfades ist durch anschließendes Sortieren nach Pfadlänge und Einschränken der Ergebnismenge auf ein Element möglich.

% Aggregation
Analog zu Cypher und OrientDB-SQL unterstützt Gremlin das Gruppierung von Ergebnismengen. Da Gremlin eine Obermenge von Java und somit turing-vollständig ist, lassen sich zum Beispiel Aggregationen durch Java-Funktion umsetzen. Nachfolgendes Beispiel bestimmt das Alter des ältesten Mitarbeiter:

\texttt{oldest = Integer.MIN\_VALUE;}\newline
\texttt{g.V('type','Employee').sideEffect\{oldest=(oldest<it.age)?it.age:oldest\}}

Die Funktion \texttt{sideEffect} kann dazu verwendet werden, den Zustand globaler Variablen zu verändern. Im Beispiel führt der ternäre Ausdruck genau dann zur Aktualisierung der Variable \texttt{oldest} wenn der aktuelle Mitarbeiter älter ist als die bisher betrachteten.\\
Das Einschränken der Ergebnismenge ist durch die Angabe eines Intervalls möglich. Das Bestimmen der drei jüngsten Mitarbeiter ist zum Beispiel wie folgt möglich:

\texttt{g.V('type','Employee').age.order[0..1]}

Dabei sortiert die \texttt{order}-Funktion die entsprechenden Attributwerte in natürlicher Ordnung und der Filter \texttt{[0..1]} selektiert die ersten beiden Elemente der Ergebnismenge.
	
\paragraph*{Mustersuche via Gremlin} 

In den bisherigen Beispielen wurden entweder Knoten- oder Kanteninstanzen am Ende eines abstrakten Weges, deren Attribute oder komplette Pfadinstanzen als Ergebnis einer Traversierung ausgegeben. Darüber hinaus erlaubt Gremlin das Suchen und Extrahieren von Teilgraphen innerhalb der Datenbasis. Abbildung \ref{fig:titan_pattern} zeigt den bereits für die Evaluation von Cypher verwendeten Mustergraphen.

\begin{figure}[h] 
	\centering
		\includegraphics[scale=1]{titan_pattern.pdf}
	\caption[Titan: Mustergraph]{Beispiel für einen Mustergraphen: Der grau hinterlegte Knoten ist eine Konstante und stellt die Bindung zur Datenbasis her, weiß hinterlegte Knoten sind Variablen, welche während der Mustersuche gebunden werden.}
	\label{fig:titan_pattern}
\end{figure}

Da sich dieses Muster nicht als lineare Sequenz von Knoten und Kanten darstellen lässt, wurde es in Cypher in zwei abstrakte Wegdefinitionen zerteilt. Gremlin begegnet dieser Situation mit dem sog. \textit{Backtracking}. Mit Hilfe der \texttt{back}-Funktion lässt sich an einem beliebigen Punkt innerhalb des abstrakten Weges entweder eine feste Anzahl von Schritten oder direkt zu einem definierten Punkt zurückgehen. Folgendes einfaches Beispiel soll dies verdeutlichen: Gesucht sind alle Kollegen von Alice, die mit Kollegen zusammenarbeiten, die älter als 25 sind:

\texttt{alice.out('WORKS\_WITH').as('a').out('WORKS\_WITH').filter\{it.age>25\}.back('a')}

Dabei werden die adjazenten Knoten von \texttt{Alice} mit \texttt{as('a')} markiert, anschließend werden deren adjazente Knoten entsprechend dem geforderten Prädikat eingeschränkt. Erfüllt ein Nachbar das Prädikat, springt die Traversierung auf den vorher besuchten Knoten zurück und gibt ihn aus.\\
Dieses Konzept kann für die Mustersuche genutzt werden. Im Beispiel ist \texttt{Alice} die Konstante innerhalb des Musters mit der Bindung an die Datenbasis, \texttt{b}, \texttt{c} und \texttt{d} sind Variablen. Für Kanten- und Knoteninstanzen sind Einschränkungen hinsichtlich ihres Typs bzw. ihres Bezeichners festgelegt. Die nachfolgende Anfrage sucht alle Teilgraphen des entsprechenden Musters aus der Datenbasis und bindet die Variablen an die gefundene Instanzen:

\texttt{t = new Table('a','b','c','d'); // stores results}\newline
\texttt{alice.as('a') // 1}\newline
\texttt{.out('WORKS\_WITH').has('type','Employee').as('b') // 2}\newline
\texttt{.out('RESPONSIBLE\_FOR').has('type','Project').as('d') // 3}\newline
\texttt{.back('b') // 4}\newline
\texttt{.out('WORKS\_WITH').has('type','Employee').except('a').as('c') // 5}\newline
\texttt{.both.has('type','Employee').retain('a') // 6}\newline
\texttt{.table(t); // store results into t}

Zunächst wird eine \texttt{Table}-Datenstruktur erzeugt, welche die geforderten Instanzen innerhalb der gefundenen Teilgraphen aufnehmen soll. In Schritt 1 wird die Konstante \texttt{Alice} an den Bezeichner \texttt{a} gebunden; anschließend werden die ausgehenden \texttt{WORKS\_WITH}-Beziehungen traversiert und die Menge der Zielknoten auf jene eingeschränkt, die vom Typ \texttt{Employee} sind.\footnote{Die Funktion \texttt{has(key, value)} ist eine Kurzform der \texttt{filter}-Funktion und liefert \texttt{true}, wenn die entsprechende Instanz das Schlüssel-Wert-Paar aufweist, andernfalls \texttt{false}.} Die Menge der Knoten wird der Variable \texttt{b} zugewiesen. Anschließend werden in Schritt 3 deren Projekte selektiert und diese Menge der Variable \texttt{d} zugewiesen. Mittels Backtracking wird in Schritt 4 zurück zu den Projektleitern gegangen. Von diesen ausgehend erfolgt anschließend das Traversieren der ausgehenden \texttt{WORKS\_WITH}-Beziehungen. Die Menge der Zielknoten wird entsprechend ihrem Typ gefiltert und der Variable \texttt{c} zugewiesen. Dabei wird eine eventuell existierende Kante zu \texttt{a} nicht berücksichtigt. In Schritt 6 werden alle inzidenten Kanten der Elemente in \texttt{c} traversiert und dabei mittels \texttt{retain} nur jene Start- bzw. Zielknoten berücksichtigt die \texttt{a} entsprechen. Im letzten Schritt werden die gefunden Instanzen in die vorher definierte Tabelle eingefügt. Jede Zeile innerhalb dieser Tabelle entspricht einem gefundenen Teilgraph innerhalb der Datenbasis.

Die gezeigten Beispiele erlauben einen ersten Einblick in die Ausdrucksstärke der Sprache. Durch die Universalität hinsichtlich der Programmierbarkeit ist Gremlin ein mächtiges Werkzeug in der Verarbeitung von Graphen. Optimierungen in der Anfrageausführung sind in erster Linie von der Implementierung des jeweiligen GDBMS abhängig. Gremlin selbst nutzt, wenn vorhanden, globale Indexstrukturen für das effiziente Auffinden von Knoten und Kanten anhand ihrer Attribute sowie die bereits erwähnten knoten-zentrierten Indizes. Der Ausführungsplan lässt sich ebenfalls ausgeben, was eine manuelle Optimierung zulässt. Auf konkrete Optimierungsmechanismen wird in \cite{gremlin_doku:2013} eingegangen.
	
\paragraph*{Transaktionen}

% obligatorisch
% Erzeugen (implizit, explizit)
% Schachtelung
% BerkeleyDB siehe OrientDB
	% Dauerhaftigkeit ist standardmäßig aktiviert (Quelltext)
	% REPEATABLE READ (keine Mehrbenutzeranomalien)
	% Behandlung von Deadlocks
% Transaktionen innerhalb von Titan?
- nur für inkonsistente Speichersysteme
	- MVCC
- Locks auf Unique Typen

Since edges and properties of unique labels and keys must be unique per vertex, inconsistencies could arise when two TitanGraph instances try to update the same unique edge or property concurrently, since one may overwrite the change of the other. To avoid such inconsistencies, Titan will acquire locks on unique edges and properties by default. Acquiring locks, however, can be very expensive depending on the storage backend. In cases where concurrent modifications can be excluded or blind overwrites are acceptable, a unique TitanType can be configured to not acquire locks by passing in UniquenessConsistency.NO\_LOCK as a second argument to TypeMaker.unique(). This configuration option should be used with care and only if the extra performance gain is needed.
	

% Anmerkung zu Cassandra und HBase

\paragraph*{Indexverwaltung}

% Primary Key
% Property-Index
- interne Indexstrukturen auf Attributen
\texttt{g.createKeyIndex("name", Vertex.class)}
	- Graph.query()
	- Besonderheiten: Geosuche, Volltextsuche

- externe Indeximplementierungen
	- ElasticSearch
	- Lucene

	% Aktualisierung (autmatische, manuelle Indizes)
	% Beispiel
% Vertex-centric Index!
- Vertex-Centric Indices
	- Supernode-Problem (Hubs, große Nachbarschaft, sehr großer Knotengrad)
	- B-Baum zur Indizierung inzidenter Knoten ermöglicht schnellen Lookup bei Einschränkung auf Richtung, Kantenbezeichner und -attribute
		- disk-zentriertes Sortieren und Indexierung ->mehrdimensionaler Index
			- Kantenbezeichner -> Attribut
		- Vertex.query()
	- \texttt{final TitanKey time = graph.makeType().name(\string"time\string").dataType(Integer.class).makePropertyKey();}
	- \texttt{graph.makeType().name(\string"battled\string").primaryKey(time).makeEdgeLabel();}
	- $\mathcal{O}(\log(\left|N_v\right|))$
	

% Erweiterung?

\subsection{Persistenz- und Cacheverwaltung}

% https://groups.google.com/forum/?hl=de#!searchin/aureliusgraphs/storage$20single$20machine/aureliusgraphs/qO9Bi-y7uLs/EG5Ol-ulHjAJ

- Data Management
	- immutable atomic edges
	- OCC
	- feingranulares Locking auf Knoten- und Kantenebene
- Edge Compression

- Vertex-Centric Indizes
% BerkeleyDB: B-Baum, Transaktions-Log
% Abbildung des Graphen auf KV-Store (reicht!)
- Kantenkompression
	- Speicherung der ID-Differenz zwischen Ziel- und Startknoten
% Komplexität Nachbarschaft / Traversierung
- abhängig vom Speichersystem
	- BerkeleyDB logarithmisch

\paragraph*{Cacheverwaltung}

% BerkeleyDB
% eigene Caches

\subsection{Verteilung und Skalierbarkeit}
\label{subsec:titan_verteilung}

% BerkeleyDB ausschließlich zentral
% Replikation und Partitionierung via Cassandra / HBase
- Cassandra
	- Hochverfügbarkeit (Replikation)
	- Peer-To-Peer Verteilung (Distributed Hashtable)
	- Caching
	- Eventual Consistency
- HBase
	- lineare Skalierbarkeit
	- Strong Consistency
	
% vielleicht kurz beschreiben (+Skalierbarkeit)