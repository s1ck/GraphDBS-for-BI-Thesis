\chapter{Benchmark von Graphdatenbanksystemen}
\label{cha:benchmark}

Dieses Kapitel dient der Bewertung von Neo4j und Titan hinsichtlich ihrer Leistungsfähigkeit bei der Ausführung verschiedener graphenspezifischer Operationen. Dabei ist es von besonderem Interesse, ob sich die im vorhergehenden Kapitel aufgeführten funktionalen Unterschiede auf die Performance auswirken. Zusätzlich soll beurteilt werden, inwieweit sich Cypher und Gremlin zur Formulierung analytischer Anfragen eignen. Zunächst werden Testgraphen, Operationen und das Testsystem vorgestellt. Es wird weiterhin auf die Konfiguration der einzelnen GDBMS sowie auf die Methodik bei der Durchführung der Messungen eingegangen. Im zweiten Teil des Kapitels werden die Ergebnisse vorgestellt und bewertet.

\section{Testumgebung}

Bei der Analyse verwandter Arbeiten wurde festgestellt, dass aktuell - Stand Oktober 2013 - kein standardisierter Benchmark für GDBMS existiert. Daher wurde sich bei der Vorbereitung und Durchführung an den Empfehlungen von Dominguez-Sal et al.\cite{Dominguez-Sal2011} orientiert, da diese u.a. auch in den verwandten Arbeiten von Ciglan et al.\cite{Ciglan:2012} und Gehrels\cite{Gehrels:2013} berücksichtigt werden.

\subsection{Datengrundlage}

Bei der Vorbereitung des Benchmarks wurde sich dafür entschieden, reale Datensätze als Datengrundlage zu verwenden. Das in Abschnitt \ref{sec:anforderungen} beschriebene Forschungsvorhaben sieht vor, Informationsnetzwerke aus unterschiedlichen Geschäftsinformationssystemen zu integrieren und den daraus resultierenden Graphen anschließend zu analysieren. Die Netzwerke in den Quellsystemen können dabei verschiedene topologische Eigenschaften aufweisen und die in ihnen gespeicherten Informationen unterschiedlichen Klassen zugeordnet sein. Ein ERP-System verwaltet zum Beispiel Rechnungen, während ein CRM-System vorrangig Kundenaktivitäten speichert. Durch die unterschiedlichen Wechselwirkungen zwischen den Entitäten innerhalb der einzelnen Quellsysteme entstehen verschiedenartige Beziehungsstrukturen. Der integrierte Graph ist folglich hinsichtlich Topologie und Nutzdaten heterogen.\\
Die in den verwandten Arbeiten eingesetzten Algorithmen zur Erzeugung von Zufallsgraphen bilden ausschließlich homogene Netzwerke ab, in denen alle Knoten einer Klasse zugeordnet sind. In \cite{Holzschuher:2013:PGQ:2457317.2457351} sind es zum Beispiel Nutzer innerhalb eines sozialen Netzwerkes, in \cite{Ciglan:2012} und \cite{Gehrels:2013} wird generell auf eine Klassifizierung der Informationen verzichtet. Das Erzeugen synthetischer, heterogener Graphen hingegen ist sehr aufwändig, da jeder Klasse und jeder Beziehungsart eine eigene Logik hinsichtlich ihrer Erzeugung zugeordnet werden muss.

Da reale Daten aus Geschäftsinformationssystemen nicht frei zur Verfügung stehen, werden stellvertretend für heterogene Netzwerke \texttt{amazon-meta}\cite{snap_amazon:2013} und \texttt{sec-Pokec}\cite{snap_pokec:2013} verwendet, beides Datensätze des Stanford Network Analysis Project\footnote{\url{https://snap.stanford.edu/}}. \texttt{amazon-meta} beinhaltet Produktinformationen des Onlinehändlers Amazon\footnote{\url{http://www.amazon.com}}, dazu zählen u.a. deren Bewertungen und Beziehungen zu anderen Produkten\footnote{Es handelt sich dabei um ähnliche Produkte, die laut Amazon oft zusammen gekauft werden.}. Pokec\footnote{\url{http://pokec.azet.sk/}} ist ein slowakisches, soziales Online-Netzwerk. Abbildung \ref{fig:testdata} zeigt das integrierte Schema beider Netzwerke als Property-Graph.

\begin{figure}[h] 
	\centering
		\includegraphics[scale=.75]{schema.pdf}
	\caption[Benchmark: Schema Testdaten]{Integriertes Schema aus Amazon- und Pokec-Daten.}
	\label{fig:testdata}
\end{figure}

Beide Datensätze verfügen über eine Klasse \texttt{User}. Deren Instanzen werden innerhalb von \texttt{amazon-meta} durch eine eindeutige Identität repräsentiert und besitzen keine Beziehungen zueinander. In \texttt{soc-Pokec} hingegen weisen die Instanzen eine Vielzahl von Attributen auf und sind durch gerichtete \texttt{FRIEND\_OF}-Beziehungen miteinander verbunden. Die Anzahl der Nutzer stimmt in beiden Netzwerken annähernd überein, \texttt{amazon-meta} weist ca. 1.5 Mio., \texttt{soc-Pokec} etwa 1.6 Mio. Nutzer auf. Im Rahmen der Vorverarbeitung der Datensätze wurden zunächst Pokec-Nutzer per Zufall auf Amazon-Nutzer abgebildet, anschließend wurde der durch die ausgewählten Knoten induzierte Teilgraph aus \texttt{soc-Pokec} extrahiert und mit den Amazon-Daten zu einem integrierten Graph zusammengeführt.\\
Die Netzwerke enthalten neben den topologischen Informationen auch Nutzdaten, diese wurden bei Amazon vollständig aus den Rohdaten übernommen, bei Pokec hingegen wurde eine Auswahl von Attributen unterschiedlichen Datentyps getroffen. Die Rohdaten beider Netzwerke wurden in das Geoff-Format\footnote{\url{http://nigelsmall.com/geoff}} überführt, ein von Neo4j konzipiertes Format zur textuellen Repräsentation von Property-Graphen.

Ein wichtiges Kriterium bei der Durchführung eines Benchmarks ist das Leistungsverhalten einer Anfrage auf Datensätzen unterschiedlicher Größe. Ein Defizit bei der Verwendung realer Datensätze ist hingegen deren festgelegte Größe. Mit dem Ziel, die Skalierbarkeit von Anfragen dennoch testen zu können, wurden zusammenhängende Teilgraphen aus dem integrierten Datensatz extrahiert. Die Teilgraphen sind bezüglich der Knoten aus \texttt{amazon-meta} induziert, in Bezug auf die enthaltenen Nutzerbeziehungen handelt es sich um einen einfachen Teilgraphen aus \texttt{soc-Pokec}. Der für die Extraktion entwickelte Algorithmus wird in Anhang \ref{anh:extraction} beschrieben.\\
Dominguez-Sal et al. empfehlen die Angabe eines Skalierungsfaktors bei der Unterscheidung der Testgraphen, hierfür wurde die Anzahl der Produkte innerhalb des Teilgraphen gewählt.  Die Tabellen \ref{tab:datasets_nodes} und \ref{tab:datasets_edges} stellen den integrierten Graph (\texttt{orig}) und die extrahierten Teilgraphen hinsichtlich der Anzahl Knoten und Kanten gruppiert nach ihrer jeweiligen Klasse gegenüber. Zusätzlich wird für jeden Wert der Skalierungsfaktor in Bezug auf den Wert im nächstkleineren Graphen angeben. Ein Nachteil des gewählten Ansatzes ist, dass sich die topologischen Eigenschaften zwischen den verschiedenen, extrahierten Teilgraphen unterscheiden können, dies wird bei der nachfolgenden Bewertung berücksichtigt.

\renewcommand{\arraystretch}{1.25}
\begin{table}[h]
	\centering
	\begin{footnotesize}
   	\begin{tabular}{|l|rl|rl|rl|rl|rl|rl|rl|rl|rl|}
	\hline
   	 & \multicolumn{8}{c|}{\textbf{Knoten}} & \multicolumn{2}{c|}{\textbf{Attribute}} \\ \cline{2-11}
   	\textbf{Graph} & \multicolumn{2}{c|}{\texttt{Group}} & \multicolumn{2}{c|}{\texttt{Product}} & \multicolumn{2}{c|}{\texttt{User}} & \multicolumn{2}{c|}{$\Sigma$} & \multicolumn{2}{c|}{$\Sigma$} \\
   	\hline
   	   	\hline
   	\texttt{orig} & \multicolumn{2}{c|}{10} & \multicolumn{2}{c|}{542\,684} & \multicolumn{2}{c|}{1\,555\,124} & \multicolumn{2}{c|}{2\,097\,819} & \multicolumn{2}{c|}{20\,377\,902} \\
   	\hline
   	\hline
	\texttt{p\_100} & 1 & (1) & 126 & (1) & 347\,752 & (1) & 347\,879 & (1) & 1\,874\,907 & (1)\\
	\hline
	\texttt{p\_1K} & 4 & (4) & 1\,089 & (8.64) & 665\,116 & (1.91) & 666\,209 & (1.92) & 3\,710\,473 & (1.98) \\
	\hline
	\texttt{p\_10K} & 4 & (1) & 10\,047 & (9.23) & 976\,985 & (1.47) & 987\,036 & (1.47) & 7\,255\,153 & (1.96) \\
   	\hline
  	\end{tabular} 
	\end{footnotesize}
	\setlength{\belowcaptionskip}{0.25cm}	
	\caption[Benchmark: Anzahl Knoten und Attribute]{Anzahl Instanzen der verschiedenen Knotenklassen und Gesamtanzahl der Knoten- und Kantenattribute.}
	
	\label{tab:datasets_nodes}
\end{table}
\renewcommand{\arraystretch}{1}

\renewcommand{\arraystretch}{1.25}
\begin{table}[h]
	\centering
	\begin{footnotesize}
   	\begin{tabular}{|l|rl|rl|rl|rl|rl|}
	\hline
	& \multicolumn{10}{c|}{\textbf{Kanten}} \\ \cline{2-11}

   	\textbf{Graph} & \multicolumn{2}{c|}{\texttt{BELONGS\_TO}} & \multicolumn{2}{c|}{\texttt{SIMILAR\_TO}} & \multicolumn{2}{c|}{\texttt{REVIEWED\_BY}} & \multicolumn{2}{c|}{\texttt{FRIEND\_OF}} & \multicolumn{2}{c|}{$\Sigma$} \\
   	\hline
   	\hline
   	\texttt{orig} & \multicolumn{2}{c|}{542\,684} & \multicolumn{2}{c|}{1\,231\,400} & \multicolumn{2}{c|}{7\,593\,109} & \multicolumn{2}{c|}{27\,787\,537} & \multicolumn{2}{c|}{37\,154\,730} \\
	\hline
	\hline
	\texttt{p\_100} & 126 & (1) & 396 & (1) & 1\,909 & (1) & 704\,092 & (1) & 706\,523 & (1) \\
	\hline
	\texttt{p\_1K} & 1\,089 & (8.64) & 3\,365 & (8.5) & 29\,848 & (15.64) & 1\,830\,064 & (2.6) & 1\,864\,366 & (2.64) \\
	\hline
	\texttt{p\_10K} & 10\,048 & (9.23) & 27\,976 & (8.31) & 401\,917 & (13.47) & 3\,576\,276 & (1.95) & 4\,016\,216 & (2.15) \\
	\hline
  	\end{tabular} 
	\end{footnotesize}
	\setlength{\belowcaptionskip}{0.25cm}	
	\caption[Benchmark: Anzahl Kanten]{Anzahl Instanzen der verschiedenen Kantenbezeichner.}
	\label{tab:datasets_edges}
\end{table}
\renewcommand{\arraystretch}{1}


% \textbf{\texttt{BELONGS\_TO}} & \textbf{\texttt{SIMILAR\_TO}} & \textbf{\texttt{REVIEWED\_BY}} & \textbf{\texttt{FRIEND\_OF}}

\subsection{Anfragen}

- Verweis auf Informationssysteme
- rein topologische Anfragen sind nicht aussagekräftig 
- stellvertretend für analytische, lesende Anfragen, die für das Forschungsvorhaben relevant sind
	- lesende Anfragen
	- lokaler Bezug
- Syntax im Anhang \ref{anh:queries}

\renewcommand{\arraystretch}{1.25}
\begin{table}[h]
	\centering
	\begin{footnotesize}
   	\begin{tabular}{|m{3cm}|>{\arraybackslash}m{12.5cm}|}
	\hline
   	\textbf{Name} & \textbf{Beschreibung} \\
	\hline
	\textbf{\texttt{import}*} & Importieren der Datenbasis in das GDBMS unter Verwendung von Bulk-Load-Mechanismen. \\
		  
	\textbf{\texttt{random\_read}*} & Selektion zufällig ausgewählter Produkte und Nutzer sowie Auslesen ihrer Attribute. \\

	\textbf{\texttt{sim\_products}} & Selektion der Titel aller ähnlichen Produkte mit Abstand $\leq 2$. Jeder Produkt soll einmalig in der Ergebnismenge sein. \\

	%\textbf{\texttt{foaf\_products}} & Selektion der Produkte, die von Freunden (anderen Geschlechts) bewertet wurden und die ähnlich zu den eigenen, bewerteten Produkten sind. \\

	\textbf{\texttt{foaf\_reviews}*} & Selektion der Produkte, für die Freunde oder deren Freunde ein Review geschrieben haben gruppiert nach Produkttitel und sortiert nach durchschnittlicher Bewertung. \\

	\textbf{\texttt{path\_all}*} & Berechnen aller Pfade der Länge $\leq 4$ zwischen einem Nutzer und einem Produkt unter Verwendung der Beziehungstypen \texttt{FRIEND\_OF}, \texttt{REVIEWED\_BY} und \texttt{SIMILAR\_TO}.\\

	\textbf{\texttt{path\_shortest}*} & Berechnung des kürzesten Pfades zwischen zwei Nutzern unter Verwendung der Beziehungstypen \texttt{FRIEND\_OF}, \texttt{REVIEWED\_BY} und \texttt{SIMILAR\_TO}. Die maximale Pfadlänge beträgt $5$. \\

	\textbf{\texttt{top\_regions}*} & Berechnen der Anzahl Bücher mit Salesrank $\leq 1000$ gruppiert nach Region.\\

	\textbf{\texttt{triangle\_pattern}*} & Finden aller Dreicksbeziehungen folgender Art: Ein Produkt \texttt{p} besitzt eine Bewertung \texttt{r} die für $\geq 10$ Personen hilfreich war. Der bewertende Nutzer \texttt{u1} ist mit einem weiteren Nutzer \texttt{u2} befreundet, der älter als $20$ Jahre alt ist und ebenfalls das Produkt p bewertet hat. Es sollen \texttt{p}, \texttt{u1}, \texttt{u2} und \texttt{r} bestimmt werden. \\
	
	\textbf{\texttt{sim\_pattern}*} & Selektion alle Subgraphen in denen ausgehend von einem Nutzer die Freunde für $n$ übereinstimmende Produkte Reviews geschrieben haben.\\

	%\textbf{\texttt{friendly\_regions}} & Berechnen der Top 10 Regionen mit den meisten Freundschaftsbeziehungen. \\
	\hline
  	\end{tabular} 
	\end{footnotesize}
	\setlength{\belowcaptionskip}{0.25cm}	
	\caption[Benchmark: Beschreibung der einzelnen Anfragen]{Name und Beschreibung der durchzuführenden Anfragen.}
	\label{tab:benchmark_queries}
\end{table}
\renewcommand{\arraystretch}{1}

- lokale Anfragen
- grundlegende Anfragen wie das Auslesen von Knoten und Kanten wurden bereits in ... durchgeführt
- Ziel: Ausführung komplexer analytischer Anfragen
- ausschließlich lesende Anfragen

\subsection{Testsystem}

\subsection{Systemkonfiguration}

- Indexstrukturen
- Typen / Klassen / Label

\paragraph*{Neo4j}

- Lucene Index für id
- eingebettet
- Gremlin + Cypher

\paragraph*{Titan}

- Index für id
- eingebettet
- Gremlin
- mit und ohne Typen

\subsection{Methodik}

siehe \cite{Dominguez-Sal2011}

- Aufwärmphase ja / nein
- Ausführungsreihenfolge
- Messen

\section{Ergebnisse}






