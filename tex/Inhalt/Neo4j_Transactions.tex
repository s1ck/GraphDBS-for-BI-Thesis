\paragraph*{Transaktionen}

Alle Zugriffe auf die Datenbasis müssen innerhalb einer Transaktion erfolgen. Bei der Verwendung von Cypher erfolgt das Starten einer Transaktion implizit, ist bereits eine Transaktion im aktuellen Kontext aktiv, wird diese genutzt. Bei Verwendung der Core API müssen Transaktionen explizit gestartet werden. Nach einer Reihe von Lese- und Schreiboperationen wird die Transaktion entweder erfolgreich beendet (Commit) oder bei Eintritt eines Fehlers zurückgesetzt (Rollback). Um eventuell gehaltene Sperren freizugeben, muss die Transaktion grundsätzlich finalisiert werden.\footnote{Dies orientert sich am \texttt{try-catch-finally}-Prinzip zur Behandlung von Ausnahmen in Java.}

In Neo4j werden flache Transaktionen unterstützt, welche sich im Quelltext jedoch auch beliebig schachteln lassen. Diese als \textit{Flat Nested Transactions} bezeichnete Umsetzung bedingt, dass ein Rollback einer untergeordneten Transaktion nicht isoliert, sondern nur über den Rollback der übergeordneten Transaktion erfolgen kann. Dieser rekursive Ansatz hat bei Abbruch einer beliebigen untergeordneten Transaktion den Abbruch der Gesamttransaktion zur Folge.

Zur Vermeidung von Mehrbenutzeranomalien werden pessimistische RX-Sperrverfahren\footnote{Beim RX-Sperrverfahren werden zwei Arten von Sperren unterschieden: Lesesperren und exklusive Schreibsperren. Diese können auf einem Objekt gesetzt werden, um einen konkurrierenden Zugriff auszuschließen. Ist ein Objekt mit einer Lesesperre versehen, kann es von anderen Transaktionen gelesen, jedoch nicht geschrieben werden. Ist hingegen ein Objekt exklusiv gesperrt, so ist der lesende und schreibende Zugriff nur für den Sperrinhaber erlaubt, Lese- oder Schreibanforderungen anderer Transaktionen werden blockiert\cite{DBLP:books/sp/HarderR01}.} eingesetzt. Bei einem schreibenden Zugriff auf ein Objekt wird eine exklusive Sperre für das entsprechende Objekt gesetzt und bis zum Ende der Transaktion gehalten. Lesesperren hingegen werden nur für die Dauer des Lesevorgangs gehalten. Eine Transaktion sieht folglich nur eigene Änderungen und die Änderungen bereits beendeter Transaktionen. Entsprechend dem strikten Zwei-Phasen-Sperrprotokoll\footnote{Im Zwei-Phasen-Sperrprotokoll werden in einer Wachstumsphase zunächst alle benötigten Sperren angefordert. Nachdem die erste Sperre wieder freigegeben wurde, dürfen keine neuen Anforderungen erfolgen, es beginnt die Schrumpfungsphase in der Sperren nur noch freigegeben werden. Mit dem Ziel, Dirty Reads und kaskadierende Rücksetzungen infolge von Systemfehlern zu vermeiden, werden beim strikten Zwei-Phasen-Sperrprotokoll alle Sperren gleichzeitig freigegeben\cite{DBLP:books/sp/HarderR01}.} werden alle Schreibsperren am Ende der Transaktion gleichzeitig freigegeben.\\
Die langen Schreibsperren vermeiden das Problem der \textit{Dirty Reads}, durch die kurzen Lesesperren sind jedoch die Anomalien \textit{Non-Repeatable Read}, \textit{Phantom Problem} und vor allem auch \textit{Lost Update} möglich. Dieser Zustand entspricht der Isolationsebene \texttt{READ COMMITTED}, sollen höhere Isolationsebenen wie zum Beispiel \texttt{REPEATABLE READ} oder\linebreak \texttt{SERIALIZABLE} erreicht werden, so liegt dies in der Verantwortung des Programmierers. Neo4j stellt Funktionen bereit, manuell Lese- bzw. Schreibsperren auf Knoten oder Kanten zu setzen.\\
Beim Einsatz exklusiver Sperren können wechselseitige Abhängigkeiten und somit Deadlocks entstehen. Neo4j begegnet diesem Problem mit Deadlock-Erkennung: Wird beim Anfordern einer exklusiven Sperre ein potentieller Deadlock erkannt, wird die anfordernde Transaktion zurückgesetzt.

Änderungen von Transaktionen erfolgen zunächst ausschließlich im Hauptspeicher. Neo4j implementiert eine NoSteal-Strategie\cite{DBLP:books/sp/HarderR01}, bei der das Ausschreiben geänderter Objekte auf den Hintergrundspeicher vor dem Commit einer Transaktion nicht zulässig ist. Diese Strategie führt dazu, dass nach einem Ausfall des GDBMS keine inkonsistenten Änderungen in der Datenbasis vorhanden sein können und somit keine UNDO-Informationen während der Transaktionsausführung gespeichert werden müssen. Die Atomarität von Transaktionen wird durch dieses Vorgehen sichergestellt. Ein Nachteil dieser Strategie ist, dass sehr umfangreiche Änderungstransaktionen durch den verfügbaren Hauptspeicher limitiert sind. Es kann erforderlich sein, diese in mehrere kleinere Änderungstransaktionen aufzuspalten.\\
Neben der Atomarität ist auch die Dauerhaftigkeit von Änderungen ein wesentliches Ziel von Transaktionen. Damit diese erreicht werden kann, führt Neo4j ein Transaktions-Log, in dem alle Änderungen protokolliert werden. Beim erfolgreichen Beenden einer Transaktion wird ein Commit-Eintrag in die Log-Datei geschrieben, der dazu führt, dass alle transienten Änderungen der Log-Datei auf dem Hintergrundspeicher persistiert werden. Beim Ausfall des GDBMS können somit alle bis dahin erfolgreich beendeten Transaktionen wiederhergestellt werden. Das Ausschreiben der Änderungen in die Datenbasis kann also verzögert erfolgen. Dieses Vorgehen wird auch als NoForce-Strategie bezeichnet und verspricht gegenüber dem unmittelbaren Ausschreiben beim Commit einen höheren Durchsatz von Schreiboperationen\cite{DBLP:books/sp/HarderR01}.

Die Bewahrung der Konsistenz innerhalb der Datenbasis ist ebenfalls ein entscheidendes Kriterium bei der Ausführung von Transaktionen. Die bereits erwähnten modellinhärenten Integritätsbedingungen sind hierfür maßgeblich verantwortlich.