\chapter{Zusammenfassung, Fazit und Ausblick}

% Blick in Bachelorarbeit

% Zusammenfassung
Ziel der Arbeit war es, verschiedene Graphdatenbanksysteme anhand definierter Anforderungen zu vergleichen, einige der Systeme auszuwählen und in einer funktionalen und technischen Evaluation ihre Eignung für aktuelle Forschungsvorhaben in der Abteilung Datenbanken der Universität Leipzig zu untersuchen.

% Theoretische Grundlagen
Nach einer Diskussion verwandter Arbeiten wurde zunächst der theoretische Unterbau der Thematik behandelt. Neben den graphentheoretischen Grundlagen wurden verschiedene Netzwerkarten und die damit verbundenen Einsatzgebiete betrachtet. Die Gegenüberstellung hat verdeutlicht, dass es graphenbasierte Softwaresysteme mit verschiedenen Schwerpunkten geben muss. Die Herangehensweise an die Analyse der Systeme folgte einer schrittweisen Eingrenzung: Zunächst wurden die drei Kategorien Graphdatenbanksysteme, Graph Processing Systems und Software zur Visualisierung und Analyse definiert. Der Fokus wurde dabei auf Graphdatenbanksysteme gelegt, da sich diese durch eine Optimierung für lokale, traversierende Anfragen in Verbindung mit klassischen Datenbankfunktionalitäten für das Forschungsprojekt eignen.\\
Der Erläuterung verschiedener GDBMS-Kategorien folgte die Definition graphenorientierter Datenmodelle, diese sind das Property-Graph-Modell, das (Property-)Hypergraph-Modell und das Resource Description Framework. Aus der Untersuchung ging hervor, dass das  PGM und das PHGM auf Grund der flexiblen Verwaltung semistrukturierter Daten und der modellinhärenten Differenzierung in Beziehungen und Nutzdaten für die weitere Betrachtung relevant sind. Das RDF-Modell hingegen legt im Kontext des Semantic Web den Schwerpunkt auf Inferenz und virtuelle Datenintegration.\\
Die Vorbetrachtung endete mit den Definitionen verschiedener graphenspezifischer Operationen, wobei in grundlegende und komplexe Operationen unterschieden wurde. Zu den grundlegenden Operationen gehört beispielsweise die Traversierung zur Definition abstrakter Wege innerhalb des Graphen, sie dient gleichzeitig als Grundlage für komplexe Operationen wie das Prüfen der Erreichbarkeit. Neben den topologie-basierten Operationen wurde auch die Aggregation von Nutzdaten als eine für die Analyse von Unternehmensdaten relevante Operation einbezogen.
	
% Funktionaler Vergleich
Als Zielstellungen des Forschungsvorhabens wurden die Integration von Unternehmensdaten aus Geschäftsinformationssystemen in einen Graphen, die darauf aufbauende graphenorientierte Analyse und die Entwicklung einer Analyseplattform definiert. Dabei sind zum aktuellen Zeitpunkt insbesondere die ersten zwei Ziele bei der Betrachtung von GDBMS relevant.\\
Auf Grund der Vielzahl verschiedener Implementierungen wurden im Rahmen der funktionalen Evaluation aus den Projektzielen zunächst kategorisierte Anforderungen abgeleitet und die Systeme auf dieser Grundlage verglichen. Durch die Differenzierung in obligatorische und optionale Anforderungen konnten aus den 22 GDBMS vier Systeme für die sich anschließende detaillierte Betrachtung ausgewählt werden: Neo4j, HyperGraphDB, OrientDB und Titan.\\
Schwerpunkte innerhalb der Evaluation waren das verwendete Datenmodell, Zugriffs- und Indexmechanismen, Persistenz- und Cacheverwaltung sowie Verteilung und Skalierbarkeit. Der unabhängigen Betrachtung der vier Systeme folgte der Vergleich auf Grundlage der gestellten Schwerpunkte. Dieser hat ergeben, dass vor allem Neo4j und Titan aufgrund ihres hohen Funktionsumfangs an graphenspezifischen Operationen und auch durch ihre effizienten Speicher- und Verteilungsmechanismen für den Einsatz innerhalb des Forschungsprojektes in Frage kommen.\\
Beide Systeme wurden in einem abschließenden Benchmark hinsichtlich ihrer Leistungsfähigkeit bei der Ausführung analytischer Anfragen verglichen und dabei gleichzeitig die Anfrageformulierung in den jeweiligen Anfragesprachen bewertet. Aus den Ergebnissen der funktionalen und technischen Evaluation lässt sich das folgende Fazit formulieren.

\paragraph*{Fazit}

Beide GDBMS implementieren das PGM und verzichten auf die systemseitige Unterstützung eines strikten Schemas. Durch die flexible Verwaltung semistrukturierter Daten eignen sich beide Systeme für die Integration heterogener Daten und unterstützen eine strukturelle Evolution ohne Beeinflussung bestehender Daten. Neo4j erweitert das Standardmodell um Knotenbezeichner, diese ermöglichen aus Anwendungssicht in Kombination mit Kantenbezeichnern die Definition eines minimalen Schemas und lockern damit die enge Kopplung von Datenbank und Anwendung. Aus Datenbanksicht ermöglicht die Erweiterung zusätzliche Optionen für die Anfrageoptimierung.\\
Titan bietet mehrere Erweiterungen des PGM an. Die Möglichkeit zur Typisierung von Attributschlüsseln und Kantenbezeichnern verspricht eine effizientere Verarbeitung des Graphen, eine deutliche Auswirkung der manuellen Typisierung konnte im Benchmark jedoch nicht festgestellt werden. Die Einschränkung der Kardinalität der an einer Beziehung beteiligten Entitäten ermöglicht es der Anwendung, topologische Integritätsbedingungen auf dem Graphen festzulegen. Knoten-zentrierte Indizes können insbesondere in umfangreichen Informationsnetzwerken mit vielen Beziehungsarten und Kantenattributen vorteilhaft sein, dies wurde im Benchmark jedoch nicht untersucht.

Für die Analyse des Graphen bietet Neo4j im Vergleich den größeren Funktionsumfang an. Algorithmen bzw. Anfragen können sowohl unter Verwendung der nativen Core API und des Traversal Frameworks als auch mit den Anfragesprachen Cypher und Gremlin formuliert werden. Insbesondere Cypher ist ein geeignetes Analyse-Werkzeug: Die intuitive Verwendung und die Möglichkeit zur Mustersuche, Aggregation und Projektion werden durch integrierte Funktionen, wie zum Beispiel die Pfadsuche, ergänzt. Die Benchmarks ergeben, wie auch in den verwandten Arbeiten, ein deutliches Leistungsdefizit zwischen der Verwendung von Cypher und Gremlin innerhalb von Neo4j und auch im Vergleich zu Titan. Dies lässt auf eine weiterhin unzureichende Anfrageoptimierung schließen, dabei gilt es jedoch zu beachten, dass Neo Technology den Schwerpunkt zunächst auf die Entwicklung einer geeigneten Syntax gelegt hat. Die Sprache eignet sich hierdurch auch als Werkzeug für Nicht-Programmierer bzw. Analysten. Ein Nachteil bei der Verwendung von Gremlin in Neo4j ist, dass die Sprache nicht von Neo Technology entwickelt wird. Somit ist nicht garantiert, dass nach Release einer Neo4j-Version alle Neuerungen, wie zum Beispiel die Unterstützung von Knotenbezeichnern, in Gremlin zur Verfügung stehen.\\
Titan bietet mit der Blueprints API und Gremlin ebenfalls die Möglichkeit zur Definition beliebiger Algorithmen und Anfragen. Gremlin eignet sich sehr gut für das Formulieren abstrakter Wege. Eine Mustersuche ist, wie gezeigt wurde, ebenfalls möglich, die Anfrage ist je nach Art des Musters deutlich komplexer als eine äquivalente Cypher-Anfrage. Durch die Integration in Groovy bzw. Java lassen sich beliebige Funktionen als Seiteneffekt implementieren und somit während der Traversierung Berechnungen ausführen. Durch den imperativen Charakter der Sprache ist die Performance jedoch im Wesentlichen von der Anfrageformulierung abhängig. Diese kann unter Umständen sehr komplex und vorrangig für Anwendungsentwickler und weniger für Analysten geeignet sein. 

- Neo4j
-------
	
	(3) Speichersystem / Cacheverwaltung
		- einziges natives System (Store-Konzept ermöglicht Trennung von Topologie und Nutzdaten)
		- indexfreie Adjazenz auch physisch umsetzbar
		- im Vergleich erzielte Neo4j in allen Datensätzen die niedrigsten Antwortzeiten
		- sehr gute Caching- und Persistenzarchitektur
		- skaliert linear bei topologischen Anfragen
		- Probleme beim Prüfen der Erreichbarkeit, Limitierung durch Hardware

	(4) Erweiterbarkeit:
		- Quelloffenheit ermöglicht generell das Erweitern der GDBMS
		- Implementierung eigener Algorithmen mittels Core API
		- Hinzufügen von Indexstrukturen
		
	(5) Verteilung / Skalierbarkeit
		- Replikation ermöglicht Skalierbarkeit von Lesezugriffen (vorteilhaft für analytische Anwendung)
		- keine Partitionierung: Datenmenge momentan durch Hardwareressourcen einzelner Rechner limitiert
	
	- objektive Faktoren
		- PGM-Erweiterung um Knotenlabel ist sinnvoll für Anfrageoptimierung und Anwendungsmodellierung
		- Cypher leistungsfähige, deklarative Anfragesprachen für die Analyse von Graphen
			- einfaches, intuitives Formulieren graphenbasierter Anfragen
			- Einbettung von Cypher im Quellcode -> hoher Wartungsaufwand (Holzschuher)
			- bei Performance-Problemen (Erreichbarkeit) -> Nutzung der nativen API
		- wenn Gremlin Neo4j 2.0 unterstützt, stellt dies ebenfalls eine positive Erweiterung dar (community-driven)
		- eigene Algorithmen / Operationen können mittels Core API hinzugefügt werden		-
		- graphenorientiertes Speichersystem und effiziente Caching-Mechanismen
		- bei Bedarf stehen mit Neo4j HA Verteilungsmechanismen zur Verfügung	
	- subjektive Faktoren
		- umfangreiche, detaillierte, aktuelle Dokumentation
		- große Nutzer- und Entwickler-Community -> viele Projekte, Rückwirkungen in das Projekt, sehr aktiv
		- offene, erweiterbare Architektur
		- lange Entwicklungsdauer -> fortgeschrittenes Projekt, aktive Community (Unterstützung)		
	
- Titan
--------
	
	
			
	(3) Speicherung
		- Entkopplung von Datenbankschicht und Speichersystem ist ein innovativer Ansatz und ermöglicht die Implementierung eigener, spezialisierter Speichersysteme bzw. die Bindung an solche
		- keine Trennung von Topologie und Nutzdaten, jedoch direkter Attributzugriff möglich -> Benchmark hat gezeigt, dass der direkte Zugriff auf Attribute dennoch sehr effizient erfolgt und kurze Antwortzeiten erreicht werden
		- physische indexfreie Adjazenz vom Speichersystem abhängig, BerkeleyDB -> logarithmisch
		- Verwendung von BerkeleyDB als Speichersystem führte bei steigender Datenmenge zu teilweise deutlichen Erhöhung der Antwortzeiten
		- skaliert linear bei topologischen Anfragen
		
	(4) Erweiterbarkeit
		- Implementierung eigener Algorithmen mittels Blueprints API
		
	(5) Verteilung / Skalierbarkeit
		- durch Verwendung von entsprechenden Speichersystemen kann sowohl Replikation als auch Partitionierung realsiert werden
		- Partitionierung in Cassandra per Hashfunktion, keine Erhaltung logischer Adjazenz garantiert
		
	- objektiv
		- gut strukturiert, aktuelle Dokumentation, fehlende Dokumentation der internen Abbildung des Graphen
		- Rückwirkung: die im Zusammenhang mit dem Datenmodell beschrieben Analogie zur Kardinalität in Bezug auf UNIQUE-Bedingungen an Kanten wurde in die offizielle Dokumentation übernommen

- beide
	- Projektziele:
		- (1) Integration -> - Verwaltung semistrukturierter Daten eignet sich im besonderen Maße für die Integration aus verschiedenen Geschäftsinformationssystemen
		- (2) graphenorientierte Analyse -> vielfältige Zugriffsmechanismen, Cypher und Gremlin für analytische Anfragen geeignet
	- analytische Anfragen möglich (Cypher, Gremlin)
	- Gremlin
		- höherer Aufwand bei der Anfrageformulierung
	- standardisierte Anfragesprache fehlt weiterhin
	- Gremlin/Blueprints bildet Quasi-Standard
		- Anpassung der GDBMS-Wrapper ist Community-driven (verzögert)
	- keine Bestrebungen hinsichtlich Standardisierung erkennbar
	- Cypher ist guter Kandidat für Standard
	
	
- Rückwirkung auf Dokumentationen (OrientDB Transaktionen, Titan Kardinalität. Neo4j Anfragebeispiele)

Nach Abschluss der Evaluation steht fest, dass sich sowohl Neo4j als auch Titan als grundlegendes Graphdatenbanksystem innerhalb des Forschungsprojektes eignet. Die Präferenz liegt bei Neo4j, da es im Vergleich mit der Unterstützung von Cypher und Gremlin den größeren Funktionsumfang aufweist und im Benchmark bei der Mehrheit der Anfragen das bessere Leistungsverhalten zeigt.

% Ausblick
\paragraph*{Ausblick}

- Neo4j:
	- In-Memory-Erweiterungen für Analyse
	- Query-Optimierung
	- formale Untersuchung und Standardisierung von Cypher im GDBMS-Sektor
	- ausführlicher Benchmark (parallele Queries, reale Unternehmensdaten)
	- Partitionierung
	- Ergebnis der Cypher-Anfragen ist Tabelle und kein Graph bzw. Graphmenge -> Änderungen?
	- Clustering im Speichersystem -> Abbildung einer logischen auf eine physische Adjazenz
	- Cypher eventuell Grundlage für die Definition einer standardisierten Anfragesprache für GDBMS
	
	
- Auffälligkeiten (Vorauswahl):
		- wenig hauptspeicher-zentrierte GDBMS
		- Partitionierung des Graphen nur selten unterstützt
		- anwendungsseitige Schemaverwaltung
		
- OrientDB
	- neues Speichersystem evaluieren
- HyperGraphDB
	- Implementierung Blueprints API
	
- quelloffene hauptspeicher-zentrierte Implementierung
- Eignung Graph Processing für Forschungsvorhaben
- Visualisierung für Analyseplattform

- Benchmark
	- Import: lesen und Schreiben von einer Platte (unrealistisch)
	- parallele Lesezugriffe
	- warmup-Prozedur verhindert Feststellen der Leistungsfähigkeit des Speichersystems
	-> weiterführende Benchmarks
	- Betrachtung ohne Caches sinnvoll?