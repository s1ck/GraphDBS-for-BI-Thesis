\paragraph*{Transaktionen}

% Zugriffsart, explizig, implizit

HyperGraphDB unterstützt die Ausführung von Anfragen innerhalb von Transaktionen. Für Änderungsoperationen ist dies obligatorisch, rein lesende Zugriffe können auch transaktionsunabhängig ausgeführt werden. Bei der Ausführung einer einzelnen Schreiboperation wird eine Transaktion implizit erzeugt, sollen hingegen mehrere Zugriffe innerhalb einer Transaktion erfolgen, muss diese anwendungsseitig explizit erzeugt und verwaltet werden. Das GDBMS stellt hierfür entsprechende Funktionen zur Verfügung. Darüber hinaus besteht die Möglichkeit, Zugriffe an eine aktive Transaktion zu binden.\\ 
Transaktionen können beim Systemstart deaktiviert werden, dies ist zum Beispiel beim Importieren umfangreicher Datenmengen sinnvoll und setzt voraus, dass keine nebenläufigen Zugriffe erfolgen. Bezüglich der ACID-Eigenschaften sind Transaktionen in HyperGraphDB atomar, konsistent und erfolgen isoliert voneinander. Die Dauerhaftigkeit wird nicht garantiert, was bedeutet, dass Änderungen erfolgreich beendeter Transaktionen nach einem Systemfehler verloren sein können. Der Hersteller begründet dies mit dem daraus resultierenden höheren Schreibdurchsatz und mit dem seltenen Auftreten kompletter Abstürze der JVM.

% Schachtelung von Transaktionen

Das GDBMS erlaubt die Schachtelung von Transaktionen, im Gegensatz zu Neo4j lassen sich dabei untergeordnete Transaktionen isoliert zurücksetzen. Der Abbruch einer übergeordneten Transaktion führt zum Rollback aller ihr untergeordneten Transaktionen. Dies hat zur Folge, dass ein Fehler in komplexen, langlaufenden Transaktionen isoliert behandelt und der Arbeitsverlust je nach Granularität der Aufteilung minimiert werden kann.

% Mehrbenutzeranomalien

Wie bereits erwähnt, nutzt HyperGraphDB die Key-Value-Datenbank BerkeleyDB für die Speicherung der Datenbasis. Diese verwendet ein pessimistisches RX-Sperrverfahren zur Vermeidung von Lese-Schreib-Konflikten. In BerkeleyDB lassen sich verschiedene Isolationsebenen konfigurieren, standardmäßig wird \texttt{REPEATABLE READ} verwendet\cite{oracle:2013}. Lese- und Schreibsperren werden in dieser Stufe für die Dauer der gesamten Transaktion gehalten, die Mehrbenutzeranomalien Dirty Read, Non-Repeatable Read und Lost Update werden somit vermieden. Das Phantom Problem kann beim parallelen Einfügen neuer Datensätze weiterhin auftreten.\\
% Deadlocks
BerkeleyDB implementiert einen Timeout-Mechanismus\cite{DBLP:books/sp/HarderR01} zur Erkennung von\linebreak~Deadlocks\cite{oracle:2013}. Der Timeout legt fest, wie lange eine Sperre auf einem Objekt gehalten werden kann. Wird dieser Wert überschritten, geht das System von einem Deadlock aus. Da dies nicht zwingend der Realität entsprechen muss, sollte der Wert dem Zugriffsverhalten und der erwarteten Transaktionsdauer entsprechend angepasst werden. Wird ein potentieller Deadlock erkannt, benachrichtigt BerkeleyDB die Anwendung, d.h. HyperGraphDB, mittels einer Ausnahme. Die Behandlung dieser Ausnahme wird entweder von HyperGraphDB oder von der Anwendung übernommen. Das GDBMS bietet die Möglichkeit, eine in Folge eines Deadlocks abgebrochene Transaktion automatisch zu wiederholen, bis diese erfolgreich beendet wird. Alternativ wird die Ausnahme an die Anwendung weitergeleitet, welche über die nachfolgenden Schritte individuell entscheidet.

% Logging

HyperGraphDB garantiert standardmäßig keine Dauerhaftigkeit von Transaktionen. Um dies zu erläutern,  muss kurz auf die Eigenschaften von BerkeleyDB eingegangen werden: BerkeleyDB bildet eine Datenbank innerhalb eines B-Baumes ab. Es handelt sich um eine spezielle Form, in der Nutzdaten ausschließlich in den Blättern hinterlegt sind. Änderungsoperationen beeinflussen sowohl die Struktur des Baumes als auch die Einträge in den Blättern. Zur Gewährleistung von Dauerhaftigkeit nutzt BerkeleyDB ein Transaktions-Log, in dem alle logischen Änderungsoperationen registriert werden, so dass sich durch sequentielles Ausführen der Log-Einträge der B-Baum rekonstruieren lässt. Folglich ist das Transaktions-Log die Datenbasis. Um den Wiederherstellungsaufwand im Fehlerfall zu minimieren, werden periodisch Sicherungspunkte geschrieben, in denen der B-Baum vollständig gespeichert wird\cite{oracle_bdb:2013}.\\
Das Transaktions-Log wird permanent im Hauptspeicher gehalten. Kommt es während der Ausführung einer Transaktion zum Ausfall des GDBMS, befinden sich die bis dahin erfolgten Änderungen ausschließlich im Hauptspeicher und sind somit verloren. Die Atomarität einer Transaktion ist damit sichergestellt und eine UNDO-Recovery nicht erforderlich. Für die Wiederholbarkeit erfolgreicher Transaktionen wird beim Commit  ein entsprechender Eintrag in das Log geschrieben. In der Standardeinstellung von BerkeleyDB führt dieser Eintrag zum Ausschreiben des Logs auf den Hintergrundspeicher, eine REDO-Recovery ist folglich möglich. HyperGraphDB initialisiert BerkeleyDB standardmäßig mit einer Konfiguration, die es der Datenbank erlaubt, das Transaktions-Log asynchron auf den Hintergrundspeicher zu schreiben, was zur Folge hat, dass Änderungen zum Commit-Zeitpunkt nicht unmittelbar persistiert werden.\footnote{Die Initialisierung kann im Quelltext unter \url{https://code.google.com/p/hypergraphdb/source/browse/tags/release1.2/storage/bdb-je/src/java/org/hypergraphdb/storage/bje/BJEConfig.java} in Zeile 64 nachvollzogen werden} Kommt es zwischen Commit und Persistieren des Logs zum Systemausfall, sind die Änderungen der Transaktion verloren.