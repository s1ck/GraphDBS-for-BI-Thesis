\chapter{Evaluation von Graphdatenbanksystemen}
\label{cha:evaluation}

Dieses Kapitel setzt sich mit konkreten GDBMS-Implementierungen auseinander. Mit der Zielstellung, aus der Vielzahl existierender Systeme geeignete auszuwählen, werden zunächst funktionale Anforderungen definiert. Diese ergeben sich aus aktuellen Forschungsvorhaben am Lehrstuhl Datenbanken der Universität Leipzig. Die ausgewählten Systeme werden anschließend im Detail betrachtet, die Schwerpunkte dabei sind: Datenmodellierung und Konsistenzerhaltung, Zugriffsmechanismen und angebotene graphenspezifische Operationen, physische Repräsentation des Graphen und Möglichkeiten der Indexierung und Verteilung. Das Kapitel schließt mit einer Gegenüberstellung der Systeme.

\section{Aktuelle Forschungsvorhaben}
\label{sec:anforderungen}

Wie bereits im vorhergehenden Kapitel erläutert, ist ein Informationsnetzwerk der Netzwerktypus, in welchem Informationen in Form von Begriffen oder konkreten Daten miteinander verknüpft sind. Die Struktur des Netzwerkes ist dabei die Grundlage für Analysen, deren Ziel es ist, aus bestehenden Informationen neue Informationen abzuleiten, aus denen wiederum neues Wissen generiert werden soll. Im Bereich der Unternehmensdaten werden diese analytischen Verfahren und damit verbundene Anwendungen unter dem Begriff Business Intelligence (BI) zusammengefasst\cite{Watson:2007:CSB:1300761.1301970}. Unternehmen setzen BI ein, um möglichst gewinnbringende Informationen aus vorhandenen Daten zu extrahieren. Auf Basis dieser Informationen können der Zustand des Unternehmens eingeschätzt und Entscheidungen getroffen werden.

Verschiedene Bereiche eines Unternehmens nutzen unterschiedliche Geschäftsinformationssysteme zur Bewältigung ihrer Aufgaben. So unterscheidet man beispielsweise Systeme für Enterprise Resource Planning (ERP), Project Management (PM) und Customer Relationship Management (CRM), welche sich in technologischer, struktureller und semantischer Hinsicht unterscheiden können. BI setzt voraus, dass Daten aus heterogenen Systemen zunächst in ein System integriert werden, zu diesem Zweck werden Data Warehouses (DWH) eingesetzt\cite{Chaudhuri:2011:OBI:1978542.1978562, Watson:2007:CSB:1300761.1301970}. Ein DWH ist eine zentrale Datenbank, welche für Analysezwecke optimiert ist und in welcher Daten aus mehreren, i.A. heterogenen Quellen zusammengeführt, ggf. bereinigt und transformiert werden\cite{}. Im Rahmen der Transformation werden die Daten in ein einheitliches Schema überführt. Fakten werden in einer zentralen Tabelle hinterlegt und mit Dimensionstabellen verknüpft. Ein Fakt kann zum Beispiel der Kauf eines Produktes sein, der aus dem Kauf resultierende Umsatz ist die dem Fakt zugeordnete Kennzahl. Mögliche Dimensionen sind das Produkt, der Kaufzeitpunkt, der Kunde und die Filiale. Auf dieser Datenbasis sind vielfältige Analysen möglich, so können zum Beispiel der Umsatz in bestimmten Regionen, die Beliebtheit von Produkten oder die Rentabilität einzelner Filialen bestimmt werden.

Wie aus dem Beispiel des DWH hervorgeht, erfordert die Transformation das Definieren eines einheitlichen Schemas. Das bedeutet, dass die für die Analyse relevanten Beziehungen zwischen Dimensionen und Fakten vorab festgelegt werden müssen und somit jeder relevante Zusammenhang zwischen Fakt und Dimension bekannt sein und im Schema abgebildet werden muss. Dieser Sachverhalt schränkt jedoch die analytischen Möglichkeiten ein, da nur Zusammenhänge analysiert werden können, die im Schema definiert wurden. Unbekannte, eventuell nicht intuitiv erkennbare Zusammenhänge können in der Analyse nicht berücksichtigt werden.

Eines der Projekte am Lehrstuhl Datenbanken befasst sich mit der Entwicklung und Untersuchung von Methoden zur graphenbasierten Business Intelligence. Eine graphenbasierte Repräsentation von Unternehmensdaten weist die beschriebene Einschränkung eines vordefinierten Schemas nicht auf, vielmehr erlaubt sie die flexible Evaluation der Beziehungen zwischen einzelnen Objekten innerhalb der Unternehmensdaten. Diese lassen sich in zwei Kategorien einteilen: Transaktionale Daten und Stammdaten.
Zu den transaktionalen Daten gehören zum Beispiel Rechnungen im ERP-System, Plandaten im PM-System oder Kundenaktivitäten im CRM-System, sie entstehen bei der Ausführung von Geschäftsprozessen und sind sowohl untereinander als auch mit Stammdaten verknüpft. Beispiele für Stammdaten sind Informationen über Kunden, Produkte, Mitarbeiter oder Filialen. Aus diesem Zusammenhang lässt sich ein Graph ableiten: Transaktionale Daten und Stammdaten bilden die Knoten, der kausale und kontextuelle Zusammenhang zwischen ihnen wird durch Kanten beschrieben. Stammdaten weisen die Eigenschaft auf, dass sie in mehreren Systemen hinterlegt sein können, transaktionale Daten beschränken sich typischerweise auf das System, in dem sie erzeugt wurden. Beziehungen zwischen Objekten können generell systemübergreifend sein. Eine mögliche Analyse ist das Finden häufiger Muster. So lassen sich zum Beispiel Teilgraphen als Instanzen von Geschäftsprozessen extrahieren und hinsichtlich des Zusammenhangs zwischen erzeugtem Mehrwert und beteiligten Mitarbeitern untersuchen. Abbildung \ref{fig:bi-graph} zeigt ein Beispiel für einen aus Geschäftsdaten erzeugten Graphen.

Das Projekt verfolgt drei Ziele: Zunächst ist die Integration von Unternehmensdaten aus heterogenen Systemen in einen Graph erforderlich. Auf der Grundlage des integrierten Graphen werden in einer zweiten Phase Algorithmen für die graphenorientierte Analyse entwickelt. In der letzten Phase sollen Ansätze untersucht werden, die Datenbasis möglichst effizient für Analysten nutzbar zu machen, hierbei spielen insbesondere Anfragesprachen und Möglichkeiten zur Visualisierung eine Rolle. Für das Erreichen der Ziele sollen GDBMS die technologische Grundlage bilden, da sie eine flexible, graphenorientierte Datenmodellierung erlauben und Operationen zur Verfügung stellen unter deren Verwendung sich BI-orientierte Algorithmen implementieren lassen. Einige der verfügbaren Systeme beinhalten darüber hinaus bereits Anfragesprachen, welche als Basis für eigene Entwicklungen dienen können.

\begin{figure}[h] 
	\centering
		\includegraphics[scale=0.45]{exa_docgraph.pdf}
	\caption[Beispiel: BI-Graph]{Informationsnetzwerk, welches die Beziehungen zwischen den Objekten eines ERP- und eines CRM-Systems darstellt. Transaktionale Daten sind weiß,  Stammdaten grau dargestellt. Bezeichner und Richtung einer Kante beschreiben den kausalen Zusammenhang zwischen transaktionalen Daten (z.B. \texttt{basedOn}, \texttt{serves}) sowie zwischen transaktionalen Daten und Stammdaten (z.B. \texttt{sentBy}, \texttt{doneFor}). Der gezeigte Teilgraph bildet die Instanz eines vollständigen Geschäftsprozesses ab, deren erzeugter Mehrwert sich aus den Einnahmen (engl. \textit{Revenue}) und Ausgaben (engl. \textit{Expense}) der transaktionalen Daten bestimmen lässt. Am Beispiel des Knotens \texttt{Employee (E01)} wird deutlich, dass Stammdaten in mehreren Systemen vorhanden sein können.}
	\label{fig:bi-graph}
\end{figure}

\input{Inhalt/Vorauswahl}

\input{Inhalt/Neo4j}
\input{Inhalt/HyperGraphDB}
\input{Inhalt/OrientDB}
\input{Inhalt/Titan}

\section{Zusammenfassung, Vergleich und Auswahl}

\paragraph*{Kategorisierung und Dokumentation}

- nur einführende Beispiele

Neo4j
	+ sehr gute, aktuelle Dokumentation	
	+ Support auf Mailingliste
	+ aktive Community (Stackoverflow, Mailing List. viele Präsentationen)
	+ im Entwicklungsstand am weitesten fortgeschritten
	+ nur wenig Quelltextrecherche erforderlich

HyperGraphDB
	+ gute Dokumentation
	- wird hauptsächlich von einer Person entwickelt
		Vorteil: gut strukturierter Quelltext
		Nachteil: langsame Weiterentwicklung im Gegensatz zu den verglichenen Systemen
	+ Support auf Mailingliste (diese ist jedoch nur schwach frequentiert)
	- kaum zusätzliches Material
	+ an vielen Stellen auf Erweiterung ausgelegt
	- Quelltextrecherche war notwendig (Transaktionsverwaltung / Caching)

OrientDB
	- Dokumentation wirkt umfangreich ist jedoch teilweise unvollständig und inkonsistent mit aktuellem Entwicklungsstand
	- Zugriffsmechanismen im Graphenmodell: widersprüchliche Dokumentation, wenig Beispiele
	- viel Quelltextrecherche (Transaktionsverwaltung, Persistenz- und Cacheverwaltung)
	+ Aktivität und Support auf Mailingliste	

Titan
	+ gute Doku für junges Projekt (fehlende Dokumentation der Persistenzverwaltung)
	+ gute Integration in TinkerPop-Projekt als Quasi-Standard
	- Quelltextrecherche für Persistenz
	+ durch Wiederverwendung existierender Lösungen -> Konzentration auf graphenorientierte Verarbeitung
	+ verteilte Graphen
	+ bei Fragen Support auf Mailingliste

\renewcommand{\arraystretch}{1.25}
\begin{table}[h]
	\centering
	\begin{footnotesize}
   	\begin{tabular}{|m{3.1cm}|>{\centering}m{2.8cm}|>{\centering}m{2.8cm}|>{\centering}m{3.1cm}|>{\centering\arraybackslash}m{3cm}|}
	\hline
	\textbf{GDBMS} & \textbf{Neo4j} & \textbf{HyperGraphDB} & \textbf{OrientDB} & \textbf{Titan} \\   
   	\hline
   	\multicolumn{5}{|c|}{\textbf{Allgemeines}} \\
	\hline
   	\textbf{Hersteller} & Neo Technology & Kobrix Software & Orient Technologies & Aurelius \\
    \textbf{Lizenz} & GPLv3 & LGPL & Apache 2.0 & Apache 2.0 \\
    \textbf{Version (Jahr)} & 2.0.0-M04 (2013) & 1.2 (2012) & 1.5.1 (2013) & 0.3.2 (2013) \\
    \textbf{Sprache} & Java, Scala & Java & Java & Java \\
    \hline
    \multicolumn{5}{|c|}{\textbf{Kategorisierung}} \\
    \hline
    \textbf{Verarbeitung} & nativ & nicht-nativ & nativ & nativ \\
    \textbf{Speicherung} & nativ & je nach Speichersystem & nicht-nativ & je nach Speichersystem \\
    \textbf{Eingebettet} & \checkmark & \checkmark & \checkmark & \checkmark \\
    \textbf{Client-Server} & \checkmark & - & \checkmark & \checkmark \\
    \textbf{Disk-zentriert} & \checkmark & je nach Speichersystem & \checkmark & je nach Speichersystem \\
    \textbf{Hauptspeicher-zentriert} & - & - & - & - \\ 
   % \textbf{Datenbanken} & eine & eine & mehrere & eine \\
   \hline
   	\end{tabular} 
	\end{footnotesize}
	\setlength{\belowcaptionskip}{0.25cm}	
	\caption[Zusammenfassung: Allgemeines und Kategorisierung]{Allgemeines und Kategorisierung.}
	\label{tab:zusammenfassung_dokumenation}
\end{table}
\renewcommand{\arraystretch}{1} 

\paragraph*{Datenmodell}

Tabelle \ref{tab:zusammenfassung_datenmodell} stellt die GDBMS hinsichtlich ihres Datenmodells gegenüber.
- generell
	- alle Systeme sind flexibel hinsichtlich Schemaänderungen
% Tabelle
- Neo4j: PGM
	+ Knotenlabel (mehrere)
	+ flexible Schemaänderung
	- keine Objekteinbettung
	- keine Schemadefinition für Attribute	
	- viel Verantwortung wird an die Anwendung übergeben

- HyperGraphDB: 
	+ Atom-Modell sehr generisch -> für den Anwendungsfall jedoch nicht zwingend erforderlich	
	+ mächtiges Typsystem, Vererbungshierarchien, Schema durch Klassendefinition
	+ flexible Schemaänderung
	+ umfangreiches Typsystem
	- keine Updates, Änderungen durch Werteaustausch
	- kein direkter Zugriff auf Nachbarschaft
	- komplizierte Definition der Semantik der Position in Zielmenge

- OrientDB:
	+ Multi-Modell-Ansatz (Dokumentenmodell als Basis) 
	+ Schema durch Klassendefinition (+ einfache Vererbung)
	+ umfangreiche attributbezogene Integritätsbedingungen
	+ Rechteverwaltung
	- bietet zwar vielfältige Einsatzmöglichkeiten, der Fokus scheint jedoch auf der dokumentenorientierten Verwendung und weniger auf vernetzten Informationen zu liegen	
	- Dokumentmodell als Basis
	- PGM auf Dokumente abgebildet
	
- Titan:
	+ Definition von TitanKey und TitanLabel zur Optimierung der Speicherung (Performance)
	+ erlaubt mehrfache Verwendung von Attributschlüsseln an Knoten / Kante
	+ Einschränkung der Kardinalität von Beziehungen
	- keine Schemadefinition an Knoten und Kanten
	+ Einschränkung der Attribute
	+ Einschränkung Datentypen
	+ verschachtelte Attributwerte (Maps)
	+ Erweiterungen des PGM
		+ Vertex-centric Indices
		+ unidirektionale Kanten
		+ Einschränkung der Kardinalität
		+ als einziges System mehrfache Verwendung eines Attributschlüssels an der Instanz

\renewcommand{\arraystretch}{1.25}
\begin{table}[h]
	\centering
	\begin{footnotesize}
   	\begin{tabular}{|m{3.1cm}|>{\centering}m{2.8cm}|>{\centering}m{2.8cm}|>{\centering}m{3.1cm}|>{\centering\arraybackslash}m{3cm}|}
	\hline
	\textbf{GDBMS} & \textbf{Neo4j} & \textbf{HyperGraphDB} & \textbf{OrientDB} & \textbf{Titan} \\   
    \hline
    \multicolumn{5}{|c|}{\textbf{Datenmodell}} \\
    \hline
    \textbf{Datenmodell} & PGM & PHGM & PGM & PGM \\
    \textbf{Typsystem} & - & \checkmark (Klassen) & \checkmark (Klassen) & \checkmark (Attributschlüssel, Kantenbezeichner) \\
    \textbf{Vererbung} & - & einfach & mehrfach & - \\
	\textbf{Knotenbezeichner} & \checkmark  (optional) & \checkmark & \checkmark & - \\
	\textbf{Kantenbezeichner} & \checkmark & \checkmark  (optional) & \checkmark & \checkmark \\
	\textbf{Attributschema} & - & \checkmark & \checkmark (optional) & - \\
	\textbf{dynamische Schemaänderung} & - & \checkmark (Werteaustausch) & \checkmark & - \\
	\textbf{attributbezogene Integritätsbedingungen} & \texttt{UNIQUE} & Datentyp, \texttt{UNIQUE} & Datentyp, Wertebereich (explizit), \texttt{UNIQUE}, \texttt{NOT NULL} & Datentyp, \texttt{UNIQUE} \\
	\textbf{referentielle Integrität} & \checkmark & \checkmark & \checkmark & \checkmark \\
	\textbf{Vererbung} & - & \checkmark & \checkmark & - \\
	\textbf{Besonderheiten} & mehrere Knotenbezeichner & n-äre Relationen höherer Ordnung, offene Architektur & Multi-Datenmodell, mehrere Datenbanken, Rechteverwaltung & lokal eindeutige Attributschlüssel \& Kantenbezeichner \\
   	\hline
   	\end{tabular} 
	\end{footnotesize}
	\setlength{\belowcaptionskip}{0.25cm}	
	\caption[Zusammenfassung: Datenmodell]{Gegenüberstellung Datenmodell.}
	\label{tab:zusammenfassung_datenmodell}
\end{table}
\renewcommand{\arraystretch}{1}

\paragraph*{Zugriffsmechanismen}

Eingebetteter Zugriff:
	- in allen Systemen möglich
Entfernter Zugriff:
	- in allen Systemen außer HyperGraphDB möglich

CRUD-Operationen:
	- in allen GDBMS möglich
	- dabei Einschränkung der Ergebnismenge durch Angabe von Schlüssel-Wert-Paaren
	- wenn vom Modell unterstützt, stehen Methoden für Klassen- / Typ-Definitionen zur Verfügung
	
Traversierung:
	- Neo4j:
		+ algorithmische Traversierung mittels Traversal Framework
			- umfangreiche Möglichkeiten zur Beeinflussung (Richtung, mehrfache Betrachtung, Filter- und Abbruchkriterien, Heuristiken)
			- Verwendung von Java für Entscheidungslogik -> mächtig
		+ alternative Definition abstrakter Wege in Cypher inkl. Einschränkung
		+ beide: Pfadinstanzen als Ergebnis möglich
	- HyperGraphDB
		+ algorithmische Traversierung mittels Traversal Framework -> Java
		+ Prädikate erlauben die Definition von Filterkriterien	für besuchte Kanten / Knoten
		- kein direkter Zugriff auf die Nachbarschaft eines Knotens (keine intuitive Verwendung)		
		- hoher manueller Aufwand (z.B. keine Pfadinstanzen)
	- OrientDB
		- TRAVERSE-Operator in OrientDB-SQL unzureichend dokumentiert, nur triviale Beispiel, wenig intuitiv
		- Einschränkungen beim Traversieren durch komplexes Verschachteln von Anfragen möglich		
		+ Ausrichtung auf dokumentenorientierten Betrieb und mengenorientiertes Verarbeiten semi-strukurierter Daten
	- OrientDB und Titan
		+ algorithmische Traversierung durch knoten-zentrierte Anfragen		
		- vorrangig Nutzung von Gremlin -> Programmiersprache, mächtig
	- Titan
		+ Gremlin für die intuitive Formulierung abstrakter Wege
		- Gruppierungen / Aggregationen aufwendiger als mit einer deklarativen Sprache wie Cypher
	
Erreichbarkeit
	- Neo4j:
		- native API stellt Algorithmen zur Verfügung
			- erlauben Einschränkungen von Kantenbezeichnern
		- Unterstützung von Blueprints
		- Cypher bietet shortestPath allShortestPath-Funktionen an
		- Weg der Länge $k$ führt zu $\mathcal{O}(\left|N(v_1)\right| \times \left|N(v_2)\right| \times \cdots \times \left|N(v_k)\right|)$
	- HyperGraphDB
		- nur durch Traversierung / manuelle Implementierung umsetzbar
		- wenig Algorithmen (Dijkstra-Implementierung)
	- OrientDB und Titan
		- durch Traversierung umsetzbar
		- Blueprints Algorithmen
			- keine Einschränkungen möglich
	- OrientDB
		- Bugs z.B. falsche Ergebnisse beim Traversieren, expand(shortestPath) und expand(dijkstra)  haben keinen Effekt
		- Ergebnisse zwischen Tiefen- und Breitensuche unterscheiden sich durch Verhindern des wiederholten Zugriffs (link zur Mailing-Liste)

Mustersuche
	- Neo4j:
		- Cypher ermöglicht durch die Kombination abstrakter Wege die Definition beliebiger Mustergraphen
		- Einschränkung der abstrakten Wege
		- deklarativ -> intuitives Formulieren möglich (nah am Datenmodell)
		- Wiederverwendung von Ergebnissen durch Verkettung von Operationen		
	- HyperGraphDB
	 	- keine native Unterstützung (keine Variablendefinition in Prädikaten)
	- OrientDB
		- keine native Unterstützung / keine Dokumentation
		- evtl. durch Schachtelung von SELECT und TRAVERSE
		- OrientDB-SQL eher für dokumentenzentierten, mengenorientierten Zugriff
	- Titan
		- Musterdefinition via Gremlin und table-Funktion
		- weniger intuitiv als Cypher (= komplexer)
		
Aggregation und Summierung

- Summierung wird von keinem GDBMS unterstützt

- Aggregation
	- Neo4j:
		- Aggregation und Gruppierung
			- Gruppierung auf Basis von Attributwerten
			- großer Funktionsumfang zur Berechnung von Aggregaten und Manipulation der Ergebnismenge
	- HyperGraphDB
		- Aggregation 
			- muss innerhalb der Anwendung erfolgen -> (hg.apply)
	- OrientDB
		- Aggregation ja
	- Titan
		- Aggregation ja
Metriken
	- einfache Metriken wie Anzahl Knoten / Kanten
	- Neo4j: Berechnung aller kürzesten Pfade als Grundlage für komplexere Metriken

\renewcommand{\arraystretch}{1.25}
\begin{table}[h]
	\centering
	\begin{footnotesize}
   	\begin{tabular}{|m{3cm}|>{\centering}m{2.9cm}|>{\centering}m{2.9cm}|>{\centering}m{2.9cm}|>{\centering\arraybackslash}m{2.9cm}|}
	\hline	
   	 \textbf{GDBMS} & \textbf{Neo4j} & \textbf{HyperGraphDB (BerkeleyDB)} & \textbf{OrientDB} & \textbf{Titan (BerkeleyDB)} \\   
   	\hline
   	\multicolumn{5}{|c|}{\textbf{Zugriffsmechanismen}} \\
	\hline
   	\textbf{Java API} & \checkmark & \checkmark & \checkmark & \checkmark \\
   	\textbf{Traversal API} & \checkmark & \checkmark & \checkmark & \checkmark \\
   	\textbf{Anfragesprachen} & Cypher, Gremlin & Prädikate\newline~(Java API) & OrientDB-SQL, Gremlin & Gremlin \\
   	\hline
	\multicolumn{5}{|c|}{\textbf{Operationen}} \\
   	\hline
   	\textbf{CRUD} & \checkmark & \checkmark & \checkmark & \checkmark \\
   	\textbf{Mengenorientiert} & \checkmark & \checkmark & \checkmark & \checkmark \\
   	\textbf{Traversierung} & \checkmark & \checkmark & \checkmark & \checkmark \\
   	\textbf{Mustersuche} & \checkmark & - & - & \checkmark \\
   	\textbf{Aggregation} & \checkmark & - & \checkmark & \checkmark \\
   	\textbf{Gruppierung} & \checkmark & - & \checkmark & \checkmark \\
   	\textbf{Summierung} & - & - & - & - \\
   	\textbf{Metriken} & - & - & - & - \\
   	\hline
	\multicolumn{5}{|c|}{\textbf{Verfügbare Algorithmen}} \\   	
   	\hline
   	\textbf{Algorithmen\newline~(nativ)} & Dijkstra, A*, BFS, DFS & Dijkstra & - & - \\
   	\textbf{Algorithmen\newline~(Blueprints)} & Bellman-Ford & - & Dijkstra, Bellman-Ford, A*, BFS, DFS & Dijkstra, Bellman-Ford, A*, BFS, DFS \\
   	\hline
   	\end{tabular} 
	\end{footnotesize}
	\setlength{\belowcaptionskip}{0.25cm}	
	\caption[Zusammenfassung: Zugriffsmechanismen]{Gegenüberstellung Zugriffsmechanismen.}
	\label{tab:zusammenfassung_zugriffsmechanismen}
\end{table}
\renewcommand{\arraystretch}{1}

\paragraph*{Transaktions- und Indexverwaltung}

Transaktionen
	- generell: Optimierung für Leseoperationen / Konflikte werden an Anwendung weitergegeben (OrientDB und Titan)
	- Neo4j
		+ ist ACID konform bietet jedoch gegenüber den anderen GDBMS eine
		- geringe Isolationsebene
		- wie auch beim Datenmodell liegt die Verantwortung bei der Anwendung wenn höhere Ebene erreicht werden soll
	- HyperGraphDB:
		+ Dauerhaftigkeit lässt sich bei Bedarf aktivieren
		+ MVCC im Cache bietet hohe Isolationsebene
		+ isolierte Transaktionen (gut für langlaufende Änderungstransaktionen -> nicht erforderlich)
	- OrientDB:
		+ client-seitige Transaktionsausführung -> Ausrichtung auf kurze Lese- bzw. Schreibtransaktionen
		- keine Schachtelung
		- beim Standard-Speichermechanismus muss Dauerhaftigkeit (FORCE) explizit aktiviert werden -> Performanceeinbußen
	- Titan:
		+ Consistency: stellt Einhaltung definierter \texttt{UNIQUE}-Bedingungen sicher
		+ AID je nach Speichersystem
		- hinsichtlich Transaktionen den geringsten Funktionsumfang
		- es muss generell mit Konflikten gerechnet werden
	
Indexverwaltung
- Primär- und Sekundärindizes generell möglich
- Indizes werden automatisch aktualisiert
	- HyperGraphDB / Titan
		- generell drei / zwei systemseitige Indexstrukturen, welche bei Schreiboperationen berücksichtigt werden müssen -> Auswirkung auf Performance
- bis auf OrientDB wird eine Erweiterung um eigene Indexstrukturen dokumentiert
- Neo4j und Titan mit Unterstützung komplexer Indizierungsmechanismen durch Apache Lucene bzw. Elastic Search
- OrientDB
	+ mehrdimensionale Indizes

\renewcommand{\arraystretch}{1.25}
\begin{table}[h]
	\centering
	\begin{footnotesize}
   	\begin{tabular}{|m{3cm}|>{\centering}m{2.9cm}|>{\centering}m{2.9cm}|>{\centering}m{2.9cm}|>{\centering\arraybackslash}m{2.9cm}|}
	\hline	
   	 \textbf{GDBMS} & \textbf{Neo4j} & \textbf{HyperGraphDB (BerkeleyDB)} & \textbf{OrientDB} & \textbf{Titan (BerkeleyDB)} \\   
   	\hline
	\multicolumn{5}{|c|}{\textbf{Transaktionen}} \\   	
   	\hline
   	\textbf{ACID-Eigenschaften} & ACID & ACI(D) & ACI(D) & ACID \\
   	\textbf{Isolationsebene} & \texttt{READ COMMITTED} & \texttt{SERIALIZABLE} & \texttt{SERIALIZABLE} & \texttt{REPEATABLE READ} \\
   	\textbf{Synchronisations-verfahren\newline~(Storage)} & RX-Sperrverfahren & RX-Sperrverfahren & MVCC & RX-Sperrverfahren \\
   	\textbf{Schachtelung} & \checkmark (kein isoliertes Rücksetzen) & \checkmark (isoliertes Rücksetzen) & - & \checkmark (keine Isolation) \\
   	\hline
	\multicolumn{5}{|c|}{\textbf{Indexverwaltung}} \\   	
   	\hline
	\textbf{Primärindex} & \checkmark & \checkmark & \checkmark & \checkmark \\
	\textbf{Sekundärindex} & \checkmark & \checkmark & \checkmark & \checkmark \\
	\textbf{mehrdimensional} & - & - & \checkmark & - \\
	\textbf{Aktualisierung} & automatisch & automatisch & automatisch & automatisch \\
	\textbf{Externe Indexstrukturen} & Apache Lucene, Neo4j Spatial & - & - & Elastic Search, Apache Lucene \\
	\textbf{Besonderheiten} & - & - & - & Knoten-zentrierte Indizes \\
   	\hline
   	\end{tabular} 
	\end{footnotesize}
	\setlength{\belowcaptionskip}{0.25cm}	
	\caption[Zusammenfassung: Transaktions- und Indexverwaltung]{Gegenüberstellung Transaktions- und Indexverwaltung.}
	\label{tab:zusammenfassung_transaktion}
\end{table}
\renewcommand{\arraystretch}{1}

\paragraph*{Persistenz- und Cacheverwaltung, Verteilung}

% Persistenzverwaltung
- Neo4j: nativ
	+ Trennung von Topologie und Daten
	+ physische Trennung feingranular durch Store-Konzept
	+ effiziente Berechnung physischer Positionen in Folge der festen Satzlänge von Knoten und  Kanten versprechen hohe Performance beim Traversieren des Graphen	
	+ indexfreie Adjazenz wird erreicht
	- Fragmentierung der Stores durch Löschen einzelner Einträge
	- logisch benachbarte Knoten sind nicht zwingend physisch benachbart

- HyperGraphDB: nicht-nativ
	+ Trennung von Topologie und Daten
	- zu beachten: Typsystem ebenfalls Teil der topologischen Daten
	- keine indexfreie Adjazenz mit BerkeleyDB
	- Traversierung: O(logn)
	
- OrientDB: nicht-nativ
	- keine Trennung von Topologie und Daten (alles im Dokument)
	+ physisches Clustering semantischer Gruppierungen
	- Traversierung: O(N\_v)
	- schlechte Performance durch:	
		- zusätzliche Indirektion durch Cluster-Datei beim Zugriff auf eigentliche Daten
		- Deserialisierung erscheint ineffizient (evtl. Verweise auf ältere Benchmarks)	
		- attributierte Kanten sind zusätzliche Indirektion\url{https://github.com/orientechnologies/orientdb/wiki/Performance-Tuning-Blueprints} -> können sich negativ auf die Performance beim Traversieren auswirken
		- Fragmentierung der Stores	
- Titan: nicht-nativ
	- keine Trennung von Topologie und Daten
	+ direkter Zugriff auf Attribute und inzidente Kanten
	- hoher Aufwand bei Speicherung in KV-Store 
	- redundante Speicherung von Kantenattributen
	- Traversierung O(logn)
	- Ein Vorteil gegenüber OrientDB und HyperGraphDB, ist die Möglichkeit des direkten Zugriffes auf Attribute und inzidente Kanten eines Knotens unter Angabe der Knoten-Identität und der geforderten 
	Column.

% Cacheverwaltung
	
- generell: Beschleunigung der Zugriffe auf häufig benötige Objekte via Caches
	- Hashtabellen  O(1) (wenn da)
	
- OrientDB
	- keine Cache-Synchronisation 
	- Empfehlung zur Deaktivierung des Caches im parallelen Betrieb
- HyperGraphDB / Titan
	- profitieren von Caching-Mechanismen in den eingesetzten Speichersystemen
- Titan
	- Transaktionscache kann bei langen Lese- oder Änderungstransaktionen zu Speicherproblemen führen

% Verteilung
- alle außer HyperGraphDB bieten die Möglichkeit zur Replikation 
	-> Ausfallsicherheit, Skalierbarkeit Lesezugriffe
	-> Single-Master, Multi-Master schränken Skalierbarkeit von Schreibzugriffen ein
	- Cassandra ermöglicht besseren, flexibleren Kompromiss aus Performance und Ausfallsicherheit
- Partitionierung nur in Titan möglich
	- bisherige Nutzung der zufälligen Zuordnung -> Weiterentwicklung bereits angekündgt
- Titan
	+ bietet als einziges GDBMS Replikation und Partitionierung und somit eine horizontale Skalierbarkeit von Zugriffen und Datenvolumen
	+ Fehlertoleranz
	- logische Nachbarschaft wird bei der Partitionierung nicht berücksichtigt

\renewcommand{\arraystretch}{1.25}
\begin{table}[h]
	\centering
	\begin{footnotesize}
   	\begin{tabular}{|m{2.6cm}|>{\centering}m{3cm}|>{\centering}m{3cm}|>{\centering}m{3cm}|>{\centering\arraybackslash}m{3cm}|}
	\hline
   	 \textbf{GDBMS} & \textbf{Neo4j} & \textbf{HyperGraphDB} & \textbf{OrientDB} & \textbf{Titan} \\   
 	\hline
 	\multicolumn{5}{|c|}{\textbf{Persistenzverwaltung}} \\
	\hline
	\textbf{Realisierung} & Store-Konzept & Key-Value-Modell & Dokument-Modell & Key-Column-Value-Modell \\
	\textbf{Trennung Topologie, Nutzdaten} & \checkmark & \checkmark & - & - \\
	\textbf{Satzlänge} & fest & variabel & variabel & variabel \\
	\textbf{Zeitkomplexität Zugriff Nachbarschaft} & konstant & logarithmisch (BerkeleyDB) & konstant & logarithmisch (BerkeleyDB), konstant (Cassandra)\\
	\textbf{Indexfreie Adjazenz} & \checkmark & - (BerkeleyDB) & \checkmark & - (BerkeleyDB), \checkmark (Cassandra) \\
	\hline
	\multicolumn{5}{|c|}{\textbf{Cacheverwaltung}} \\
	\hline
	\textbf{Caches} & MMF, Filesystem-Cache (LFU), Objekt-Cache (Schwache Referenzen) & Atomcache (LRU), Inzidenzcache (LRU) & MMF, L2 Cache (FIFO), L1 Cache (Schwache Referenzen) & Transaktionscache \\
	\hline
	\multicolumn{5}{|c|}{\textbf{Verteilung}} \\
	\hline
	\textbf{Architektur} & Master-Slave (nur Enterprise Edition) & Peer-To-Peer Nachrichten Framework & Master-Master & Peer-to-Peer (Cassandra) \\
	\textbf{Replikation} & \checkmark & - & \checkmark & \checkmark \\
	\textbf{Partitionierung} & - & - & - & \checkmark \\
	%\textbf{Strong Consistency} & \checkmark & - & \checkmark & \checkmark \\
	%\textbf{Eventual Consistency} & \checkmark & - & \checkmark & \checkmark \\
	\textbf{Skalierbarkeit Lesen} & horizontal & - & horizontal & horizontal \\
	\textbf{Skalierbarkeit Schreiben} & vertikal & - & vertikal & horizontal \\
	\textbf{Skalierbarkeit Datenvolumen} & vertikal & - & vertikal & horizontal \\
   	\hline
  	\end{tabular} 
	\end{footnotesize}
	\setlength{\belowcaptionskip}{0.25cm}	
	\caption[Zusammenfassung: Persistenz- und Cacheverwaltung, Verteilung]{Gegenüberstellung Persistenz- und Cacheverwaltung, Verteilung.}
	\label{tab:zusammenfassung_persistenz}
\end{table}
\renewcommand{\arraystretch}{1}

Unter Berücksichtigung der vorgestellten Ergebnisse werden Neo4j und Titan im letzten Kapitel der Arbeit in einem Benchmark untersucht um die Leistungsfähigkeit der Systeme abschließend beurteilen zu können. Insbesondere soll dabei auch untersucht werden, inwieweit eine native Speicherung des Graphen vorteilhaft ist oder ob die Nutzung bestehender Systeme eine gleichwertige Alternative darstellt.