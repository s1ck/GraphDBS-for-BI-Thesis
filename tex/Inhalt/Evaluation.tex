\chapter{Funktionaler Vergleich von Graphdatenbanksystemen}
\label{cha:evaluation}

Dieses Kapitel setzt sich mit konkreten GDBMS-Implementierungen auseinander. Mit der Zielstellung, aus der Vielzahl existierender Systeme geeignete auszuwählen, werden zunächst funktionale Anforderungen definiert. Diese ergeben sich aus aktuellen Forschungsvorhaben am Lehrstuhl Datenbanken der Universität Leipzig. Die ausgewählten Systeme werden anschließend im Detail betrachtet, die Schwerpunkte dabei sind: Datenmodellierung und Konsistenzerhaltung, Zugriffsmechanismen und angebotene graphenspezifische Operationen, physische Repräsentation des Graphen und Möglichkeiten der Indexierung und Verteilung. Das Kapitel schließt mit einer Gegenüberstellung der Systeme.

\section{Aktuelle Forschungsvorhaben}
\label{sec:anforderungen}

Wie bereits im vorhergehenden Kapitel erläutert, ist ein Informationsnetzwerk der Netzwerktypus, in welchem Informationen in Form von Begriffen oder konkreten Daten miteinander verknüpft sind. Die Struktur des Netzwerkes ist dabei die Grundlage für Analysen, deren Ziel es ist, aus bestehenden Informationen neue Informationen abzuleiten, aus denen wiederum neues Wissen generiert werden soll. Im Bereich der Unternehmensdaten werden diese analytischen Verfahren und damit verbundene Anwendungen unter dem Begriff Business Intelligence (BI) zusammengefasst\cite{Watson:2007:CSB:1300761.1301970}. Unternehmen setzen BI ein, um möglichst gewinnbringende Informationen aus vorhandenen Daten zu extrahieren. Auf Basis dieser Informationen können der Zustand des Unternehmens eingeschätzt und Entscheidungen getroffen werden.

Verschiedene Bereiche eines Unternehmens nutzen unterschiedliche Geschäftsinformationssysteme zur Bewältigung ihrer Aufgaben. So unterscheidet man beispielsweise Systeme für Enterprise Resource Planning (ERP), Project Management (PM) und Customer Relationship Management (CRM), welche sich in technologischer, struktureller und semantischer Hinsicht unterscheiden können. BI setzt voraus, dass Daten aus heterogenen Systemen zunächst in ein System integriert werden, zu diesem Zweck werden Data Warehouses (DWH) eingesetzt\cite{Chaudhuri:2011:OBI:1978542.1978562, Watson:2007:CSB:1300761.1301970}. Ein DWH ist eine zentrale Datenbank, welche für Analysezwecke optimiert ist und in welcher Daten aus mehreren, i.A. heterogenen Quellen zusammengeführt, ggf. bereinigt und transformiert werden\cite{}. Im Rahmen der Transformation werden die Daten in ein einheitliches Schema überführt. Fakten werden in einer zentralen Tabelle hinterlegt und mit Dimensionstabellen verknüpft. Ein Fakt kann zum Beispiel der Kauf eines Produktes sein, der aus dem Kauf resultierende Umsatz ist die dem Fakt zugeordnete Kennzahl. Mögliche Dimensionen sind das Produkt, der Kaufzeitpunkt, der Kunde und die Filiale. Auf dieser Datenbasis sind vielfältige Analysen möglich, so können zum Beispiel der Umsatz in bestimmten Regionen, die Beliebtheit von Produkten oder die Rentabilität einzelner Filialen bestimmt werden.

Wie aus dem Beispiel des DWH hervorgeht, erfordert die Transformation das Definieren eines einheitlichen Schemas. Das bedeutet, dass die für die Analyse relevanten Beziehungen zwischen Dimensionen und Fakten vorab festgelegt werden müssen und somit jeder relevante Zusammenhang zwischen Fakt und Dimension bekannt sein und im Schema abgebildet werden muss. Dieser Sachverhalt schränkt jedoch die analytischen Möglichkeiten ein, da nur Zusammenhänge analysiert werden können, die im Schema definiert wurden. Unbekannte, eventuell nicht intuitiv erkennbare Zusammenhänge können in der Analyse nicht berücksichtigt werden.

Eines der Projekte am Lehrstuhl Datenbanken befasst sich mit der Entwicklung und Untersuchung von Methoden zur graphenbasierten Business Intelligence. Eine graphenbasierte Repräsentation von Unternehmensdaten weist die beschriebene Einschränkung eines vordefinierten Schemas nicht auf, vielmehr erlaubt sie die flexible Evaluation der Beziehungen zwischen einzelnen Objekten innerhalb der Unternehmensdaten. Diese lassen sich in zwei Kategorien einteilen: Transaktionale Daten und Stammdaten.
Zu den transaktionalen Daten gehören zum Beispiel Rechnungen im ERP-System, Plandaten im PM-System oder Kundenaktivitäten im CRM-System, sie entstehen bei der Ausführung von Geschäftsprozessen und sind sowohl untereinander als auch mit Stammdaten verknüpft. Beispiele für Stammdaten sind Informationen über Kunden, Produkte, Mitarbeiter oder Filialen. Aus diesem Zusammenhang lässt sich ein Graph ableiten: Transaktionale Daten und Stammdaten bilden die Knoten, der kausale und kontextuelle Zusammenhang zwischen ihnen wird durch Kanten beschrieben. Stammdaten weisen die Eigenschaft auf, dass sie in mehreren Systemen hinterlegt sein können, transaktionale Daten beschränken sich typischerweise auf das System, in dem sie erzeugt wurden. Beziehungen zwischen Objekten können generell systemübergreifend sein. Eine mögliche Analyse ist das Finden häufiger Muster. So lassen sich zum Beispiel Teilgraphen als Instanzen von Geschäftsprozessen extrahieren und hinsichtlich des Zusammenhangs zwischen erzeugtem Mehrwert und beteiligten Mitarbeitern untersuchen. Abbildung \ref{fig:bi-graph} zeigt ein Beispiel für einen aus Geschäftsdaten erzeugten Graphen.

Das Projekt verfolgt drei Ziele: Zunächst ist die Integration von Unternehmensdaten aus heterogenen Systemen in einen Graph erforderlich. Auf der Grundlage des integrierten Graphen werden in einer zweiten Phase Algorithmen für die graphenorientierte Analyse entwickelt. In der letzten Phase sollen Ansätze untersucht werden, die Datenbasis möglichst effizient für Analysten nutzbar zu machen, hierbei spielen insbesondere Anfragesprachen und Möglichkeiten zur Visualisierung eine Rolle. Für das Erreichen der Ziele sollen GDBMS die technologische Grundlage bilden, da sie eine flexible, graphenorientierte Datenmodellierung erlauben und Operationen zur Verfügung stellen unter deren Verwendung sich BI-orientierte Algorithmen implementieren lassen. Einige der verfügbaren Systeme beinhalten darüber hinaus bereits Anfragesprachen, welche als Basis für eigene Entwicklungen dienen können.

\begin{figure}[h] 
	\centering
		\includegraphics[scale=0.45]{exa_docgraph.pdf}
	\caption[Beispiel: BI-Graph]{Informationsnetzwerk, welches die Beziehungen zwischen den Objekten eines ERP- und eines CRM-Systems darstellt. Transaktionale Daten sind weiß,  Stammdaten grau dargestellt. Bezeichner und Richtung einer Kante beschreiben den kausalen Zusammenhang zwischen transaktionalen Daten (z.B. \texttt{basedOn}, \texttt{serves}) sowie zwischen transaktionalen Daten und Stammdaten (z.B. \texttt{sentBy}, \texttt{doneFor}). Der gezeigte Teilgraph bildet die Instanz eines vollständigen Geschäftsprozesses ab, deren erzeugter Mehrwert sich aus den Einnahmen (engl. \textit{Revenue}) und Ausgaben (engl. \textit{Expense}) der transaktionalen Daten bestimmen lässt. Am Beispiel des Knotens \texttt{Employee (E01)} wird deutlich, dass Stammdaten in mehreren Systemen vorhanden sein können.}
	\label{fig:bi-graph}
\end{figure}

\input{Inhalt/Vorauswahl}

\input{Inhalt/Neo4j}
\input{Inhalt/HyperGraphDB}
\input{Inhalt/OrientDB}
\input{Inhalt/Titan}

\section{Zusammenfassung, Vergleich und Auswahl}

In diesem Abschnitt werden die Ergebnisse der vorangegangen funktionalen Analyse zusammengefasst. Die tabellarische, kategorisierte Gegenüberstellung der Eigenschaften betrachteter Graphdatenbanksysteme dient dabei als Bewertungsgrundlage für die Eignung im beschriebenen Forschungsvorhaben. Ziel ist es, die Menge der Systeme anhand ihrer funktionalen Eigenschaften weiter einzugrenzen und sie in der sich anschließenden technischen Analyse hinsichtlich ihrer Leistungsfähigkeit final gegenüberzustellen.

\paragraph*{Kategorisierung und Dokumentation}

In Tabelle \ref{tab:zusammenfassung_dokumenation} werden allgemeine Informationen zusammengefasst dargestellt und die Systeme entsprechend der in Abschnitt \ref{subsec:gdbms} vorgestellten Kategorien eingeteilt.

\renewcommand{\arraystretch}{1.25}
\begin{table}[h]
	\centering
	\begin{footnotesize}
   	\begin{tabular}{|m{3.1cm}|>{\centering}m{2.8cm}|>{\centering}m{2.8cm}|>{\centering}m{3.1cm}|>{\centering\arraybackslash}m{3cm}|}
	\hline
	\textbf{GDBMS} & \textbf{Neo4j} & \textbf{HyperGraphDB} & \textbf{OrientDB} & \textbf{Titan} \\   
   	\hline
   	\multicolumn{5}{|c|}{\textbf{Allgemeines}} \\
	\hline
   	\textbf{Hersteller} & Neo Technology & Kobrix Software & Orient Technologies & Aurelius \\
    \textbf{Lizenz} & GPLv3 & LGPL & Apache 2.0 & Apache 2.0 \\
    \textbf{Version (Jahr)} & 2.0.0-M04 (2013) & 1.2 (2012) & 1.5.1 (2013) & 0.3.2 (2013) \\
    \textbf{Sprache} & Java, Scala & Java & Java & Java \\
    \textbf{Dokumentation} & +++ & ++ & + & ++ \\
    \textbf{Besonderheiten} & - & offene Architektur & mehrere Datenbanken, Rechteverwaltung & - \\
    \hline
    \multicolumn{5}{|c|}{\textbf{Kategorisierung}} \\
    \hline
    \textbf{Verarbeitung} & nativ & nicht-nativ & nativ & nativ \\
    \textbf{Speicherung} & nativ & je nach Speichersystem & nicht-nativ & je nach Speichersystem \\
    \textbf{Eingebettet} & \checkmark & \checkmark & \checkmark & \checkmark \\
    \textbf{Client-Server} & \checkmark & - & \checkmark & \checkmark \\
    \textbf{Disk-zentriert} & \checkmark & je nach Speichersystem & \checkmark & je nach Speichersystem \\
    \textbf{Hauptspeicher-zentriert} & - & - & - & - \\ 
   % \textbf{Datenbanken} & eine & eine & mehrere & eine \\
   \hline
   	\end{tabular} 
	\end{footnotesize}
	\setlength{\belowcaptionskip}{0.25cm}	
	\caption[Zusammenfassung: Allgemeines und Kategorisierung]{Allgemeine Informationen zu den verglichenen Graphdatenbanksystemen und deren Kategorisierung.}
	\label{tab:zusammenfassung_dokumenation}
\end{table}
\renewcommand{\arraystretch}{1} 

Bei der Analyse eines Systems ist die offizielle Dokumentation erster Anlaufpunkt. Neo4j verfügt über eine umfassende, detaillierte und vor allem aktuelle Dokumentation, welche sowohl ausführlich auf Zugriffsmechanismen eingeht als auch Implementierungstechniken ansatzweise beschreibt. Im Gegensatz dazu ist die Dokumentation zu OrientDB teilweise unvollständig und nicht konsistent mit dem aktuellen Entwicklungsstand des GDBMS. Insbesondere bei der Analyse der für Datenbanksysteme wichtigen Transaktionsverwaltung musste auf den Quelltext zurückgegriffen werden. Generell ist die Dokumentation von OrientDB auf die Verwendung als Dokumentendatenbank ausgerichtet, die graphenorientierten Erweiterungen von SQL werden nur durch minimalistische Beispiele beschrieben.\\
Die Dokumentationen von HyperGraphDB und Titan sind gut strukturiert und entsprechen dem aktuellen Entwicklungsstand. Titan profitiert dabei von den sehr guten Dokumentationen des TinkerPop-Projektes. Eine Quelltextrecherche war jedoch auch bei diesen Systemen im Zusammenhang mit Transaktions- und Persistenzverwaltung notwendig. Alle Hersteller besitzen offizielle Mailinglisten, in denen Fragen beantwortet und Annahmen bestätigt wurden. Die Mailinglisten von Neo4j, OrientDB und Titan sind deutlich aktiver als dies bei HyperGraphDB der Fall ist. Insbesondere Neo4j erweckt den Eindruck einer umfangreichen Entwicklergemeinde; neben den offiziellen Dokumentationen finden sich viele Präsentationen, Blog-Artikel, Twitter-Nachrichten oder Forenbeiträge mit Bezug zum GDBMS und dessen Anwendungen.

Die Kategorisierung verdeutlicht, dass nur Neo4j als vollständig natives GDBMS gewertet werden kann. Als einziges bildet es das PGM auf ein explizit dafür entwickeltes Speichersystem ab. Im Gegensatz dazu ist die Einbettung in Java-Anwendungen in allen Systemen möglich; HyperGraphDB beinhaltet keine Unterstützung für den entfernen Zugriff und muss bei Bedarf entsprechend erweitert werden. Ein Speichersystem, welches auf den Hauptspeicher ausgerichtet ist, wird von keinem der Systeme unterstützt. Bezüglich der Verteilung ist Titan hervorzuheben, da es Partitionierung und Replikation der Datenbasis ermöglicht. In diesem Zusammenhang ist die Nutzung etablierter Systeme wie z.B. Apache Cassandra eine innovative Idee und nimmt den Entwicklern zusätzlichen Implementierungsaufwand für die Realisierung von Persistenz-, Transaktions- und Verteilungsmechanismen ab.


%Neo4j
%	+ sehr gute, aktuelle Dokumentation	
%	+ Support auf Mailingliste
%	+ aktive Community (Stackoverflow, Mailing List. viele Präsentationen)
%	+ im Entwicklungsstand am weitesten fortgeschritten
%	+ nur wenig Quelltextrecherche erforderlich
%
%HyperGraphDB
%	+ gute Dokumentation
%	- wird hauptsächlich von einer Person entwickelt
%		Vorteil: gut strukturierter Quelltext
%		Nachteil: langsame Weiterentwicklung im Gegensatz zu den verglichenen Systemen
%	+ Support auf Mailingliste (diese ist jedoch nur schwach frequentiert)
%	- kaum zusätzliches Material
%	+ an vielen Stellen auf Erweiterung ausgelegt
%	- Quelltextrecherche war notwendig (Transaktionsverwaltung / Caching)
%
%OrientDB
%	- Dokumentation wirkt umfangreich ist jedoch teilweise unvollständig und inkonsistent mit aktuellem Entwicklungsstand
%	- Zugriffsmechanismen im Graphenmodell: widersprüchliche Dokumentation, wenig Beispiele
%	- viel Quelltextrecherche (Transaktionsverwaltung, Persistenz- und Cacheverwaltung)
%	+ Aktivität und Support auf Mailingliste	
%
%Titan
%	+ gute Doku für junges Projekt (fehlende Dokumentation der Persistenzverwaltung)
%	+ gute Integration in TinkerPop-Projekt als Quasi-Standard
%	- Quelltextrecherche für Persistenz
%	+ durch Wiederverwendung existierender Lösungen -> Konzentration auf graphenorientierte Verarbeitung
%	+ verteilte Graphen
%	+ bei Fragen Support auf Mailingliste



\paragraph*{Datenmodell}

Bei der Analyse des jeweiligen Datenmodells wurde festgestellt, dass das PGM von allen Systemen unterstützt wird. Eine sich daraus ergebende weitere Gemeinsamkeit ist die hohe Flexibilität bezüglich Schemaänderungen ohne Beeinflussung bestehender Nutzdaten. Hierdurch eignen sich die Systeme im besonderem Maße für die Datenintegration aus heterogenen Quellsystemen. In Tabelle \ref{tab:zusammenfassung_datenmodell} sind die wichtigsten Merkmale gegenüberstellt.

Neo4j bietet nur wenig Einfluss auf das Schema der hinterlegten Daten und übergibt einen Großteil der Verantwortung hinsichtlich Schemaverwaltung und Konsistenzerhaltung an die Anwendung. Eine Erweiterung des PGM stellen die Knotenbezeichner dar mit denen sich Knoteninstanzen beliebig vielen Gruppen zuordnen lassen. Die Einbettung geschachtelter Objekte als Attributwerte ist in Neo4j nicht möglich und muss bei Bedarf durch dedizierte Knoten realisiert werden.\\
HyperGraphDB hingegen stellt mit dem Atom-Modell einen generischen Ansatz für die Abbildung komplexer Strukturen mit n-ären und höherwertigen Beziehungen zur Verfügung. Eine Folge der hohen Ausdrucksstärke ist die stellenweise wenig intuitive Verwendung: So muss der Ordnung innerhalb der Zielmenge grundsätzlich eine Semantik zugewiesen werden. Da es sich bei den beschriebenen Informationsnetzwerken vorrangig um binäre Beziehungen handelt und n-äre Relationen auch durch mehrfache binäre Relationen ausgedrückt werden können, ist die Implementierung des PHGM kein wesentlicher Vorteil gegenüber den anderen Systemen. Ungeachtet dessen erlaubt das GDBMS die Definition komplexer Typsysteme und eine Verwendung beliebiger Objektkompositionen zur Beschreibung der Nutzdaten.

\renewcommand{\arraystretch}{1.25}
\begin{table}[h]
	\centering
	\begin{footnotesize}
   	\begin{tabular}{|m{3.1cm}|>{\centering}m{2.8cm}|>{\centering}m{2.8cm}|>{\centering}m{3.1cm}|>{\centering\arraybackslash}m{3cm}|}
	\hline
	\textbf{GDBMS} & \textbf{Neo4j} & \textbf{HyperGraphDB} & \textbf{OrientDB} & \textbf{Titan} \\   
    \hline
    \multicolumn{5}{|c|}{\textbf{Datenmodell}} \\
    \hline
    \textbf{Datenmodell} & PGM & PHGM & PGM & PGM \\
    \textbf{Typsystem} & - & \checkmark (Klassen) & \checkmark (Klassen) & \checkmark (Attributschlüssel, Kantenbezeichner) \\
    \textbf{Vererbung} & - & mehrfach & einfach & - \\
	\textbf{Knotenbezeichner} & \checkmark  (optional) & \checkmark & \checkmark & - \\
	\textbf{Kantenbezeichner} & \checkmark & \checkmark  (optional) & \checkmark & \checkmark \\
	\textbf{Attributschema} & - & \checkmark & \checkmark (optional) & - \\
	\textbf{dynamische Schemaänderung} & - & \checkmark (Werteaustausch) & \checkmark & - \\
	\textbf{attributbezogene Integritätsbedingungen} & \texttt{UNIQUE} & Datentyp, \texttt{UNIQUE} & Datentyp, Wertebereich (explizit), \texttt{UNIQUE}, \texttt{NOT NULL} & Datentyp, \texttt{UNIQUE} \\
	\textbf{referentielle Integrität} & \checkmark & \checkmark & \checkmark & \checkmark \\
	\textbf{Besonderheiten} & mehrere Knotenbezeichner & n-äre Relationen höherer Ordnung & Multi-Datenmodell & Kardinalitäten, unidirektionale Kanten \\
   	\hline
   	\end{tabular} 
	\end{footnotesize}
	\setlength{\belowcaptionskip}{0.25cm}	
	\caption[Zusammenfassung: Datenmodell und Schemaverwaltung]{Gegenüberstellung der wesentlichen Eigenschaften des jeweiligen Datenmodells.}
	\label{tab:zusammenfassung_datenmodell}
\end{table}
\renewcommand{\arraystretch}{1}

OrientDB deckt mit der Unterstützung mehrerer Datenmodelle verschiedene Einsatzszenarien ab. Im Gegensatz zu Neo4j und Titan lassen sich Schemaverwaltung und Konsistenz-erhaltung systemseitig umsetzen. Dokumentenklassen erlauben die Schemadefinition, dabei ist insbesondere auf die Vielzahl attributbezogener Integritätsbedingungen hinzuweisen. Die Möglichkeit, Attribute als obligatorisch zu deklarieren stellt dabei einen Kompromiss zwischen selbstbeschreibender und strukturierter Datenhaltung dar. Durch die Unterstützung eingebetteter Beziehungen sind beliebige Objektkompositionen an Knoten- und Kanteninstanzen möglich.\\
Die Implementierung des PGM in Titan ist ähnlich zur Umsetzung in Neo4j, Schemadefinitionen für Knoten- und Kantenattribute sind nicht möglich. Knotenbezeichner werden nicht unterstützt, das GDBMS erlaubt jedoch als einziges im Vergleich die mehrfache Verwendung von Attributschlüsseln an Knoten und Kanten sowie die Einschränkung der Kardinalität der an einer Beziehungen beteiligten Instanzen. Infolge der Definition von Attributschlüsseln lässt sich darüber hinaus der Datentyp und somit der Wertebereich der Attributwerte einschränken. Das Konzept der knoten-zentrierten Indizes ist im Vergleich einzigartig und kann insbesondere in stark vernetzten Informationssystemen mit vielen verschiedenen Beziehungsarten vorteilhaft sein.

%- generell
%	- alle Systeme sind flexibel hinsichtlich Schemaänderungen
%% Tabelle
%- Neo4j: PGM
%	+ Knotenlabel (mehrere)
%	+ flexible Schemaänderung
%	- keine Objekteinbettung
%	- keine Schemadefinition für Attribute	
%	- viel Verantwortung wird an die Anwendung übergeben

%- HyperGraphDB: 
%	+ Atom-Modell sehr generisch -> für den Anwendungsfall jedoch nicht zwingend erforderlich	
%	+ mächtiges Typsystem, Vererbungshierarchien, Schema durch Klassendefinition
%	+ flexible Schemaänderung
%	+ umfangreiches Typsystem
%	- keine Updates, Änderungen durch Werteaustausch
%	- kein direkter Zugriff auf Nachbarschaft
%	- komplizierte Definition der Semantik der Position in Zielmenge

%- OrientDB:
%	+ Multi-Modell-Ansatz (Dokumentenmodell als Basis) 
%	+ Schema durch Klassendefinition (+ einfache Vererbung)
%	+ umfangreiche attributbezogene Integritätsbedingungen
%	+ Rechteverwaltung
%	- bietet zwar vielfältige Einsatzmöglichkeiten, der Fokus scheint jedoch auf der dokumentenorientierten Verwendung und weniger auf vernetzten Informationen zu liegen	
%	- Dokumentmodell als Basis
%	- PGM auf Dokumente abgebildet
	
%- Titan:
%	+ Definition von TitanKey und TitanLabel zur Optimierung der Speicherung (Performance)
%	+ erlaubt mehrfache Verwendung von Attributschlüsseln an Knoten / Kante
%	+ Einschränkung der Kardinalität von Beziehungen
%	- keine Schemadefinition an Knoten und Kanten
%	+ Einschränkung der Attribute
%	+ Einschränkung Datentypen
%	+ verschachtelte Attributwerte (Maps)
%	+ Erweiterungen des PGM
%		+ Vertex-centric Indices
%		+ unidirektionale Kanten
%		+ Einschränkung der Kardinalität
%		+ als einziges System mehrfache Verwendung eines Attributschlüssels an der Instanz


\paragraph*{Zugriffsmechanismen}

Die Systeme wurden hinsichtlich ihrer Eignung für die in Abschnitt \ref{subsec:graph_operations} beschriebenen graphenspezifischen Operationen untersucht, Tabelle \ref{tab:zusammenfassung_zugriffsmechanismen} fasst die Ergebnisse zusammen.

% CRUD alle
Die Manipulation der Datenbasis ist in allen Systemen möglich, wird darüber hinaus ein Typsystem angeboten, stehen entsprechende Methoden für dessen Definition bereit. Beim Auslesen der Daten kann die Selektion von Teilmengen durch die Angabe von Prädikaten realisiert werden. Ausgehend von Knoten- und Kanteninstanzen erlauben die Systeme den Zugriff auf die jeweilige Nachbarschaft und das Auslesen der Attribute. Folglich eignen sich die imperativen Java APIs in allen Systemen für die Implementierung eigener Graphalgorithmen.

\renewcommand{\arraystretch}{1.25}
\begin{table}[h]
	\centering
	\begin{footnotesize}
   	\begin{tabular}{|m{3cm}|>{\centering}m{2.9cm}|>{\centering}m{2.9cm}|>{\centering}m{2.9cm}|>{\centering\arraybackslash}m{2.9cm}|}
	\hline	
   	 \textbf{GDBMS} & \textbf{Neo4j} & \textbf{HyperGraphDB (BerkeleyDB)} & \textbf{OrientDB} & \textbf{Titan (BerkeleyDB)} \\   
   	\hline
   	\multicolumn{5}{|c|}{\textbf{Zugriffsmechanismen}} \\
	\hline
   	\textbf{Java API} & \checkmark & \checkmark & \checkmark & \checkmark \\
   	\textbf{Traversal API} & \checkmark & \checkmark & \checkmark & \checkmark \\
   	\textbf{Anfragesprachen} & Cypher, Gremlin & Prädikate\newline~(Java API) & OrientDB-SQL, Gremlin & Gremlin \\
   	\hline
	\multicolumn{5}{|c|}{\textbf{Operationen}} \\
   	\hline
   	\textbf{CRUD} & \checkmark & \checkmark & \checkmark & \checkmark \\
   	\textbf{Mengenorientiert} & \checkmark & \checkmark & \checkmark & \checkmark \\
   	\textbf{Traversierung} & \checkmark & \checkmark & \checkmark & \checkmark \\
   	\textbf{Mustersuche} & \checkmark & - & \checkmark & \checkmark \\
   	\textbf{Aggregation} & \checkmark & - & \checkmark & \checkmark \\
   	\textbf{Gruppierung} & \checkmark & - & \checkmark & \checkmark \\
   	\textbf{Summierung} & - & - & - & - \\
   	\textbf{Metriken} & - & - & - & - \\
   	\hline
	\multicolumn{5}{|c|}{\textbf{Verfügbare Algorithmen}} \\   	
   	\hline
   	\textbf{Algorithmen\newline~(nativ)} & Dijkstra, A*, BFS, DFS & Dijkstra & - & - \\
   	\textbf{Algorithmen\newline~(TinkerPop)} & Bellman-Ford & - & Dijkstra, Bellman-Ford, A*, BFS, DFS & Dijkstra, Bellman-Ford, A*, BFS, DFS \\
   	\hline
   	\end{tabular} 
	\end{footnotesize}
	\setlength{\belowcaptionskip}{0.25cm}	
	\caption[Zusammenfassung: Zugriffsmechanismen]{Gegenüberstellung der Zugriffsmechanismen und unterstützter Operationen in den betrachteten GDBMS.}
	\label{tab:zusammenfassung_zugriffsmechanismen}
\end{table}
\renewcommand{\arraystretch}{1}

% Neo4j
Für die Traversierung des Graphen bietet Neo4j mit dem Traversal Framework ein unterstützendes Werkzeug an. Die Durchlaufreihenfolge, das mehrfache Betrachten von Instanzen und Filterkriterien für Kantenbezeichner und -richtung können konfiguriert werden, durch die Einbettung in Java lassen sich beliebige Entscheidungslogiken implementieren. Das Prüfen der Erreichbarkeit ist folglich ebenfalls möglich. Neo4j bietet darüber hinaus integrierte Graphalgorithmen zur Suche kürzester Pfade in gewichteten und ungewichteten Graphen oder für das Finden aller Wege zwischen definierten Instanzen an. Im Vergleich erlauben die Algorithmen als einzige die Angabe von Filterkriterien.\\
Neben der Traversierung in Java kann alternativ die Anfragesprache Cypher für die Wegsuche genutzt werden. Kernelement der Sprache ist das Kombinieren mehrerer abstrakter Wegdefinition zu Mustergraphen. Der deklarative Charakter ermöglicht dabei ein intuitives Formulieren komplexer Strukturen entsprechend dem PGM. Mustergraphen lassen sich optional an die Datenbasis binden und ihre Elemente mit Variablen auszeichnen, deren Instanzmengen sich wiederum durch Prädikate einschränken lassen.\\
Eine topologische Summierung des Graphen wird von keinem der Systeme unterstützt. Die Aggregation von Nutzdaten und die damit verbundene Gruppierung sind in Neo4j möglich. Cypher bietet hierfür eine Vielzahl von Funktionen zur Berechnung von Aggregaten sowie zur Manipulation der Ergebnismenge.

% HyperGraphDB
HyperGraphDB weist im Vergleich den geringsten Funktionsumfang hinsichtlich graphenspezifischer Operationen auf, bietet jedoch durch eine offene, erweiterbare Architektur die Möglichkeit zur Erweiterung des GDBMS an. Der Zugriff auf die Datenbasis erfolgt ausschließlich innerhalb einer Java-Anwendung. Analog zu Neo4j wird ein Framework für die Traversierung des Graphen bereitgestellt, dieses besitzt jedoch einen deutlich geringeren Funktionsumfang. Filterkriterien für Knoten- und Kanteninstanzen lassen sich durch Prädikate formulieren; alle weiteren Eigenschaften der Traversierung müssen via Java realisiert werden. Sollen Pfadinstanzen als Ergebnis zur Verfügung stehen, so liegt dies in der Verantwortung des Programmierers.\\
Die Definition von Mustergraphen ist in HyperGraphDB nicht möglich, das integrierte, prädikat-basierte Anfragesystem ist ausschließlich mengenorientiert und erlaubt keine Definition von Variablen für die Extraktion von Teilgraphen. Das Aggregieren und Gruppieren von Nutzdaten muss ebenfalls durch anwendungsseitig implementierte Funktionen erfolgen.

% OrientDB
Der in OrientDB angebotene SQL-Dialekt eignet sich primär für die mengenorientierte Verarbeitung semi-strukturierter Daten in Form von Dokumenten. Die von SQL gewohnte Aggregation und Gruppierung von Nutzdaten wird in diesem Zusammenhang unterstützt. Wird OrientDB als GDBMS genutzt, müssen für die Datenmanipulation dedizierte Befehle verwendet werden. Das Traversieren erfolgt in OrientDB durch einen speziellen Operator, Filter- und Abbruchkriterien werden durch Selektion realisiert, was bei einer komplexen Traversierung die Schachtelung von Anfragen erfordert. Insgesamt betrachtet sind die graphenspezifischen SQL-Erweiterungen wenig intuitiv, in Verbindung mit der unzureichenden, inkonsistenten Dokumentation gestaltete sich deren Verwendung im Vergleich zu Cypher und Gremlin als schwierig bis unmöglich. Im Rahmen der Analyse kam es darüber hinaus zu falschen Ergebnissen der integrierten Pfadsuchalgorithmen, ein entsprechender Eintrag auf der Mailingliste blieb bisher unbeantwortet.\footnote{Die Fehlerbeschreibung kann unter \url{https://groups.google.com/forum/?hl=de\#!topic/orient-database/gsw44qcXtMM} nachvollzogen werden.} Die Verwendung des SQL-Dialektes für die Realisierung einer Mustersuche innerhalb des Graphen ist nicht dokumentiert.\\
Da OrientDB die Blueprints API implementiert, lässt sich Gremlin für graphenspezifische Operationen einsetzen. Die im Zusammenhang mit Titan beschriebene Traversierung und Mustersuche ist somit auch in OrientDB anwendbar. Darüber hinaus stehen für das Berechnen kürzester Pfade die ebenfalls im TinkerPop-Projekt angebotenen Graphalgorithmen zur Verfügung.

% Titan
Titan ist eine native Implementierung der Blueprints API und bietet Gremlin als primäre Anfragesprache an. Diese kann sowohl für die Manipulation der Datenbasis als auch für die Traversierung und Mustersuche genutzt werden. Die Sprache eignet sich im besonderen Maße für die intuitive Beschreibung abstrakter Wege und wurde speziell für das PGM entwickelt. Durch die Integration in Java, kann Programmlogik in Form von Seiteneffekten während der Traversierung ausgeführt und somit zum Beispiel das Berechnen von Aggregaten oder eine Abbruchbedingung für Pfadsuchen realisiert werden. Analog zu OrientDB lassen sich die im TinkerPop-Projekt angebotenen Graphalgorithmen in Titan verwenden.\\
Die Definition eines Mustergraphen ist in Gremlin ebenfalls möglich, gestaltet sich im Vergleich zu Cypher jedoch aufwendiger, da eine Fragmentierung in mehrere abstrakte Wege nicht möglich ist. Es lässt sich auch hier eine beliebige Anzahl Konstanten und Variablen innerhalb des Musters festlegen und Instanzen gefundener Teilgraphen als Ergebnis zurückgeben.

\paragraph*{Transaktionsverwaltung}

Bei der Speicherung von Geschäftsinformationen wird ein hoher Anspruch an die Einhaltung der Konsistenz und die fehlertolerante Speicherung der Datenbasis gestellt. Aus diesem Grund wurde die Einhaltung der ACID-Anforderungen analysiert, Tabelle \ref{tab:zusammenfassung_transaktion} fasst die Ergebnisse zusammen.

\renewcommand{\arraystretch}{1.25}
\begin{table}[h]
	\centering
	\begin{footnotesize}
   	\begin{tabular}{|m{3cm}|>{\centering}m{2.9cm}|>{\centering}m{2.9cm}|>{\centering}m{2.9cm}|>{\centering\arraybackslash}m{2.9cm}|}
	\hline	
   	 \textbf{GDBMS} & \textbf{Neo4j} & \textbf{HyperGraphDB (BerkeleyDB)} & \textbf{OrientDB} & \textbf{Titan (BerkeleyDB)} \\   
   	\hline
%	\multicolumn{5}{|c|}{\textbf{Transaktionen}} \\   	
%	\hline
	\textbf{ACID-Eigenschaften} & ACID & ACI(D) & ACI(D) & ACID \\
   	\textbf{Isolationsebene} & \texttt{READ COMMITTED} & \texttt{SERIALIZABLE} & \texttt{SERIALIZABLE} (embedded) & \texttt{REPEATABLE READ} \\
   	\textbf{Synchronisation\newline~(GDBMS)} & RX-Sperrverfahren & MVCC & MVCC & RX-Sperrverfahren \\
   	\textbf{Synchronisation\newline~(Storage)} & - & RX-Sperrverfahren & - & RX-Sperrverfahren \\
   	\textbf{Schachtelung} & \checkmark (kein isoliertes Rücksetzen) & \checkmark (isoliertes Rücksetzen) & - & \checkmark (keine Isolation) \\
   	\hline
	\end{tabular} 
	\end{footnotesize}
	\setlength{\belowcaptionskip}{0.25cm}	
	\caption[Zusammenfassung: Transaktionsverwaltung]{Gegenüberstellung von ACID-Eigenschaften und Transaktionsmechanismen der betrachteten GDBMS.}
	\label{tab:zusammenfassung_transaktion}
\end{table}
\renewcommand{\arraystretch}{1}

Es wurde gezeigt, dass Neo4j die ACID-Eigenschaften erfüllt, jedoch die im Vergleich geringste Isolationsebene aufweist. Sollen im parallelen Betrieb entsprechende Mehrbenutzeranomalien vermieden werden, so liegt dies analog zur Schemaverwaltung und Konsistenzerhaltung in der Verantwortung der Anwendung.\\
HyperGraphDB nutzt BerkeleyDB für die Einhaltung der ACID-Eigenschaften. Für eine bessere Performanz wird dabei auf die garantierte Dauerhaftigkeit von Änderungen verzichtet, diese lässt sich jedoch manuell aktivieren. Für den isolierten Zugriff auf den Cache implementiert das GDBMS ein MVCC-Verfahren, welches die höchste Isolationsebene garantiert. HyperGraphDB bietet als einziges der betrachteten Systeme das isolierte Rücksetzen geschachtelter Transaktionen an und eignet sich somit speziell für langlaufende Änderungstransaktionen, welche auf mehrere untergeordnete Transaktionen aufgeteilt werden.\\
Ein Systemausfall kann auch in OrientDB zum Verlust der Änderungen erfolgreich beendeter Transaktionen führen. Es besteht jedoch ebenfalls die Möglichkeit, Wiederherstellungsinformationen unter Inkaufnahme eines Geschwindigkeitsverlustes auf den Externspeicher zu forcieren. OrientDB garantiert im eingebetteten Betrieb die höchste Isolationsebene, dies gilt jedoch nicht für den entfernten Zugriff.\\
Die ACID-Eigenschaften von Titan variieren je nach eingesetztem Speichersystemen: BerkeleyDB wird mit Standardeinstellungen verwendet und garantiert folglich auch die Dauerhaftigkeit erfolgreicher Transaktionen. Das GDBMS stellt die Einhaltung definierter Integritätsbedingungen durch das Setzen von Sperren sicher.

Die Verwendung eines pessimistischen Synchronisationsverfahrens führt dazu, dass sich entsprechende Systeme vorrangig für kurze Änderungstransaktionen eignen, da ein Blockieren parallel ausgeführter Transaktionen möglich ist. Im Forschungsvorhaben sollen hauptsächlich Lesetransaktionen für die lokale Analyse des Graphen durchgeführt werden, Änderungen hingegen erfolgen in periodischen Bulk-Load-Prozessen. Die Verwendung eines RX-Sperrverfahrens stellt somit im Vergleich kein Defizit dar. Zu beachten ist, dass alle GDBMS die Atomarität von Änderungen durch deren Zwischenspeicherung im Hauptspeicher sicherstellen, dies kann bei langen Lese- oder Änderungstransaktionen zu Problemen führen.

\paragraph*{Persistenz-, Cache- und Indexverwaltung}

Die Repräsentation des Graphen auf dem Externspeicher bzw. im verwendeten Speichersystem wurde ebenfalls betrachtet um davon ausgehend eine erste Einschätzung hinsichtlich der Performance graphenspezifischer Operationen treffen zu können. Darüber hinaus spielen Caches und Indexstrukturen beim Zugriff auf die hinterlegten Informationen eine wichtige Rolle, weswegen diese ebenfalls betrachtet wurden. Tabelle \ref{tab:zusammenfassung_persistenz} fasst die Ergebnisse der Analyse zusammen.

\renewcommand{\arraystretch}{1.25}
\begin{table}[h]
	\centering
	\begin{footnotesize}
   	\begin{tabular}{|m{3cm}|>{\centering}m{2.9cm}|>{\centering}m{2.9cm}|>{\centering}m{2.9cm}|>{\centering\arraybackslash}m{2.9cm}|}
	\hline
   	 \textbf{GDBMS} & \textbf{Neo4j} & \textbf{HyperGraphDB} & \textbf{OrientDB} & \textbf{Titan} \\   
 	\hline
 	\multicolumn{5}{|c|}{\textbf{Persistenzverwaltung}} \\
	\hline
	\textbf{Realisierung} & Store-Konzept & Key-Value-Modell & Dokument-Modell & Key-Column-Value-Modell \\
	\textbf{Trennung Topologie, Nutzdaten} & \checkmark & \checkmark & - & - \\
	\textbf{Satzlänge} & fest & variabel & variabel & variabel \\
	\textbf{Zeitkomplexität Zugriff Nachbarschaft} & konstant & logarithmisch (BerkeleyDB) & konstant & logarithmisch (BerkeleyDB), konstant (Cassandra)\\
	\textbf{Indexfreie Adjazenz} & \checkmark & - (BerkeleyDB) & \checkmark & - (BerkeleyDB), \checkmark (Cassandra) \\
	\hline	
	\multicolumn{5}{|c|}{\textbf{Cacheverwaltung}} \\
	\hline
	\textbf{Caches} & MMF, Filesystem-Cache (LFU), Objekt-Cache (Schwache Referenzen) & Atomcache (LRU), Inzidenzcache (LRU) & MMF, L2 Cache (FIFO), L1 Cache (Schwache Referenzen) & Transaktionscache \\
	\hline
	\multicolumn{5}{|c|}{\textbf{Indexverwaltung}} \\   	
   	\hline
	\textbf{Primärindex} & \checkmark & \checkmark & \checkmark & \checkmark \\
	\textbf{Sekundärindex} & \checkmark & \checkmark & \checkmark & \checkmark \\
	\textbf{mehrdimensional} & - & - & \checkmark & - \\
	\textbf{Aktualisierung} & automatisch & automatisch & automatisch & automatisch \\
	\textbf{Externe Indexstrukturen} & Apache Lucene, Neo4j Spatial & - & - & Elastic Search, Apache Lucene \\
	%\textbf{Besonderheiten} & - & - & - & Knoten-zentrierte Indizes \\
   	\hline
	\end{tabular} 
	\end{footnotesize}
	\setlength{\belowcaptionskip}{0.25cm}	
	\caption[Zusammenfassung: Persistenz-, Cache- und Indexverwaltung]{Gegenüberstellung der Persistenz-, Cache- und Indexverwaltung in den untersuchten GDBMS.}
	\label{tab:zusammenfassung_persistenz}
\end{table}
\renewcommand{\arraystretch}{1}

% Persistenzverwaltung

% Neo4j
Neo4j bietet im Vergleich als einziges GDBMS eine Speicherung an, die explizit für die Abbildung eines Property-Graphen entwickelt und optimiert ist. Die Trennung von Topologie und Nutzdaten wird durch eine Aufteilung in mehrere Stores weiter verfeinert. Die Verwendung fester Satzlängen ermöglicht bereits in der physischen Repräsentation ein effizientes Berechnen der Nachbarschaft eines Knotens unabhängig von der Größe des Graphen und ohne dabei einen zusätzlichen Index berücksichtigen zu müssen. Ein Nachteil, welcher jedoch auf alle untersuchten GDBMS zutrifft, ist die fehlende Abbildung einer logischen Adjazenz auf eine physische Adjazenz, Datensätze adjazenter Knoten sind nicht zwingend physisch benachbart.

%- Neo4j: nativ
%	+ Trennung von Topologie und Daten
%	+ physische Trennung feingranular durch Store-Konzept
%	+ effiziente Berechnung physischer Positionen in Folge der festen Satzlänge von Knoten und  Kanten versprechen hohe Performance beim Traversieren des Graphen	
%	+ indexfreie Adjazenz wird erreicht
%	- Fragmentierung der Stores durch Löschen einzelner Einträge
%	- logisch benachbarte Knoten sind nicht zwingend physisch benachbart

% HyperGraphDB
HyperGraphDB trennt ebenfalls Topologie und Nutzdaten, dabei ist jedoch zu beachten, dass das Typsystem ebenfalls Teil der Topologie ist. Die Abbildung auf mehrere Key-Value-Datenbanken in BerkeleyDB führt dazu, dass die Performanz des Traversieren von der Größe des Gesamten Graphen abhängig ist, da jeder Zugriff auf ein Graphelement eine Suche im B-Baum nach sich zieht. Dies gilt sowohl für das Bestimmen inzidenter Knoten einer Kante und für jeden primitiven Attributwert. Das sich dieses Abbildung negativ auf die Gesamtperformance des Systems auswirkt wurde bereits in \cite{Dominguez-Sal:2010:SGD:1927585.1927590} und \cite{Gehrels:2013} gezeigt.
 
%- HyperGraphDB: nicht-nativ
%	+ Trennung von Topologie und Daten
%	- zu beachten: Typsystem ebenfalls Teil der topologischen Daten
%	- keine indexfreie Adjazenz mit BerkeleyDB
%	- Traversierung: O(logn)

% OrientDB
OrientDB bildet den Graphen auf ein Dokumentenmodell ab und speichert dabei Nutzdaten und Beziehungsinformationen innerhalb eines Dokumentes. Eine physische Partitionierung der Datenbasis in Cluster ermöglicht dabei eine Einschränkung der in Anfragen zu berücksichtigenden Datensätze. Durch die feste Satzlänge innerhalb eines Clusters ist der Zugriff auf die Nachbarschaft eines Knotens analog zu Neo4j in konstanter Zeit und ohne zusätzlichen Indexzugriff möglich. Ungeachtet dessen weist das Speichersystem von OrientDB mehrere Defizite auf: Die Cluster-Datei stellt eine zusätzliche Indirektion im Zugriff auf die hinterlegten Daten dar; durch die variable Satzlänge im Data Segement wird beim Zugriff auf einzelne Attribute oder Beziehungen zunächst das gesamte Dokument deserialisiert und anschließend die relevanten Informationen extrahiert; werden Kantenattribute verwendet, so werden diese in einem zusätzlichen Dokument abgelegt und stellen folglich eine weitere Indirektion im Zugriff dar. Die aufgeführten Defizite könnten eine Erklärung dafür sein, dass in \cite{Ciglan:2012} für OrientDB bei ausschließlich strukturbezogenen Benchmarks in attributierten Graphen trotz indexfreier Adjazenz das im Vergleich schlechteste Leistungsverhalten festgestellt wurde.

%- OrientDB: nicht-nativ
%	- keine Trennung von Topologie und Daten (alles im Dokument)
%	+ physisches Clustering semantischer Gruppierungen
%	- Traversierung: O(N\_v)
%	- schlechte Performance durch:	
%		- zusätzliche Indirektion durch Cluster-Datei beim Zugriff auf eigentliche Daten
%		- Deserialisierung erscheint ineffizient (evtl. Verweise auf ältere Benchmarks \cite{Ciglan:2012})	
%		- attributierte Kanten sind zusätzliche Indirektion\url{https://github.com/orientechnologies/orientdb/wiki/Performance-Tuning-Blueprints} -> können sich negativ auf die Performance beim Traversieren auswirken
%		- Fragmentierung der Stores	

% Titan
Titan bildet den Graphen auf ein Key-Column-Value Modell ab, eine Trennung von Topologie und Nutzdaten erfolgt dabei nicht, da sowohl Knotenattribute als auch deren inzidente Kanten innerhalb eines Datensatzes abgelegt werden. Im Gegensatz zu OrientDB erlaubt das Datenmodell jedoch den direkten Zugriff einzelne Attribute unter Angabe eines Schlüssels und

- Titan: nicht-nativ
	- keine Trennung von Topologie und Daten
	+ direkter Zugriff auf Attribute und inzidente Kanten
	- hoher Aufwand bei Speicherung in KV-Store 
	- redundante Speicherung von Kantenattributen
	- Traversierung O(logn)
	- Ein Vorteil gegenüber OrientDB und HyperGraphDB, ist die Möglichkeit des direkten Zugriffes auf Attribute und inzidente Kanten eines Knotens unter Angabe der Knoten-Identität und der geforderten 
	Column.
	
% Indexverwaltung
- Primär- und Sekundärindizes generell möglich
- Indizes werden automatisch aktualisiert
	- HyperGraphDB / Titan
		- generell drei / zwei systemseitige Indexstrukturen, welche bei Schreiboperationen berücksichtigt werden müssen -> Auswirkung auf Performance
- bis auf OrientDB wird eine Erweiterung um eigene Indexstrukturen dokumentiert
- Neo4j und Titan mit Unterstützung komplexer Indizierungsmechanismen durch Apache Lucene bzw. Elastic Search
- OrientDB
	+ mehrdimensionale Indizes

% Cacheverwaltung
	
- generell: Beschleunigung der Zugriffe auf häufig benötige Objekte via Caches
	- Hashtabellen  O(1) (wenn da)
	
- OrientDB
	- keine Cache-Synchronisation 
	- Empfehlung zur Deaktivierung des Caches im parallelen Betrieb
- HyperGraphDB / Titan
	- profitieren von Caching-Mechanismen in den eingesetzten Speichersystemen
- Titan
	- Transaktionscache kann bei langen Lese- oder Änderungstransaktionen zu Speicherproblemen führen





\paragraph*{Verteilung und Skalierbarkeit}

% Verteilung
- alle außer HyperGraphDB bieten die Möglichkeit zur Replikation 
	-> Ausfallsicherheit, Skalierbarkeit Lesezugriffe
	-> Single-Master, Multi-Master schränken Skalierbarkeit von Schreibzugriffen ein
	- Cassandra ermöglicht besseren, flexibleren Kompromiss aus Performance und Ausfallsicherheit
- Partitionierung nur in Titan möglich
	- bisherige Nutzung der zufälligen Zuordnung -> Weiterentwicklung bereits angekündgt
- Titan
	+ bietet als einziges GDBMS Replikation und Partitionierung und somit eine horizontale Skalierbarkeit von Zugriffen und Datenvolumen
	+ Fehlertoleranz
	- logische Nachbarschaft wird bei der Partitionierung nicht berücksichtigt

\renewcommand{\arraystretch}{1.25}
\begin{table}[h]
	\centering
	\begin{footnotesize}
   	\begin{tabular}{|m{2.6cm}|>{\centering}m{3cm}|>{\centering}m{3cm}|>{\centering}m{3cm}|>{\centering\arraybackslash}m{3cm}|}
	\hline
   	 \textbf{GDBMS} & \textbf{Neo4j} & \textbf{HyperGraphDB} & \textbf{OrientDB} & \textbf{Titan} \\   
 	\hline
	\multicolumn{5}{|c|}{\textbf{Verteilung}} \\
	\hline
	\textbf{Architektur} & Master-Slave (nur Enterprise Edition) & Peer-To-Peer Nachrichten Framework & Master-Master & Peer-to-Peer (Cassandra) \\
	\textbf{Replikation} & \checkmark & - & \checkmark & \checkmark \\
	\textbf{Partitionierung} & - & - & - & \checkmark \\
	%\textbf{Strong Consistency} & \checkmark & - & \checkmark & \checkmark \\
	%\textbf{Eventual Consistency} & \checkmark & - & \checkmark & \checkmark \\
	\textbf{Skalierbarkeit Lesen} & horizontal & - & horizontal & horizontal \\
	\textbf{Skalierbarkeit Schreiben} & vertikal & - & vertikal & horizontal \\
	\textbf{Skalierbarkeit Datenvolumen} & vertikal & - & vertikal & horizontal \\
   	\hline
  	\end{tabular} 
	\end{footnotesize}
	\setlength{\belowcaptionskip}{0.25cm}	
	\caption[Zusammenfassung: Verteilung und Skalierbarkeit]{Datenverteilung und Skalierbarkeit der untersuchten GDBMS}
	\label{tab:zusammenfassung_persistenz}
\end{table}
\renewcommand{\arraystretch}{1}


Unter Berücksichtigung der vorgestellten Ergebnisse werden Neo4j und Titan im letzten Kapitel der Arbeit in einem Benchmark untersucht um die Leistungsfähigkeit der Systeme abschließend beurteilen zu können. Insbesondere soll dabei auch untersucht werden, inwieweit eine native Speicherung des Graphen vorteilhaft ist oder ob die Nutzung bestehender Systeme eine gleichwertige Alternative darstellt.