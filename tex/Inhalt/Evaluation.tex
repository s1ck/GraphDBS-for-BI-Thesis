\chapter{Evaluation von Graphdatenbanksystemen}
\label{cha:evaluation}

Dieses Kapitel setzt sich mit konkreten GDBMS-Implementierungen auseinander. Mit der Zielstellung, aus der Vielzahl existierender Systeme geeignete auszuwählen, werden zunächst funktionale Anforderungen definiert. Diese ergeben sich aus aktuellen Forschungsvorhaben am Lehrstuhl Datenbanken der Universität Leipzig. Die ausgewählten Systeme werden anschließend im Detail betrachtet, die Schwerpunkte dabei sind: Datenmodellierung und Konsistenzerhaltung, Zugriffsmechanismen und angebotene graphenspezifische Operationen, physische Repräsentation des Graphen und Möglichkeiten der Indexierung und Verteilung. Das Kapitel schließt mit einer Gegenüberstellung der Systeme.

\section{Aktuelle Forschungsvorhaben}
\label{sec:anforderungen}

Wie bereits im vorhergehenden Kapitel erläutert, ist ein Informationsnetzwerk der Netzwerktypus, in welchem Informationen in Form von Begriffen oder konkreten Daten miteinander verknüpft sind. Die Struktur des Netzwerkes ist dabei die Grundlage für Analysen, deren Ziel es ist, aus bestehenden Informationen neue Informationen abzuleiten, aus denen wiederum neues Wissen generiert werden soll. Im Bereich der Unternehmensdaten werden diese analytischen Verfahren und damit verbundene Anwendungen unter dem Begriff Business Intelligence (BI) zusammengefasst\cite{Watson:2007:CSB:1300761.1301970}. Unternehmen setzen BI ein, um möglichst gewinnbringende Informationen aus vorhandenen Daten zu extrahieren. Auf Basis dieser Informationen können der Zustand des Unternehmens eingeschätzt und Entscheidungen getroffen werden.

Verschiedene Bereiche eines Unternehmens nutzen unterschiedliche Geschäftsinformationssysteme zur Bewältigung ihrer Aufgaben. So unterscheidet man beispielsweise Systeme für Enterprise Resource Planning (ERP), Project Management (PM) und Customer Relationship Management (CRM), welche sich in technologischer, struktureller und semantischer Hinsicht unterscheiden können. BI setzt voraus, dass Daten aus heterogenen Systemen zunächst in ein System integriert werden, zu diesem Zweck werden Data Warehouses (DWH) eingesetzt\cite{Chaudhuri:2011:OBI:1978542.1978562, Watson:2007:CSB:1300761.1301970}. Ein DWH ist eine zentrale Datenbank, welche für Analysezwecke optimiert ist und in welcher Daten aus mehreren, i.A. heterogenen Quellen zusammengeführt, ggf. bereinigt und transformiert werden\cite{}. Im Rahmen der Transformation werden die Daten in ein einheitliches Schema überführt. Fakten werden in einer zentralen Tabelle hinterlegt und mit Dimensionstabellen verknüpft. Ein Fakt kann zum Beispiel der Kauf eines Produktes sein, der aus dem Kauf resultierende Umsatz ist die dem Fakt zugeordnete Kennzahl. Mögliche Dimensionen sind das Produkt, der Kaufzeitpunkt, der Kunde und die Filiale. Auf dieser Datenbasis sind vielfältige Analysen möglich, so können zum Beispiel der Umsatz in bestimmten Regionen, die Beliebtheit von Produkten oder die Rentabilität einzelner Filialen bestimmt werden.

Wie aus dem Beispiel des DWH hervorgeht, erfordert die Transformation das Definieren eines einheitlichen Schemas. Das bedeutet, dass die für die Analyse relevanten Beziehungen zwischen Dimensionen und Fakten vorab festgelegt werden müssen und somit jeder relevante Zusammenhang zwischen Fakt und Dimension bekannt sein und im Schema abgebildet werden muss. Dieser Sachverhalt schränkt jedoch die analytischen Möglichkeiten ein, da nur Zusammenhänge analysiert werden können, die im Schema definiert wurden. Unbekannte, eventuell nicht intuitiv erkennbare Zusammenhänge können in der Analyse nicht berücksichtigt werden.

Eines der Projekte am Lehrstuhl Datenbanken befasst sich mit der Entwicklung und Untersuchung von Methoden zur graphenbasierten Business Intelligence. Eine graphenbasierte Repräsentation von Unternehmensdaten weist die beschriebene Einschränkung eines vordefinierten Schemas nicht auf, vielmehr erlaubt sie die flexible Evaluation der Beziehungen zwischen einzelnen Objekten innerhalb der Unternehmensdaten. Diese lassen sich in zwei Kategorien einteilen: Transaktionale Daten und Stammdaten.
Zu den transaktionalen Daten gehören zum Beispiel Rechnungen im ERP-System, Plandaten im PM-System oder Kundenaktivitäten im CRM-System, sie entstehen bei der Ausführung von Geschäftsprozessen und sind sowohl untereinander als auch mit Stammdaten verknüpft. Beispiele für Stammdaten sind Informationen über Kunden, Produkte, Mitarbeiter oder Filialen. Aus diesem Zusammenhang lässt sich ein Graph ableiten: Transaktionale Daten und Stammdaten bilden die Knoten, der kausale und kontextuelle Zusammenhang zwischen ihnen wird durch Kanten beschrieben. Stammdaten weisen die Eigenschaft auf, dass sie in mehreren Systemen hinterlegt sein können, transaktionale Daten beschränken sich typischerweise auf das System, in dem sie erzeugt wurden. Beziehungen zwischen Objekten können generell systemübergreifend sein. Eine mögliche Analyse ist das Finden häufiger Muster. So lassen sich zum Beispiel Teilgraphen als Instanzen von Geschäftsprozessen extrahieren und hinsichtlich des Zusammenhangs zwischen erzeugtem Mehrwert und beteiligten Mitarbeitern untersuchen. Abbildung \ref{fig:bi-graph} zeigt ein Beispiel für einen aus Geschäftsdaten erzeugten Graphen.

Das Projekt verfolgt drei Ziele: Zunächst ist die Integration von Unternehmensdaten aus heterogenen Systemen in einen Graph erforderlich. Auf der Grundlage des integrierten Graphen werden in einer zweiten Phase Algorithmen für die graphenorientierte Analyse entwickelt. In der letzten Phase sollen Ansätze untersucht werden, die Datenbasis möglichst effizient für Analysten nutzbar zu machen, hierbei spielen insbesondere Anfragesprachen und Möglichkeiten zur Visualisierung eine Rolle. Für das Erreichen der Ziele sollen GDBMS die technologische Grundlage bilden, da sie eine flexible, graphenorientierte Datenmodellierung erlauben und Operationen zur Verfügung stellen unter deren Verwendung sich BI-orientierte Algorithmen implementieren lassen. Einige der verfügbaren Systeme beinhalten darüber hinaus bereits Anfragesprachen, welche als Basis für eigene Entwicklungen dienen können.

\begin{figure}[h] 
	\centering
		\includegraphics[scale=0.45]{exa_docgraph.pdf}
	\caption[Beispiel: BI-Graph]{Informationsnetzwerk, welches die Beziehungen zwischen den Objekten eines ERP- und eines CRM-Systems darstellt. Transaktionale Daten sind weiß,  Stammdaten grau dargestellt. Bezeichner und Richtung einer Kante beschreiben den kausalen Zusammenhang zwischen transaktionalen Daten (z.B. \texttt{basedOn}, \texttt{serves}) sowie zwischen transaktionalen Daten und Stammdaten (z.B. \texttt{sentBy}, \texttt{doneFor}). Der gezeigte Teilgraph bildet die Instanz eines vollständigen Geschäftsprozesses ab, deren erzeugter Mehrwert sich aus den Einnahmen (engl. \textit{Revenue}) und Ausgaben (engl. \textit{Expense}) der transaktionalen Daten bestimmen lässt. Am Beispiel des Knotens \texttt{Employee (E01)} wird deutlich, dass Stammdaten in mehreren Systemen vorhanden sein können.}
	\label{fig:bi-graph}
\end{figure}

\input{Inhalt/Vorauswahl}

\input{Inhalt/Neo4j}
\input{Inhalt/HyperGraphDB}
\input{Inhalt/OrientDB}
\input{Inhalt/Titan}

\section{Zusammenfassung und Zwischenfazit}

\renewcommand{\arraystretch}{1.25}
\begin{table}[t]
	\centering
	\begin{footnotesize}
   	\begin{tabular}{|m{3.1cm}|>{\centering}m{2.8cm}|>{\centering}m{2.8cm}|>{\centering}m{3.1cm}|>{\centering\arraybackslash}m{3cm}|}
	\hline
	\textbf{GDBMS} & \textbf{Neo4j} & \textbf{HyperGraphDB} & \textbf{OrientDB} & \textbf{Titan} \\   
   	\hline
   	\multicolumn{5}{|c|}{\textbf{Allgemeines}} \\
	\hline
   	\textbf{Hersteller} & Neo Technology & Kobrix Software & Orient Technologies & Aurelius \\
    \textbf{Lizenz} & GPLv3 & LGPL & Apache 2.0 & Apache 2.0 \\
    \textbf{Version (Jahr)} & 2.0.0-M04 (2013) & 1.2 (2012) & 1.5.1 (2013) & 0.3.2 (2013) \\
    \textbf{Sprache} & Java, Scala & Java & Java & Java \\
    \hline
    \multicolumn{5}{|c|}{\textbf{Kategorisierung}} \\
    \hline
    \textbf{Verarbeitung} & nativ & nativ & nativ & nativ \\
    \textbf{Speicherung} & nativ & je nach Speichersystem & nativ & je nach Speichersystem \\
    \textbf{Eingebettet} & \checkmark & \checkmark & \checkmark & \checkmark \\
    \textbf{Client-Server} & \checkmark & - & \checkmark & \checkmark \\
    \textbf{Disk-zentriert} & \checkmark & je nach Speichersystem & \checkmark & je nach Speichersystem \\
    \textbf{Hauptspeicher-zentriert} & - & - & - & - \\ 
   % \textbf{Datenbanken} & eine & eine & mehrere & eine \\
    \hline
    \multicolumn{5}{|c|}{\textbf{Datenmodell}} \\
    \hline
    \textbf{Datenmodell} & PGM & PHGM & PGM & PGM \\
    \textbf{Typsystem} & - & \checkmark (Klassen) & \checkmark (Klassen) & \checkmark (Attributschlüssel, Kantenbezeichner) \\
	\textbf{Knotenbezeichner} & \checkmark  (optional) & \checkmark & \checkmark & - \\
	\textbf{Kantenbezeichner} & \checkmark & \checkmark  (optional) & \checkmark & \checkmark \\
	\textbf{Attributschema} & - & \checkmark & \checkmark (optional) & - \\
	\textbf{dynamische Schemaänderung} & - & \checkmark (Werteaustausch) & \checkmark & - \\
	\textbf{attributbezogene Integritätsbedingungen} & Datentyp, \texttt{UNIQUE} & Datentyp, \texttt{UNIQUE} & Datentyp, Wertebereich (explizit), \texttt{UNIQUE} & Datentyp, \texttt{UNIQUE} \\
	\textbf{referentielle Integrität} & \checkmark & \checkmark & \checkmark & \checkmark \\
	\textbf{Vererbung} & - & \checkmark & \checkmark & - \\
	\textbf{Besonderheiten} & mehrere Knotenbezeichner & Relationen höherer Ordnung & Multi-Datenmodell & lokal eindeutige Attributschlüssel \& Kantenbezeichner \\
   	\hline
   	\end{tabular} 
	\end{footnotesize}
	\setlength{\belowcaptionskip}{0.25cm}	
	\caption[Zusammenfassung: Allgemeines, Kategorisierung und Datenmodell]{Allgemeines, Kategorisierung und Datenmodell.}
	\label{tab:zusammenfassung_allgemeines}
\end{table}
\renewcommand{\arraystretch}{1}

\renewcommand{\arraystretch}{1.25}
\begin{table}[t]
	\centering
	\begin{footnotesize}
   	\begin{tabular}{|m{3.1cm}|>{\centering}m{3cm}|>{\centering}m{3cm}|>{\centering}m{3cm}|>{\centering\arraybackslash}m{3cm}|}
	\hline	
   	 \textbf{GDBMS} & \textbf{Neo4j} & \textbf{HyperGraphDB (BerkeleyDB)} & \textbf{OrientDB} & \textbf{Titan (BerkeleyDB)} \\   
   	\hline
   	\multicolumn{5}{|c|}{\textbf{Zugriffsmechanismen}} \\
	\hline
   	\textbf{Java API} & \checkmark & \checkmark & \checkmark & \checkmark \\
   	\textbf{Traversal API} & \checkmark & \checkmark & \checkmark & \checkmark \\
   	\textbf{Anfragesprachen} & Cypher, Gremlin & Prädikate\newline~(Java API) & OrientDB-SQL, Gremlin & Gremlin \\
   	\hline
	\multicolumn{5}{|c|}{\textbf{Operationen}} \\
   	\hline
   	\textbf{CRUD} & \checkmark & \checkmark & \checkmark & \checkmark \\
   	\textbf{Mengenorientiert} & \checkmark & \checkmark & \checkmark & \checkmark \\
   	\textbf{Traversierung} & \checkmark & \checkmark & \checkmark & \checkmark \\
   	\textbf{Mustersuche} & \checkmark & - & \checkmark & \checkmark \\
   	\textbf{Aggregation} & \checkmark & - & \checkmark & \checkmark \\
   	\textbf{Gruppierung} & \checkmark & - & \checkmark & \checkmark \\
   	\textbf{Summierung} & - & - & - & - \\
   	\textbf{Metriken} & - & - & - & - \\
   	\hline
	\multicolumn{5}{|c|}{\textbf{Verfügbare Algorithmen}} \\   	
   	\hline
   	\textbf{Algorithmen\newline~(nativ)} & Dijkstra, A*, BFS, DFS & Dijkstra & - & - \\
   	\textbf{Algorithmen\newline~(Blueprints)} & Bellman-Ford & - & Dijkstra, Bellman-Ford, A*, BFS, DFS & Dijkstra, Bellman-Ford, A*, BFS, DFS \\
   	\hline
	\multicolumn{5}{|c|}{\textbf{Transaktionen}} \\   	
   	\hline
   	\textbf{ACID-Eigenschaften} & ACID & ACI(D) & ACID & ACID \\
   	\textbf{Isolationsebene} & \texttt{READ COMMITTED} & \texttt{SERIALIZABLE} & \texttt{SERIALIZABLE} & \texttt{REPEATABLE READ} \\
   	\textbf{Synchronisations-verfahren\newline~(Storage)} & RX-Sperrverfahren & RX-Sperrverfahren & MVCC & RX-Sperrverfahren \\
   	\textbf{Schachtelung} & ja, kein isoliertes Rücksetzen & ja, isoliertes Rücksetzen & nein & ja, keine Isolation \\
   	\hline
	\multicolumn{5}{|c|}{\textbf{Indexverwaltung}} \\   	
   	\hline
	\textbf{Primärindex} & \checkmark & \checkmark & \checkmark & \checkmark \\
	\textbf{Sekundärindex} & \checkmark & \checkmark & \checkmark & \checkmark \\
	\textbf{Aktualisierung} & automatisch & automatisch & automatisch & automatisch \\
	\textbf{Externe Indexstrukturen} & Apache Lucene, Neo4j Spatial & - & - & Elastic Search, Apache Lucene \\
	\textbf{Besonderheiten} & - & - & - & Knoten-zentrierte Indizes \\
   	\hline
   	\end{tabular} 
	\end{footnotesize}
	\setlength{\belowcaptionskip}{0.25cm}	
	\caption[Zusammenfassung: Allgemeines und Datenmodell]{Allgemeines und Datenmodell.}
	\label{tab:zusammenfassung_allgemeines}
\end{table}
\renewcommand{\arraystretch}{1}

\renewcommand{\arraystretch}{1.25}
\begin{table}[t]
	\centering
	\begin{footnotesize}
   	\begin{tabular}{|m{3.1cm}|>{\centering}m{3cm}|>{\centering}m{3cm}|>{\centering}m{3cm}|>{\centering\arraybackslash}m{3cm}|}
	\hline
   	 \textbf{GDBMS} & \textbf{Neo4j} & \textbf{HyperGraphDB} & \textbf{OrientDB} & \textbf{Titan} \\   
 	\hline
 	\multicolumn{5}{|c|}{\textbf{Persistenzverwaltung}} \\
	\hline
	\textbf{Realisierung} & Store-Konzept & Key-Value-Modell & Dokument-Modell & Key-Column-Value-Modell \\
	\textbf{Trennung Topologie, Nutzdaten} & \checkmark & \checkmark & - & - \\
	\textbf{Satzlänge} & fest & variabel & variabel & variabel \\
	\textbf{Zeitkomplexität Zugriff Nachbarschaft} & konstant & logarithmisch (BerkeleyDB) & konstant & logarithmisch (BerkeleyDB), konstant (Cassandra)\\
	\hline
	\multicolumn{5}{|c|}{\textbf{Cacheverwaltung}} \\
	\hline
	\textbf{Caches} & Memory Mapped Files, Filesystem-Cache (LFU), Objekt-Cache (Schwache Referenzen) & Atomcache (LRU), Inzidenzcache (LRU) & Memory Mapped Files, L2 Cache (FIFO), L1 Cache (Schwache Referenzen) & Transaktionscache \\
	\hline
	\multicolumn{5}{|c|}{\textbf{Verteilung}} \\
	\hline
	\textbf{Architektur} & Master-Slave (nur Enterprise Edition) & Peer-To-Peer Message Framework & Master-Master & Peer-to-Peer (Cassandra) \\
	\textbf{Replikation} & \checkmark & - & \checkmark & \checkmark \\
	\textbf{Partitionierung} & - & - & - & \checkmark \\
	\textbf{Skalierbarkeit Lesen} & horizontal & - & horizontal & horizontal \\
	\textbf{Skalierbarkeit Schreiben} & vertikal & - & vertikal & horizontal \\
	\textbf{Skalierbarkeit Datenvolumen} & vertikal & - & vertikal & horizontal \\
   	\hline
  	\end{tabular} 
	\end{footnotesize}
	\setlength{\belowcaptionskip}{0.25cm}	
	\caption[Zusammenfassung: Allgemeines und Datenmodell]{Allgemeines und Datenmodell.}
	\label{tab:zusammenfassung_allgemeines}
\end{table}
\renewcommand{\arraystretch}{1}