\chapter{Evaluation von Graphdatenbanksystemen}
\label{cha:evaluation}

Dieses Kapitel setzt sich mit konkreten GDBMS-Implementierungen auseinander. Mit der Zielstellung, aus der Vielzahl existierender Systeme geeignete auszuwählen, werden zunächst funktionale Anforderungen definiert. Diese ergeben sich aus aktuellen Forschungsvorhaben am Lehrstuhl Datenbanken der Universität Leipzig. Die ausgewählten Systeme werden anschließend im Detail betrachtet, die Schwerpunkte dabei sind: Datenmodellierung und Konsistenzerhaltung, Zugriffsmechanismen und angebotene graphenspezifische Operationen, physische Repräsentation des Graphen und Möglichkeiten der Indexierung und Verteilung. Das Kapitel schließt mit einer Gegenüberstellung der Systeme.

\section{Aktuelle Forschungsvorhaben}
\label{sec:anforderungen}

Wie bereits im vorhergehenden Kapitel erläutert, ist ein Informationsnetzwerk der Netzwerktypus, in welchem Informationen in Form von Begriffen oder konkreten Daten miteinander verknüpft sind. Die Struktur des Netzwerkes ist dabei die Grundlage für Analysen, deren Ziel es ist, aus bestehenden Informationen neue Informationen abzuleiten, aus denen wiederum neues Wissen generiert werden soll. Im Bereich der Unternehmensdaten werden diese analytischen Verfahren und damit verbundene Anwendungen unter dem Begriff Business Intelligence (BI) zusammengefasst\cite{Watson:2007:CSB:1300761.1301970}. Unternehmen setzen BI ein, um möglichst gewinnbringende Informationen aus vorhandenen Daten zu extrahieren. Auf Basis dieser Informationen können der Zustand des Unternehmens eingeschätzt und Entscheidungen getroffen werden.

Verschiedene Bereiche eines Unternehmens nutzen unterschiedliche Geschäftsinformationssysteme zur Bewältigung ihrer Aufgaben. So unterscheidet man beispielsweise Systeme für Enterprise Resource Planning (ERP), Project Management (PM) und Customer Relationship Management (CRM), welche sich in technologischer, struktureller und semantischer Hinsicht unterscheiden können. BI setzt voraus, dass Daten aus heterogenen Systemen zunächst in ein System integriert werden, zu diesem Zweck werden Data Warehouses (DWH) eingesetzt\cite{Chaudhuri:2011:OBI:1978542.1978562, Watson:2007:CSB:1300761.1301970}. Ein DWH ist eine zentrale Datenbank, welche für Analysezwecke optimiert ist und in welcher Daten aus mehreren, i.A. heterogenen Quellen zusammengeführt, ggf. bereinigt und transformiert werden\cite{}. Im Rahmen der Transformation werden die Daten in ein einheitliches Schema überführt. Fakten werden in einer zentralen Tabelle hinterlegt und mit Dimensionstabellen verknüpft. Ein Fakt kann zum Beispiel der Kauf eines Produktes sein, der aus dem Kauf resultierende Umsatz ist die dem Fakt zugeordnete Kennzahl. Mögliche Dimensionen sind das Produkt, der Kaufzeitpunkt, der Kunde und die Filiale. Auf dieser Datenbasis sind vielfältige Analysen möglich, so können zum Beispiel der Umsatz in bestimmten Regionen, die Beliebtheit von Produkten oder die Rentabilität einzelner Filialen bestimmt werden.

Wie aus dem Beispiel des DWH hervorgeht, erfordert die Transformation das Definieren eines einheitlichen Schemas. Das bedeutet, dass die für die Analyse relevanten Beziehungen zwischen Dimensionen und Fakten vorab festgelegt werden müssen und somit jeder relevante Zusammenhang zwischen Fakt und Dimension bekannt sein und im Schema abgebildet werden muss. Dieser Sachverhalt schränkt jedoch die analytischen Möglichkeiten ein, da nur Zusammenhänge analysiert werden können, die im Schema definiert wurden. Unbekannte, eventuell nicht intuitiv erkennbare Zusammenhänge können in der Analyse nicht berücksichtigt werden.

Eines der Projekte am Lehrstuhl Datenbanken befasst sich mit der Entwicklung und Untersuchung von Methoden zur graphenbasierten Business Intelligence. Eine graphenbasierte Repräsentation von Unternehmensdaten weist die beschriebene Einschränkung eines vordefinierten Schemas nicht auf, vielmehr erlaubt sie die flexible Evaluation der Beziehungen zwischen einzelnen Objekten innerhalb der Unternehmensdaten. Diese lassen sich in zwei Kategorien einteilen: Transaktionale Daten und Stammdaten.
Zu den transaktionalen Daten gehören zum Beispiel Rechnungen im ERP-System, Plandaten im PM-System oder Kundenaktivitäten im CRM-System, sie entstehen bei der Ausführung von Geschäftsprozessen und sind sowohl untereinander als auch mit Stammdaten verknüpft. Beispiele für Stammdaten sind Informationen über Kunden, Produkte, Mitarbeiter oder Filialen. Aus diesem Zusammenhang lässt sich ein Graph ableiten: Transaktionale Daten und Stammdaten bilden die Knoten, der kausale und kontextuelle Zusammenhang zwischen ihnen wird durch Kanten beschrieben. Stammdaten weisen die Eigenschaft auf, dass sie in mehreren Systemen hinterlegt sein können, transaktionale Daten beschränken sich typischerweise auf das System, in dem sie erzeugt wurden. Beziehungen zwischen Objekten können generell systemübergreifend sein. Eine mögliche Analyse ist das Finden häufiger Muster. So lassen sich zum Beispiel Teilgraphen als Instanzen von Geschäftsprozessen extrahieren und hinsichtlich des Zusammenhangs zwischen erzeugtem Mehrwert und beteiligten Mitarbeitern untersuchen. Abbildung \ref{fig:bi-graph} zeigt ein Beispiel für einen aus Geschäftsdaten erzeugten Graphen.

Das Projekt verfolgt drei Ziele: Zunächst ist die Integration von Unternehmensdaten aus heterogenen Systemen in einen Graph erforderlich. Auf der Grundlage des integrierten Graphen werden in einer zweiten Phase Algorithmen für die graphenorientierte Analyse entwickelt. In der letzten Phase sollen Ansätze untersucht werden, die Datenbasis möglichst effizient für Analysten nutzbar zu machen, hierbei spielen insbesondere Anfragesprachen und Möglichkeiten zur Visualisierung eine Rolle. Für das Erreichen der Ziele sollen GDBMS die technologische Grundlage bilden, da sie eine flexible, graphenorientierte Datenmodellierung erlauben und Operationen zur Verfügung stellen unter deren Verwendung sich BI-orientierte Algorithmen implementieren lassen. Einige der verfügbaren Systeme beinhalten darüber hinaus bereits Anfragesprachen, welche als Basis für eigene Entwicklungen dienen können.

\begin{figure}[h] 
	\centering
		\includegraphics[scale=0.45]{exa_docgraph.pdf}
	\caption[Beispiel: BI-Graph]{Informationsnetzwerk, welches die Beziehungen zwischen den Objekten eines ERP- und eines CRM-Systems darstellt. Transaktionale Daten sind weiß,  Stammdaten grau dargestellt. Bezeichner und Richtung einer Kante beschreiben den kausalen Zusammenhang zwischen transaktionalen Daten (z.B. \texttt{basedOn}, \texttt{serves}) sowie zwischen transaktionalen Daten und Stammdaten (z.B. \texttt{sentBy}, \texttt{doneFor}). Der gezeigte Teilgraph bildet die Instanz eines vollständigen Geschäftsprozesses ab, deren erzeugter Mehrwert sich aus den Einnahmen (engl. \textit{Revenue}) und Ausgaben (engl. \textit{Expense}) der transaktionalen Daten bestimmen lässt. Am Beispiel des Knotens \texttt{Employee (E01)} wird deutlich, dass Stammdaten in mehreren Systemen vorhanden sein können.}
	\label{fig:bi-graph}
\end{figure}

\input{Inhalt/Vorauswahl}

\input{Inhalt/Neo4j}
\input{Inhalt/HyperGraphDB}
\input{Inhalt/OrientDB}
\input{Inhalt/Titan}

\section{Zusammenfassung, Vergleich und Auswahl}

\paragraph*{Kategorisierung und Dokumentation}

- nur einführende Beispiele

Neo4j
	- sehr gute, aktuelle Dokumentation	
	- Support auf Mailingliste
	- aktive Community (Stackoverflow, Mailing List. viele Präsentationen)
	- im Entwicklungsstand am weitesten fortgeschritten
	- nur wenig Quelltextrecherche erforderlich

HyperGraphDB
	- gute Dokumentation
	- wird hauptsächlich von einer Person entwickelt
		Vorteil: gut strukturierter Quelltext
		Nachteil: langsame Weiterentwicklung im Gegensatz zu den verglichenen Systemen
	- Support auf Mailingliste (diese ist jedoch nur schwach frequentiert)
	- kaum zusätzliches Material
	- an vielen Stellen auf Erweiterung ausgelegt
	- Quelltextrecherche war notwendig (Transaktionsverwaltung / Caching)

OrientDB
	- Dokumentation sehr eingeschränkt und inkonsistent mit aktuellem Entwicklungsstand
	- Zugriffsmechanismen im Graphenmodell: widersprüchliche Dokumentation, wenig Beispiele
	- viel Quelltextrecherche (Transaktionsverwaltung, Persistenz- und Cacheverwaltung)
	- Aktivität und Support auf Mailingliste	

Titan
	- gute Doku für junges Projekt (fehlende Dokumentation der Persistenzverwaltung)
	- Quelltextrecherche
	- durch Wiederverwendung existierender Lösungen -> Konzentration auf graphenorientierte Verarbeitung
	- bei Fragen Support auf Mailingliste

\renewcommand{\arraystretch}{1.25}
\begin{table}[h]
	\centering
	\begin{footnotesize}
   	\begin{tabular}{|m{3.1cm}|>{\centering}m{2.8cm}|>{\centering}m{2.8cm}|>{\centering}m{3.1cm}|>{\centering\arraybackslash}m{3cm}|}
	\hline
	\textbf{GDBMS} & \textbf{Neo4j} & \textbf{HyperGraphDB} & \textbf{OrientDB} & \textbf{Titan} \\   
   	\hline
   	\multicolumn{5}{|c|}{\textbf{Allgemeines}} \\
	\hline
   	\textbf{Hersteller} & Neo Technology & Kobrix Software & Orient Technologies & Aurelius \\
    \textbf{Lizenz} & GPLv3 & LGPL & Apache 2.0 & Apache 2.0 \\
    \textbf{Version (Jahr)} & 2.0.0-M04 (2013) & 1.2 (2012) & 1.5.1 (2013) & 0.3.2 (2013) \\
    \textbf{Sprache} & Java, Scala & Java & Java & Java \\
    \hline
    \multicolumn{5}{|c|}{\textbf{Kategorisierung}} \\
    \hline
    \textbf{Verarbeitung} & nativ & nativ & nativ & nativ \\
    \textbf{Speicherung} & nativ & je nach Speichersystem & nativ & je nach Speichersystem \\
    \textbf{Eingebettet} & \checkmark & \checkmark & \checkmark & \checkmark \\
    \textbf{Client-Server} & \checkmark & - & \checkmark & \checkmark \\
    \textbf{Disk-zentriert} & \checkmark & je nach Speichersystem & \checkmark & je nach Speichersystem \\
    \textbf{Hauptspeicher-zentriert} & - & - & - & - \\ 
   % \textbf{Datenbanken} & eine & eine & mehrere & eine \\
   \hline
   	\end{tabular} 
	\end{footnotesize}
	\setlength{\belowcaptionskip}{0.25cm}	
	\caption[Zusammenfassung: Allgemeines und Kategorisierung]{Allgemeines und Kategorisierung.}
	\label{tab:zusammenfassung_dokumenation}
\end{table}
\renewcommand{\arraystretch}{1} 

\paragraph*{Datenmodell}

Tabelle \ref{tab:zusammenfassung_datenmodell} stellt die GDBMS hinsichtlich ihres Datenmodells gegenüber.

% Tabelle
- Neo4j: PGM
	+ Knotenlabel (mehrere)
	- keine Objekteinbettung
	- keine Schemadefinition für Attribute
	- viel Verantwortung wird an die Anwendung übergeben
- HyperGraphDB: 
	+ Atom-Modell sehr generisch, für den Anwendungsfall jedoch nicht zwingend erforderlich
	+ Schema durch Klassendefinition
	+ umfangreiches Typsystem
	- keine Updates, Änderungen durch Werteaustausch
	- kein direkter Zugriff auf Nachbarschaft
	- komplizierte Definition der Semantik der Position in Zielmenge
- OrientDB:
	+ Multi-Modell-Ansatz (Dokumentenmodell als Basis)
	- Versuch, mehrere Ansätze zu kombinieren	
	- Deserialisierung erscheint ineffizient (evtl. Verweise auf ältere Benchmarks)	
	- Dokumentmodell als Basis
	- PGM auf Dokumente abgebildet 
	- Schema durch Klassendefinition
- Titan: PGM + TitanKey + TitanLabel
	+ Definition von TitanKey und TitanLabel zur Optimierung der Speicherung (Performance)
	+ erlaubt mehrfache Verwendung von Attributschlüsseln an Knoten / Kante
	+ Einschränkung der Kardinalität von Beziehungen
	- keine Schemadefinition an Knoten und Kanten
	- Einschränkung der Attribute
	- Einschränkung der Kanten
	- Einschränkung Datentypen
	- verschachtelte Attributwerte (Maps)
	- Vertex-centric Indices
	- unidirektionale Kanten

\renewcommand{\arraystretch}{1.25}
\begin{table}[h]
	\centering
	\begin{footnotesize}
   	\begin{tabular}{|m{3.1cm}|>{\centering}m{2.8cm}|>{\centering}m{2.8cm}|>{\centering}m{3.1cm}|>{\centering\arraybackslash}m{3cm}|}
	\hline
	\textbf{GDBMS} & \textbf{Neo4j} & \textbf{HyperGraphDB} & \textbf{OrientDB} & \textbf{Titan} \\   
    \hline
    \multicolumn{5}{|c|}{\textbf{Datenmodell}} \\
    \hline
    \textbf{Datenmodell} & PGM & PHGM & PGM & PGM \\
    \textbf{Typsystem} & - & \checkmark (Klassen) & \checkmark (Klassen) & \checkmark (Attributschlüssel, Kantenbezeichner) \\
	\textbf{Knotenbezeichner} & \checkmark  (optional) & \checkmark & \checkmark & - \\
	\textbf{Kantenbezeichner} & \checkmark & \checkmark  (optional) & \checkmark & \checkmark \\
	\textbf{Attributschema} & - & \checkmark & \checkmark (optional) & - \\
	\textbf{dynamische Schemaänderung} & - & \checkmark (Werteaustausch) & \checkmark & - \\
	\textbf{attributbezogene Integritätsbedingungen} & \texttt{UNIQUE} & Datentyp, \texttt{UNIQUE} & Datentyp, Wertebereich (explizit), \texttt{UNIQUE} & Datentyp, \texttt{UNIQUE} \\
	\textbf{referentielle Integrität} & \checkmark & \checkmark & \checkmark & \checkmark \\
	\textbf{Vererbung} & - & \checkmark & \checkmark & - \\
	\textbf{Besonderheiten} & mehrere Knotenbezeichner & n-äre Relationen höherer Ordnung, offene Architektur & Multi-Datenmodell & lokal eindeutige Attributschlüssel \& Kantenbezeichner \\
   	\hline
   	\end{tabular} 
	\end{footnotesize}
	\setlength{\belowcaptionskip}{0.25cm}	
	\caption[Zusammenfassung: Datenmodell]{Gegenüberstellung Datenmodell.}
	\label{tab:zusammenfassung_datenmodell}
\end{table}
\renewcommand{\arraystretch}{1}

\paragraph*{Zugriffsmechanismen}

Eingebetteter Zugriff:
	- in allen Systemen möglich
Entfernter Zugriff:
	- in allen Systemen außer HyperGraphDB möglich

CRUD-Operationen:
	- in allen GDBMS möglich
	- dabei Einschränkung der Ergebnismenge durch Angabe von Schlüssel-Wert-Paaren
Traversierung:
	- Neo4j:
		- algorithmische Traversierung mittels Traversal Framework
			- umfangreiche Möglichkeiten zur Beeinflussung (Richtung, mehrfache Betrachtung, Filter- und Abbruchkriterien, Heuristiken)
			- Verwendung von Java für Entscheidungslogik -> mächtig
		- alternative Definition abstrakter Wege in Cypher inkl. Einschränkung
		- beide: Pfadinstanzen als Ergebnis möglich
	- HyperGraphDB
		- algorithmische Traversierung mittels Traversal Framework -> Java
		- Prädikatdefinition erlaubt Einschränkung der Traversierung
		- hoher manueller Aufwand (z.B. keine Pfadinstanzen)
	- OrientDB und Titan
		- algorithmische Traversierung durch knoten-zentrierte Anfragen		
		- vorrangig Nutzung von Gremlin -> Programmiersprache, mächtig
	- OrientDB
		- OrientDB-SQL graphenorientierte Verwendung sehr schlecht dokumentiert
		- Ausrichtung auf dokumentenorientierten Betrieb

Erreichbarkeit
	- Neo4j:
		- native API stellt Algorithmen zur Verfügung
			- erlauben Einschränkungen von Kantenbezeichnern
		- Unterstützung von Blueprints
		- Cypher bietet shortestPath allShortestPath-Funktionen an
		- Weg der Länge $k$ führt zu $\mathcal{O}(\left|N(v_1)\right| \times \left|N(v_2)\right| \times \cdots \times \left|N(v_k)\right|)$
	- HyperGraphDB
		- durch Traversierung umsetzbar
		- Dijkstra-Implementierung
	- OrientDB und Titan
		- durch Traversierung umsetzbar
		- Blueprints Algorithmen
			- keine Einschränkungen möglich
	- OrientDB
		- Bugs z.B. falsche Ergebnisse beim Traversieren, expand(shortestPath) und expand(dijkstra)  haben keinen Effekt
		- Ergebnisse zwischen Tiefen- und Breitensuche unterscheiden sich durch Verhindern des wiederholten Zugriffs (link zur Mailing-Liste)
Mustersuche
	- Neo4j:
		- Cypher ermöglicht durch die Kombination abstrakter Wege die Definition beliebiger Mustergraphen
		- Einschränkung der abstrakten Wege
		- deklarativ -> intuitives Formulieren möglich (nah am Datenmodell)
		- Wiederverwendung von Ergebnissen durch Verkettung von Operationen		
	- HyperGraphDB
	 	- keine native Unterstützung
		- einfache Muster durch entsprechende Prädikatverknüpfungen
	- OrientDB
		- keine native Unterstützung
		- evtl. durch Schachtelung von SELECT und TRAVERSE
		- kaum dokumentiert
		- OrientDB-SQL eher für dokumentenzentierten, mengenorientierten Zugriff
	- Titan
		- Musterdefinition via Gremlin und table-Funktion
		- weniger elegant als Cypher (= komplexer)
		
Aggregation und Summierung

- Summierung wird von keinem GDBMS unterstützt
- Aggregation
	- Neo4j:
		- Aggregation und Gruppierung
			- Gruppierung auf Basis von Attributwerten
			- großer Funktionsumfang zur Berechnung von Aggregaten und Manipulation der Ergebnismenge
	- HyperGraphDB
		- Aggregation 
			- muss innerhalb der Anwendung erfolgen -> (hg.apply)
	- OrientDB
		- Aggregation ja
	- Titan
		- Aggregation ja
Metriken
	- einfache Metriken wie Anzahl Knoten / Kanten
	- Neo4j: Berechnung aller kürzesten Pfade als Grundlage für komplexere Metriken

\renewcommand{\arraystretch}{1.25}
\begin{table}[h]
	\centering
	\begin{footnotesize}
   	\begin{tabular}{|m{3cm}|>{\centering}m{2.9cm}|>{\centering}m{2.9cm}|>{\centering}m{2.9cm}|>{\centering\arraybackslash}m{2.9cm}|}
	\hline	
   	 \textbf{GDBMS} & \textbf{Neo4j} & \textbf{HyperGraphDB (BerkeleyDB)} & \textbf{OrientDB} & \textbf{Titan (BerkeleyDB)} \\   
   	\hline
   	\multicolumn{5}{|c|}{\textbf{Zugriffsmechanismen}} \\
	\hline
   	\textbf{Java API} & \checkmark & \checkmark & \checkmark & \checkmark \\
   	\textbf{Traversal API} & \checkmark & \checkmark & \checkmark & \checkmark \\
   	\textbf{Anfragesprachen} & Cypher, Gremlin & Prädikate\newline~(Java API) & OrientDB-SQL, Gremlin & Gremlin \\
   	\hline
	\multicolumn{5}{|c|}{\textbf{Operationen}} \\
   	\hline
   	\textbf{CRUD} & \checkmark & \checkmark & \checkmark & \checkmark \\
   	\textbf{Mengenorientiert} & \checkmark & \checkmark & \checkmark & \checkmark \\
   	\textbf{Traversierung} & \checkmark & \checkmark & \checkmark & \checkmark \\
   	\textbf{Mustersuche} & \checkmark & - & \checkmark & \checkmark \\
   	\textbf{Aggregation} & \checkmark & - & \checkmark & \checkmark \\
   	\textbf{Gruppierung} & \checkmark & - & \checkmark & \checkmark \\
   	\textbf{Summierung} & - & - & - & - \\
   	\textbf{Metriken} & (\checkmark) & - & (\checkmark) & (\checkmark) \\
   	\hline
	\multicolumn{5}{|c|}{\textbf{Verfügbare Algorithmen}} \\   	
   	\hline
   	\textbf{Algorithmen\newline~(nativ)} & Dijkstra, A*, BFS, DFS & Dijkstra & - & - \\
   	\textbf{Algorithmen\newline~(Blueprints)} & Bellman-Ford & - & Dijkstra, Bellman-Ford, A*, BFS, DFS & Dijkstra, Bellman-Ford, A*, BFS, DFS \\
   	\hline
   	\end{tabular} 
	\end{footnotesize}
	\setlength{\belowcaptionskip}{0.25cm}	
	\caption[Zusammenfassung: Zugriffsmechanismen]{Gegenüberstellung Zugriffsmechanismen.}
	\label{tab:zusammenfassung_zugriffsmechanismen}
\end{table}
\renewcommand{\arraystretch}{1}

\paragraph*{Transaktions- und Indexverwaltung}

Transaktionen
	- generell: Optimierung für Leseoperationen / Konflikte werden an Anwendung weitergegeben (OrientDB und Titan)
	- Neo4j
		- ist ACID konform bietet jedoch gegenüber den anderen GDBMS eine
		- geringe Isolationsebene
		- wie auch beim Datenmodell liegt die Verantwortung bei der Anwendung wenn höhere Ebene erreicht werden soll
	- HyperGraphDB: ACI(D), MVCC (GDBMS) + Locking (BerkeleyDB), SERIALIZABLE
	- OrientDB: ACID, MVCC, SERIALIZABLE
	- Titan: ACID, Locking (BerkeleyDB), SERIALIZABLE (BerkeleyDB)
	
Indexverwaltung
- Primär- und Sekundärindizes generell möglich
- Indizes werden automatisch aktualisiert
- bis auf OrientDB wird eine Erweiterung um eigene Indexstrukturen dokumentiert
- Neo4j und Titan mit Unterstützung komplexer Indizierungsmechanismen durch Apache Lucene bzw. Elastic Search

\renewcommand{\arraystretch}{1.25}
\begin{table}[h]
	\centering
	\begin{footnotesize}
   	\begin{tabular}{|m{3cm}|>{\centering}m{2.9cm}|>{\centering}m{2.9cm}|>{\centering}m{2.9cm}|>{\centering\arraybackslash}m{2.9cm}|}
	\hline	
   	 \textbf{GDBMS} & \textbf{Neo4j} & \textbf{HyperGraphDB (BerkeleyDB)} & \textbf{OrientDB} & \textbf{Titan (BerkeleyDB)} \\   
   	\hline
	\multicolumn{5}{|c|}{\textbf{Transaktionen}} \\   	
   	\hline
   	\textbf{ACID-Eigenschaften} & ACID & ACI(D) & ACID & ACID \\
   	\textbf{Isolationsebene} & \texttt{READ COMMITTED} & \texttt{SERIALIZABLE} & \texttt{SERIALIZABLE} & \texttt{REPEATABLE READ} \\
   	\textbf{Synchronisations-verfahren\newline~(Storage)} & RX-Sperrverfahren & RX-Sperrverfahren & MVCC & RX-Sperrverfahren \\
   	\textbf{Schachtelung} & ja, kein isoliertes Rücksetzen & ja, isoliertes Rücksetzen & nein & ja, keine Isolation \\
   	\hline
	\multicolumn{5}{|c|}{\textbf{Indexverwaltung}} \\   	
   	\hline
	\textbf{Primärindex} & \checkmark & \checkmark & \checkmark & \checkmark \\
	\textbf{Sekundärindex} & \checkmark & \checkmark & \checkmark & \checkmark \\
	\textbf{Aktualisierung} & automatisch & automatisch & automatisch & automatisch \\
	\textbf{Externe Indexstrukturen} & Apache Lucene, Neo4j Spatial & - & - & Elastic Search, Apache Lucene \\
	\textbf{Besonderheiten} & - & - & - & Knoten-zentrierte Indizes \\
   	\hline
   	\end{tabular} 
	\end{footnotesize}
	\setlength{\belowcaptionskip}{0.25cm}	
	\caption[Zusammenfassung: Transaktions- und Indexverwaltung]{Gegenüberstellung Transaktions- und Indexverwaltung.}
	\label{tab:zusammenfassung_transaktion}
\end{table}
\renewcommand{\arraystretch}{1}

\paragraph*{Persistenz- und Cacheverwaltung, Verteilung}

% Persistenzverwaltung

- Neo4j: nativ
	- Trennung von Topologie und Daten sowie die effiziente Berechnung physischer Positionen in Folge der festen Satzlänge von Knoten und  Kanten versprechen hohe Performance beim Traversieren des Graphen	
	- Fragmentierung der Stores durch Löschen einzelner Einträge
	- logisch benachbarte Knoten sind nicht zwingend physisch benachbart

- HyperGraphDB: nicht-nativ
	- Trennung von Topologie und Daten, Typsystem jedoch auch in Topologie abgebildet
	- Speicherung in KV-Store
	- Traversierung: O(logn)
- OrientDB: nativ
	- keine Trennung von Topologie und Daten 
	- Traversierung: O(N\_v)
	- Fragmentierung der Stores
	- attributierte Kanten sind zusätzliche Indirektion\url{https://github.com/orientechnologies/orientdb/wiki/Performance-Tuning-Blueprints} -> können sich negativ auf die Performance beim Traversieren auswirken
- Titan: nicht-nativ
	- keine Trennung von Topologie und Daten
	- Speicherung in KV-Store 
	- Traversierung O(logn)
	- Ein Vorteil gegenüber OrientDB und HyperGraphDB, ist die Möglichkeit des direkten Zugriffes auf Attribute und inzidente Kanten eines Knotens unter Angabe der Knoten-Identität und der geforderten 
	Column.
	- Caching und langlaufende Änderungstransaktionen

% Cacheverwaltung
	
- generell: Beschleunigung der Zugriffe auf häufig benötige Objekte via Caches
	- Hashtabellen  O(1) (wenn da)

% Verteilung
- alle außer HyperGraphDB bieten die Möglichkeit zur Replikation 
	-> Ausfallsicherheit, Skalierbarkeit Lesezugriffe
	-> Single-Master, Multi-Master schränken Skalierbarkeit von Schreibzugriffen ein
	- Cassandra ermöglicht besseren, flexibleren Kompromiss aus Performance und Ausfallsicherheit
- Partitionierung nur in Titan möglich
	- bisherige Nutzung der zufälligen Zuordnung -> Weiterentwicklung bereits angekündgt

\renewcommand{\arraystretch}{1.25}
\begin{table}[h]
	\centering
	\begin{footnotesize}
   	\begin{tabular}{|m{3cm}|>{\centering}m{2.9cm}|>{\centering}m{2.9cm}|>{\centering}m{2.9cm}|>{\centering\arraybackslash}m{2.9cm}|}
	\hline
   	 \textbf{GDBMS} & \textbf{Neo4j} & \textbf{HyperGraphDB} & \textbf{OrientDB} & \textbf{Titan} \\   
 	\hline
 	\multicolumn{5}{|c|}{\textbf{Persistenzverwaltung}} \\
	\hline
	\textbf{Realisierung} & Store-Konzept & Key-Value-Modell & Dokument-Modell & Key-Column-Value-Modell \\
	\textbf{Trennung Topologie, Nutzdaten} & \checkmark & \checkmark & - & - \\
	\textbf{Satzlänge} & fest & variabel & variabel & variabel \\
	\textbf{Zeitkomplexität Zugriff Nachbarschaft} & konstant & logarithmisch (BerkeleyDB) & konstant & logarithmisch (BerkeleyDB), konstant (Cassandra)\\
	\hline
	\multicolumn{5}{|c|}{\textbf{Cacheverwaltung}} \\
	\hline
	\textbf{Caches} & Memory Mapped Files, Filesystem-Cache (LFU), Objekt-Cache (Schwache Referenzen) & Atomcache (LRU), Inzidenzcache (LRU) & Memory Mapped Files, L2 Cache (FIFO), L1 Cache (Schwache Referenzen) & Transaktionscache \\
	\hline
	\multicolumn{5}{|c|}{\textbf{Verteilung}} \\
	\hline
	\textbf{Architektur} & Master-Slave (nur Enterprise Edition) & Peer-To-Peer Message Framework & Master-Master & Peer-to-Peer (Cassandra) \\
	\textbf{Replikation} & \checkmark & - & \checkmark & \checkmark \\
	\textbf{Partitionierung} & - & - & - & \checkmark \\
	\textbf{Skalierbarkeit Lesen} & horizontal & - & horizontal & horizontal \\
	\textbf{Skalierbarkeit Schreiben} & vertikal & - & vertikal & horizontal \\
	\textbf{Skalierbarkeit Datenvolumen} & vertikal & - & vertikal & horizontal \\
   	\hline
  	\end{tabular} 
	\end{footnotesize}
	\setlength{\belowcaptionskip}{0.25cm}	
	\caption[Zusammenfassung: Persistenz- und Cacheverwaltung, Verteilung]{Gegenüberstellung Persistenz- und Cacheverwaltung, Verteilung.}
	\label{tab:zusammenfassung_persistenz}
\end{table}
\renewcommand{\arraystretch}{1}

Unter Berücksichtigung der vorgestellten Ergebnisse werden Neo4j und Titan im letzten Kapitel der Arbeit in einem Benchmark untersucht um die Leistungsfähigkeit der Systeme abschließend beurteilen zu können. Insbesondere soll dabei auch untersucht werden, inwieweit eine native Speicherung des Graphen vorteilhaft ist oder ob die Nutzung bestehender Systeme eine gleichwertige Alternative darstellt.