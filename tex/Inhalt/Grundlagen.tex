\chapter{Theoretische Grundlagen}
\label{cha:theory}

Das folgende Kapitel behandelt die theoretischen Grundlagen der Arbeit. Es werden zunächst die verwendeten graphentheoretischen Begriffe definiert. Anschließend werden verschiedene Netzwerkarten kurz vorgestellt. Der Fokus des Kapitels liegt auf der Abgrenzung von Graphdatenbanksystemen zu anderen graphenbasierten Softwaresystemen. Die letzten zwei Abschnitte beschreiben die in aktuellen Graphdatenbanksystemen eingesetzten Datenmodelle und die damit verbundenen graphenspezifischen Operationen zur Verarbeitung von Netzwerken.

\section{Graphentheoretische Begriffe}
\label{sec:graph_theory}

Ein Graph besteht in seiner grundlegenden Form aus einer Menge von Knoten, welche durch Kanten verbunden sein können. In der Graphentheorie und den darauf aufbauenden Anwendungen werden je nach Anforderung verschiedene Arten von Graphen eingesetzt. Nachfolgend werden diejenigen von ihnen definiert, die für die Arbeit relevant sind. Wenn nicht anders gekennzeichnet, beziehen sich alle Definitionen auf \cite{DBLP:books/daglib/0030488}.

% ungerichteter Graph
\paragraph*{Ungerichteter Graph} Ein ungerichteter Graph (engl. \textit{undirected} oder \textit{simple graph}, Abbildung \ref{fig:undirected_graph}) ist ein Tupel $G=(V,E)$ und besteht aus einer Menge $V$ von \textit{Knoten} (engl. \textit{vertices})  und einer Menge $E=\{\{u,v\}\ \vert\ u,v \in V \wedge u \neq v\}$ von \textit{Kanten} (engl. \textit{edges}). Die Anzahl der Knoten ist $n=\left|V\right|$, die Anzahl der Kanten ist $m=\left|E\right|$.

% gerichteter Graph
\paragraph*{Gerichteter Graph} Ein gerichteter Graph (engl. \textit{directed graph}, Abbildung \ref{fig:directed_graph}) ist ein Tupel $G=(V,E)$ und besteht aus einer Menge $V$ von Knoten und einer Menge $E=\{(u,v)\ \vert\ u,v \in V \wedge u \neq v\}$ von \textit{gerichteten} Kanten. Für jede Kante $e \in E$ mit $e = (u,v)$ gilt: $u$ ist der \textit{Startknoten}, $v$ der \textit{Zielknoten} von $e$. 
% Eine alternative Notation für eine Kante $(u,v)$ lautet $e_{u,v}$.
Die Menge der Kanten, deren Start- oder Zielknoten $v$ ist, sind die zu $v$ \textit{inzidenten} Kanten. Zwei Kanten sind \textit{adjazent}, wenn sie einen gemeinsamen Start- bzw. Zielknoten besitzen.

\begin{figure}[h]
	\centering	
	\subfigure[Ungerichteter Graph]{\label{fig:undirected_graph}\includegraphics{undirected_graph.pdf}}\qquad	
	\subfigure[Gerichteter Graph]{\label{fig:directed_graph}\includegraphics{directed_graph.pdf}}	
	\caption[Beispiel: Gerichteter und ungerichteter Graph]{Gerichteter und ungerichteter Graph mit $n = m = 5$.}
\end{figure}

% gewichteter Graph

\paragraph*{Gewichteter Graph} Ein gewichteter Graph (engl. \textit{weighted graph}, Abbildung \ref{fig:weighted_graph}) ist ein Tupel $G = (V,E,\omega_v,\omega_e)$. Er zeichnet sich durch die Möglichkeit aus, Gewichte an Knoten und Kanten zu definieren. Hierfür werden die Abbildungen $\omega_v: V \rightarrow \mathbb{R}$ und $\omega_e: E \rightarrow \mathbb{R}$ verwendet.

% bezeichneter Graph
\paragraph*{Bezeichneter Graph} Ein bezeichneter Graph (engl. \textit{labeled graph}, Abbildung \ref{fig:labeled_graph}) $G=(V,E,\Sigma_{V_L},\Sigma_{E_L},\sigma_v,\sigma_e)$ ergänzt Knoten- und Kantenmenge durch das Alphabet der Knotenbezeichner $\Sigma_{V_L}$, das Alphabet der Kantenbezeichner $\Sigma_{E_L}$ sowie die Abbildungen $\sigma_v: V \rightarrow \Sigma_{V_L}$ und $\sigma_e:E \rightarrow \Sigma_{E_L}$.

\begin{figure}[htb]
	\centering	
	\subfigure[Gerichteter, kantengewichteter Graph]{\label{fig:weighted_graph}\includegraphics[scale=1.3]{weighted_graph.pdf}}\qquad	
	\subfigure[Gerichteter, bezeichneter Graph mit $\Sigma_{V_L} = \{1,2,3,4,5\}$ und $\Sigma_{E_L} = \{a,b,c,d,e\}$]{\label{fig:labeled_graph}\includegraphics[scale=1.3]{labeled_graph.pdf}}	
	\caption[Beispiel: Gewichteter und bezeichneter Graph]{Gewichteter und bezeichneter Graph.}
\end{figure}

% attributierter Graph
\paragraph*{Attributierter Graph} Ein attributierter Graph (engl. \textit{attributed graph}, Abbildung \ref{fig:attributed_graph}) verfügt über die Möglichkeit, Knoten und Kanten mit zusätzlichen Informationen in Form von Schlüssel-Wert-Paaren zu versehen. Der Graph wird durch das Tupel \linebreak $G=(V,E,\Sigma_{V_A}, \Sigma_{E_A}, \gamma_V, \gamma_E, A)$ definiert, wobei $\Sigma_{V_A}$ das Alphabet aller möglichen Schlüssel für Knoteneigenschaften und $\Sigma_{E_A}$ jenes für alle Schlüssel der Kanteneigenschaften bildet. $A$ ist die Menge der Eigenschaftswerte für Knoten und Kanten. Die Abbildung $\gamma_v: \Sigma_{V_A} \times V \rightarrow \mathcal P(A)$ ordnet die Knotenschlüssel ihren entsprechenden Werten oder Wertemengen zu, gleiches gilt für Kanten unter Verwendung der Abbildung $\gamma_e: \Sigma_{E_A} \times E \rightarrow \mathcal P(A)$.

% Multigraph
\paragraph*{Multigraph} Ein Multigraph (Abbildung \ref{fig:multigraph}) ist ein Graph $G=(V,E)$, in dem die Menge aller Kanten $E$ eine Multimenge ist. Diese weist die Eigenschaft auf, dass einzelne Elemente mehrfach enthalten sein können. Somit ist die Definition beliebig vieler Kanten zwischen zwei Knoten möglich. Zwei gerichtete Kanten gelten als \textit{parallel}, wenn sie den gleichen Start- und Zielknoten aufweisen.

\begin{figure}[htb]
	\centering	
	\subfigure[Knotenattributierter, gerichteter Graph mit $\Sigma_{V_A} = \{a,b\}$ und $A = \{1,2,3,4,5,h,o,d,r\}$]{\label{fig:attributed_graph}\includegraphics[scale=1.5]{attributes_graph.pdf}}\qquad	
	\subfigure[Gerichteter, kantenbezeichneter Multigraph]{\label{fig:multigraph}\includegraphics[scale=1.5]{multigraph.pdf}}	
	\caption[Beispiel: Attributierter Graph und Multigraph]{Attributierter Graph und Multigraph.}	
\end{figure}

Bei der Betrachtung der verschiedenen Graph-Typen wird deutlich, dass diese sich nicht zwingend gegenseitig ausschließen. Die Kanten in einem Multigraphen können zum Beispiel gerichtet und bezeichnet sein. Darüber hinaus lassen sich bezeichnete Graphen mit Hilfe von attributierten Graphen abbilden. Neben den verschiedenen Arten von Graphen sind in der vorliegenden Arbeit weitere graphentheoretische Konzepte relevant, welche im Folgenden definiert werden. Alle Definitionen beziehen sich auf gerichtete Graphen.

\paragraph*{Teilgraph, Obergraph} Ein Graph $G'=(V',E')$ heißt Teilgraph oder Subgraph von einem Graph $G=(V, E)$, wenn $V' \subseteq V$ und $E' \subseteq E$. $G$ ist der Obergraph von $G'$. Der Teilgraph $G'$ ist \textit{induziert}, wenn er alle Kanten $(x,y) \in E$ mit $x,y \in V'$ enthält.

\paragraph*{Nachbarschaft} Zwei Knoten $u,v \in V$, die durch eine Kante $e = (u,v)$ verbunden sind, heißen \textit{adjazent} oder benachbart in $G$. Die Nachbarschaft $N(v)$ eines Knotens $v$ ist die Menge aller adjazenten Knoten von $v$: 
\begin{equation}
	N(v) := \{u \mid (u,v) \in E \vee (v,u) \in E\}.
\end{equation}

\paragraph*{Außen- und Innengrad, Grad}  Der Außengrad $d^+(v)$ eines Knotens $v \in V$ ist die Anzahl der Kanten in $E$, deren Startknoten $v$ ist. Der Innengrad $d^-(v)$ von $v$ ist die Anzahl der in $v$ endenden Kanten. Der Grad $deg(v)$ eines Knotens $v \in V$ ist die Summe aus Außengrad und Innengrad für diesen Knoten. Somit gilt in gerichteten Graphen:
\begin{equation}
	deg(v) := d^+(v)+d^-(v) = \left|N(v)\right|.
\end{equation}
In gewichteten Graphen werden bei der Berechnung des Grades die einzelnen Kantengewichte berücksichtigt.
\begin{equation}
	deg(v) := \sum_{e \in N(v)}\omega_e(e) 
\end{equation}

\paragraph*{Weg, Kantenfolge, Pfad, Kreis} Ein Weg ist eine Sequenz $v_1,e_1,v_2,e_2,...,v_{k-1},e_{k-1},v_k$ von Knoten und Kanten eines Graphen $G$. Die \textit{Länge} des Weges ist die Anzahl der Kanten innerhalb der Sequenz. Ein Weg ist eine Kantenfolge in $G$, wenn jede Kante höchstens einmal in dieser Folge auftritt. Gilt $v_1 = v_k$, so bezeichnet man diese Folge als \textit{geschlossen}, andernfalls handelt es sich um eine \textit{offene} Kantenfolge. Eine Kantenfolge ist ein Pfad, wenn alle Knoten innerhalb der Folge voneinander verschieden sind. Kommt mit Ausnahme von $v_k$ kein Knoten doppelt in der geschlossenen Kantenfolge vor, bezeichnet man diese als einfachen Kreis. Ein Graph, der einen Kreis enthält, ist ein zyklischer Graph.

\paragraph*{Abstand} Der Abstand $dist(u,v)$ von zwei Knoten $u,v \in V$ ist die Länge des kürzesten Pfades von $u$ nach $v$. Existiert kein solcher Weg, so gilt $dist(u,v) = \infty$.

\section{Arten von Netzwerken}
\label{sec:nwarten}

Netzwerk ist ein allgemeiner Oberbegriff für die Beschreibung von Beziehungen zwischen Objekten. Art und Verteilung der Beziehungen definieren dabei ein Muster, anhand dessen sich Aussagen über das Netzwerk treffen lassen. Objekte und deren Beziehungen werden mittels Knoten und Kanten modelliert und durch graphentheoretische Algorithmen analysiert. Im Folgenden werden vier verschiedene Arten von Netzwerken nach Newman\cite{Newman:2010:NI:1809753} vorgestellt.

\textbf{Technologische Netzwerke} bilden physische Infrastrukturen ab. Einer der bekanntesten Vertreter ist das Internet. Hier ist das Finden effizienter Routen, auf deren Grundlage Datenpakete zwischen Knoten weitergeleitet werden, eine der wesentlichen Aufgaben. Transportnetzwerke zählen ebenfalls zu den technologischen Netzwerken. Orte werden als Knoten und die Verbindungen zwischen ihnen als Kanten modelliert. Eine typische Anwendung ist auch hier das Ermitteln von Routen zwischen zwei oder mehreren Orten. Dabei ist nicht immer ausschließlich der geographisch kürzeste Weg von Interesse, vielmehr spielen zusätzliche Einschränkungen, wie die Kombination verschiedener Transportmittel und das Meiden bestimmter Knoten (z.B. von Großstädten) eine Rolle.

In \textbf{sozialen Netzwerken} stehen die Knoten für Personen, Gruppen oder Ereignisse, die Kanten beschreiben Beziehungen zwischen ihnen. Diese Beziehungen können sehr vielfältig sein, typische Beispiele sind Freundschaft, berufliche Beziehung oder Gruppenmitgliedschaft. Prominente Beispiele sind Netzwerke, wie sie im World Wide Web zu finden sind. Hierzu zählen zum Beispiel Facebook\footnote{\url{http://www.facebook.com}} oder LinkedIn\footnote{\url{http://www.linkedin.com/}}. Aber auch reale soziale Netzwerke, wie zum Beispiel in Schulen oder Firmen, werden dieser Kategorie zugeordnet. Der Bereich der Social Network Analysis\cite{INSNA_web} (SNA) befasst sich mit dem Aufdecken und Analysieren von Interaktionsmustern innerhalb solcher Netzwerke. Dabei ist neben der Struktur von Organisationen und sozialen Gruppen auch die Evolution der Netzwerke von Interesse. Firmen nutzen beispielsweise Ausbreitungseigenschaften von Informationen für virales Marketing, auch die Verbreitungswege von Krankheiten lassen sich auf dieser Grundlage untersuchen. Des Weiteren können Empfehlungen für neue Kontakte oder Gruppen ausgesprochen werden. Dies erfolgt auf Basis des zurückliegenden Nutzerverhaltens oder der aktuellen Netzwerkstruktur in der unmittelbaren Umgebung eines Knotens.

Eine weitere Kategorie bildet die Gruppe der \textbf{biologischen Netzwerke}. In vielen Bereichen der Biologie werden Netzwerke eingesetzt um das Verhalten bestimmter Elemente abzubilden. Molekularbiologen nutzen Netzwerke um chemische Reaktionen in Zellen darzustellen, Neurowissenschaftler modellieren die Verbindungen von Hirnzellen. Eine weitere Anwendung ist die Repräsentation des Verhaltens verschiedener Spezies in Ökosystemen. 

Die vierte und für die vorliegende Arbeit relevante Kategorie bilden die \textbf{Informations- oder Wissensnetzwerke}, oft auch als semantische Netzwerke bezeichnet. Objekte sind dabei Informationen in Form von Begriffen oder konkreten Daten, welche miteinander verknüpft sind. Die Beziehungen werden dabei möglichst explizit definiert\cite{semantische_netze:2010}, lassen sich aber auch aus bestehenden Beziehungen ableiten. Bestes Beispiel für ein Wissensnetzwerk ist das World Wide Web. Hierbei werden Webpräsenzen als Knoten und Hyperlinks als Kanten modelliert. Kanten sind gerichtet, da eine Verbindung von Webpräsenz A zu Webpräsenz B nicht zwingend eine Verbindung von B nach A voraussetzt. Eine Wichtung der Knoten ist vorstellbar in Abhängigkeit des Innengrades, welcher hierbei die Anzahl der eingehenden Hyperlinks auf eine Website repräsentiert. Diese Information wird u.a. im Pagerank\cite{Brin:1998:ALH:297805.297827} Algorithmus von Google zur Wichtung von Suchergebnissen verwendet. Eng verbunden mit dem World Wide Web ist das Semantic Web\cite{SEMWEB:2013}. Schwerpunkt ist hierbei die maschinenlesbare Repräsentation von Beziehungen zwischen beliebigen Ressourcen.\\
Ein weiteres Informationsnetzwerk, welches auch im Rahmen aktueller Forschungen in der Abteilung Datenbanken der Universität Leipzig untersucht wird, sind Beziehungen innerhalb von Geschäftsdaten aus Geschäftsinformationssystemen. In diesen werden Stammdaten, wie zum Beispiel Mitarbeiter oder Produkte, mit transaktionalen Daten, wie zum Beispiel Rechnungen, Aufträgen und Buchungen, verknüpft. Die Instanzen der jeweiligen Datenart sind Knoten im Graphen, die Verknüpfungen zwischen ihnen lassen sich durch bezeichnete Kanten ausdrücken. Betrachtet man Teile dieses Graphen als Instanz eines Geschäftsprozesses, so kann untersucht werden, worin sich Teilgraphen erfolgreicher\footnote{Ein Prozess ist zum Beispiel genau dann erfolgreich, wenn die Summe der Einnahmen innerhalb des Prozesses die Prozesskosten überschreitet.} Prozesse von denen nicht erfolgreicher Prozesse unterscheiden. Eine detaillierte Beschreibung des Anwendungsfalls erfolgt in Abschnitt \ref{sec:anforderungen}.

\section{Klassifikation graphenbasierter Softwaresysteme}
\label{sec:graphsystems_classification}

Aus dem vorherigen Abschnitt geht hervor, dass Graphen für eine Vielzahl verschiedener Anwendungen eine Rolle spielen. Daraus folgt, dass auch an die Konzeption und Implementierung dedizierter Softwaresysteme unterschiedliche Anforderungen gestellt werden. Nachfolgend werden die drei Kategorien graphenbasierter Softwaresysteme beschrieben. Die Kategorisierung gründet sich auf die Ausführungen in \cite{Buerli:2012}, \cite{robinson2013graph} und \cite{Shao:2012:MML:2213836.2213907} sowie eigene Überlegungen im Rahmen der Arbeit.

\subsection{Graphdatenbanksysteme}
\label{subsec:gdbms}

Kemper und Eickler definieren in \cite{kemper2006datenbanksysteme} ein Datenbankverwaltungssystem (engl. \textit{database management system}, DBMS) wie folgt:

\begin{quote}
\textit{Die Gesamtheit aller Programme zum Zugriff auf die Datenbasis, zur Kontrolle der Konsistenz und zur Modifikation der Daten wird als Datenbankverwaltungssystem bezeichnet.}
\end{quote}

Unter einer \textit{Datenbasis} versteht man die gespeicherten Daten in Form von miteinander in Beziehung stehenden Informationseinheiten. 

Angles definiert in \cite{Angles:2008} ein Graphdatenbankmodell wie folgt:

\begin{quote}
\textit{Ein Graphdatenbankmodell ist ein Modell, in welchem die Datenstrukturen für Schema und/oder Instanzen direkt als Graph modelliert sind. Datenmanipulation erfolgt durch graphenorientierte Operationen und Typkonstruktoren, Integritätsbedingungen können auf der Graphstruktur definiert werden.}
\end{quote}

Ein Datenbankverwaltungssystem, welches ein Graphdatenbankmodell implementiert, wird im Rahmen dieser Arbeit als \textbf{Graphdatenbankverwaltungssystem} (engl. \textit{graph database management system}, GDBMS) bezeichnet. Eine \textit{Graphdatenbank} ist die Instanz eines Graphen und stellt somit die vom GDBMS verwaltete Datenbasis dar. 
%Der von Angles verwendete Begriff der Datenstruktur wird allgemeiner als \textit{Datenmodell} bezeichnet (Abschnitt \ref{sec:datamodels}). 
Nachfolgend werden die Begriffe Graphdatenbanksystem und Graphdatenbankverwaltungssystem im Text synonym verwendet.

Graphdatenbanksysteme sind generell für den Einsatz als OLTP-System (engl. \textit{Online Transaction Processing}) konzipiert\cite{robinson2013graph}. Der Schwerpunkt liegt somit auf Mehrbenutzerfähigkeit, transaktionaler Performance, Integrität und Verfügbarkeit. GDBMS eignen sich vorrangig für die Ausführung lokaler Operationen, diese betrachten nur einen Teil des Graphen, wie zum Beispiel die Umgebung eines definierten Knotens oder einer Knotenmenge.

Festzuhalten ist, dass sich ein GDBMS über drei wesentliche Aufgaben definiert:
\begin{enumerate}
	\item Bereitstellen von Informationen als Instanz eines graphenspezifischen Datenmodells
	\item Bereitstellen von Operationen zur Definition, Manipulation und Abfrage einer Instanz des Datenmodells
	\item Sicherstellen der Widerspruchsfreiheit innerhalb der Datenbasis
\end{enumerate}

Ausgehend von dieser allgemeinen Definition lassen sich die vorhandenen Systeme weiter unterteilen. Nachfolgend werden die im Rahmen der Arbeit relevanten Ausprägungen von GDBMS erläutert.

\paragraph*{Native versus nicht-native GDBMS}

Als native GDBMS bezeichnet man jene Systeme, in denen sowohl die Verarbeitung als auch die Speicherung der Datenbasis graphenorientiert erfolgt\cite{robinson2013graph}. Im Sinne der Verarbeitung spielt hierbei das Konzept der \textit{indexfreien Adjazenz}\cite{DBLP:journals/corr/abs-1004-1001} eine entscheidende Rolle. Zum Verständis soll kurz die Modellierung von Netzwerken im relationalen Datenmodell\cite{Codd:1970:RMD:362384.362685} skizziert werden. In RDBMS werden Beziehungen zwischen Objekten durch Fremdschlüsselattribute und im Fall von $n:m$ Beziehungen durch zusätzliche Tabellen (engl. \textit{mapping tables}) abgebildet. Im Zuge der Normalisierung entsteht eine große Anzahl von Tabellen, welche über Fremdschlüsselbeziehungen miteinander verbunden sind. Für die Verwaltung stark vernetzter Daten weist dieses Modell einen entscheidenden Nachteil auf: Im Falle einer Selektion müssen die Tabellen unter der Verwendung von Verbundoperationen (sog. JOIN-Operationen) wieder zusammengeführt werden, um die angeforderte Teilmenge zu extrahieren. Relationale Datenbanken begegnen diesem Problem mittels Anfrageoptimierung, dem Einsatz von Cachingstrategien oder der Verwendung von Indizes auf Fremdschlüsselattributen\cite{DBLP:books/sp/HarderR01}. Der Aufwand, einen Index nach einem bestimmten Schlüssel zu durchsuchen steht meist in einem logarithmischen Verhältnis zur Anzahl der hinterlegten Einträge. Der Aufwand vervielfacht sich, wenn mehrere JOIN-Operationen rekursiv hintereinander ausgeführt werden müssen.\\
Native GDBMS hingegen bilden die Daten in ihrer expliziten Struktur ab, Beziehungen zwischen Objekten werden durch Kanten modelliert und als physische Referenz direkt am Objekt abgelegt. Der geringe Aufwand, die Nachbarschaft eines Knotens zur Laufzeit abzufragen, ist der entscheidende Vorteil, den diese Struktur aufweist. Während bei einer JOIN-Operation typischerweise ein Index in die Berechnung einbezogen wird, ist die Komplexität dieser Operation in einem nativen GDBMS nur vom aktuellen Knotengrad abhängig. Somit bleibt sie unabhängig von der Größe des Graphen konstant. Die Kanten innerhalb des Graphen können als materialisiertes Ergebnis einer JOIN-Operation verstanden werden. Gegenüber einem relationalen DBMS verspricht dieser Ansatz insbesondere bei rekursiven Anfragen großer Tiefe, wie zum Beispiel der Pfadsuche, einen entscheidenden Geschwindigkeitsvorteil.

Die Möglichkeit zur nativen Verarbeitung ist eng verknüpft mit der Repräsentation des Graphen im Hauptspeicher und auf Externspeichern. Eine hohe Performance rekursiver Anfragen kann nur erreicht werden, wenn der direkte Zugriff auf die Nachbarschaft eines Knotens auch physisch effizient möglich ist. Native GDBMS speichern den Graphen in einem Format, dass für rekursive Operationen optimiert ist. In \cite{Shao:2012:MML:2213836.2213907} wird diskutiert, dass es keine Repräsentation des Graphen geben kann, welche für alle vorstellbaren Graphalgorithmen optimal ist, da Zugriffe innerhalb des Graphen grundsätzlich wahlfrei sind. Ungeachtet dessen existieren verschiedene Datenformate zur effizienten Verarbeitung des Graphen, diese sind jedoch nur hinsichtlich bestimmter Operationen optimiert.

Nicht-native GDBMS sind jene Systeme, welche die Modellierung der Daten als Graph unterstützen, für die Verarbeitung und Speicherung jedoch auf andere Technologien zurückgreifen. Dazu zählen zum Beispiel relationale und objektorientierte Datenbanken aber auch dedizierte Persistenzframeworks\cite{robinson2013graph}. Nicht-native GDBMS weisen den Vorteil auf, dass viele der zugrundeliegenden Systeme durch eine lange Entwicklungsdauer und den oft mehrjährigen Einsatz als Produktivsystem eine hohe Stabilität aufweisen und deren Funktionsweise umfassend dokumentiert ist. Nicht-native Verarbeitung weist bei traversierenden Anfragen Leistungsdefizite auf, dafür können andere Anfragen, wie zum Beispiel mengenorientierte, von einer entsprechend optimierten Verarbeitung profitieren.

\paragraph*{Zentrale versus verteilte GDBMS} 

Ein weitere Differenzierung von GDBMS ist die klassische Einteilung in zentrale und verteilte Systeme. Zentrale GDBMS werden auf einem einzelnen, zentralen Rechner ausgeführt. Steigenden bzw. generell hohen Anforderungen hinsichtlich Anfragelast und verwalteter Datenmenge kann in diesen Systemen durch \textit{vertikale Skalierung} (engl. \textit{scale up}) begegnet werden\cite{DBLP:journals/corr/cs-AR-9912010}. Hierbei wird durch das Ändern der Hardwarekonfiguration, wie zum Beispiel dem Hinzufügen mehrerer, leistungsfähigerer Prozessoren oder größerer Mengen an Hauptspeicher, die Leistung des Systems gesteigert. Die maximale Leistungsfähigkeit ist damit durch die technische Entwicklung im Bereich der Hardware und durch die Wirtschaftlichkeit der eingesetzten Ressourcen limitiert.

Ein Weg, der Forderung nach hoher Leistungsfähigkeit zu begegnen, ist der Einsatz verteilter GDBMS. Diese zeichnen sich dadurch aus, dass Instanzen eines konkreten GDBMS auf mehreren Rechnern parallel ausgeführt werden. Für die Beantwortung von Anfragen und die Verwaltung der Datenbasis kooperieren die einzelnen Instanzen. Eine Steigerung der Leistungsfähigkeit wird durch das Hinzufügen zusätzlicher Rechner oder Instanzen erreicht. Dieses Vorgehen wird als \textit{horizontale Skalierung} (engl. \textit{scale out}) bezeichnet\cite{DBLP:journals/corr/cs-AR-9912010}. Ziel dabei ist eine lineare Steigerung der Leistungsfähigkeit in Abhängigkeit zur Anzahl der hinzugefügten Rechner\cite{rahm1994mehrrechner}. 
%Die für die vorliegende Arbeit relevanten GDBMS implementieren eine \textit{shared-nothing}-Architektur, diese zeichnet sich durch einen lose gekoppelten Rechnerverbund aus, in dem jedem beteiligten Rechner eigene Hardware-Ressourcen zur Verfügung stehen\cite{rahm1994mehrrechner}.

Bei der Aufteilung der Datenbasis in verteilten Systemen unterscheidet man zwei Techniken: \textit{Replikation} und \textit{Partitionierung}. Im Rahmen einer vollständigen Replikation wird die gesamte Datenbasis an allen beteiligten Rechnern redundant hinterlegt. Dies erhöht die Verfügbarkeit des Gesamtsystems und ermöglicht das horizontale Skalieren lesender Zugriffe. Vollständige Replikation weist den Nachteil auf, dass die Datenmenge durch die Kapazität der einzelnen Rechner limitiert ist.\\
Die Partitionierung teilt die Datenbasis in mehrere Fragmente auf, diese werden den beteiligten Rechnern zugewiesen. Die Folgen sind eine horizontale Skalierbarkeit schreibender Zugriffe und eine theoretisch unbeschränkte Größe der Datenbasis. Mit dem Ziel, beide Zugriffsarten skalieren und gleichzeitig Verfügbarkeit sicherstellen zu können, werden die Fragmente im Rahmen der partiellen Replikation redundant gespeichert\cite{rahm1994mehrrechner}.

\paragraph*{Eingebettete versus Client-Server GDBMS}

Viele der aktuell verfügbaren GDBMS können als eingebettete Datenbanksysteme verwendet werden. Die Einbettung erfolgt in Form spezieller Softwarebibliotheken innerhalb des Anwendungsprogramms, die Funktionen des GDBMS können über herstellerspezifische APIs in Anspruch genommen werden. Eingebettete Datenbanksysteme eignen sich insbesondere für den Einsatz in speziellen Geräten oder eigenständigen Desktopanwendungen. Das Anwendungsprogramm übernimmt die Verantwortung über das GDBMS, eine manuelle Installation oder Aktualisierung ist nicht erforderlich. Ein wesentlicher Vorteil der eingebetteten Verwendung ist die geringe Latenz beim Aufruf von Datenbankfunktionen. Ein möglicher Nachteil ist die Bindung an den Prozess des Anwendungsprogramms, mit welchem sich das GDBMS Ressourcen, wie zum Beispiel den verfügbaren Hauptspeicher, teilen muss. Ein weiterer Nachteil ist die Einschränkung in der Wahl der Programmiersprache, da die Softwarebibliotheken typischerweise nur in der Programmiersprache des jeweiligen GDBMS zur Verfügung stehen.

Neben der Einbettung in das Anwendungsprogramm bieten viele GDBMS-Hersteller auch die Verwendung eines eigenständigen Datenbankservers an. Generell werden Datenbanksysteme häufig als Client-Server-Systeme realisiert\cite{vossen2008datenmodelle}. Ein Client sendet eine Anfrage an einen Server, dieser bearbeitet die Anfrage und sendet eine Antwort an den Client zurück. Client- und Serverprozess sind entkoppelt, was zur Folge hat, dass mehrere Clients gleichzeitig mit dem Server kommunizieren können. Die Kommunikation erfolgt auf Basis der Protokolle des jeweiligen Datenbanksystems. Viele Graphdatenbanksysteme nutzen standardisierte Protokolle für die Kommunikation zwischen Client und Server. Infolgedessen ist die Verwendung des GDBMS grundsätzlich unabhängig von Plattform und Programmiersprache. Ein Nachteil der Client-Server-Architektur ist die höhere Latenz durch den zusätzlichen Kommunikationsaufwand. Darüber hinaus zieht der Einsatz eines Datenbankservers auch entsprechende administrative Aufgaben nach sich.

\paragraph*{Disk- versus hauptspeicher-zentrierte GDBMS}

Ein weiteres wichtiges Unterscheidungsmerkmal zwischen GDBMS-Implementierungen ist die Wahl des primären Speichermediums für die hinterlegten Daten. Generell wird in disk-zentrierte (engl. \textit{disk resident}) und hauptspeicher-zentrierte (engl. \textit{main memory based} oder \textit{in-memory}) DBMS unterschieden\cite{Garcia-Molina:1992:MMD:627289.627538}.

Disk-zentrierte DBMS stellen die klassische Form eines Datenbanksystems dar. Ihre Entwicklung erfolgte unter der Vorgabe, dass die gesamte Datenbasis auf mechanischen Festplatten hinterlegt und einzelne Fragmente bei Bedarf zur Verarbeitung in den Hauptspeicher geladen werden. Die Zugriffszeiten des Hauptspeichers sind wesentlich kürzer als die von Festplatten. Ein wahlfreier Zugriff auf die Informationen im Hauptspeicher ist demnach effizienter als das wahlfreie Lesen von Daten auf den rotierenden Magnetscheiben einer Festplatte. DBMS-Hersteller begegneten diesem Problem mit sequentieller, an der Blockstruktur der Festplatten orientierten Datenspeicherung und dem Einsatz großer Datenbankpuffer mit entsprechenden Ersetzungsverfahren\cite{DBLP:books/sp/HarderR01}.

Hauptspeicher-zentrierte DBMS verwalten die gesamte Datenbasis innerhalb des physischen Hauptspeichers. Die eingesetzten Algorithmen und Datenstrukturen sind auf die Kommunikation zwischen Hauptspeicher, Prozessor-Caches und CPU-Registern optimiert. Durch die geringen Zugriffszeiten wird weniger die sequentielle Anordnung der Daten priorisiert, vielmehr wird versucht, durch Komprimierung mehr Daten im Hauptspeicher verwalten zu können\cite{plattner2011memory}. Hauptspeicher-zentrierte Verarbeitung ist nicht gleichbedeutend mit der Verwendung großer Puffer, welche den gesamten Datenbestand eines disk-zentrierten Systems aufnehmen können. Der Puffer stellt eine zusätzliche Indirektion im Zugriff dar, Adressen müssen übersetzt, das Vorhandensein des entsprechenden Blocks im Puffer geprüft und das angeforderte Tupel letztendlich ausgelesen werden. Diese Schritte entfallen bei einer hauptspeicher-zentrierten Verarbeitung.

Ein wesentlicher Nachteil des Hauptspeichers ist dessen Flüchtigkeit. Wird die Stromversorgung unterbrochen, sind die hinterlegten Informationen verloren. Die Systeme nutzen zwar den Hauptspeicher als primäres Speichermedium, setzen jedoch häufig Externspeicher für Backups ein. Insbesondere die Verwendung von Solid-State-Disks (SSD) bietet hier wesentliche Performance-Vorteile gegenüber mechanischen Festplatten. 
%Durch die Wirtschaftlichkeit großer Mengen an Hauptspeicher erlangen In-Memory-DBMS zunehmend an Bedeutung. 
Wie bereits erwähnt, erfolgt der Zugriff innerhalb des Graphen grundsätzlich wahlfrei. Infolgedessen stellen hauptspeicher-zentrierte Implementierungen vor allem im Bereich der GDBMS eine interessante Alternative dar.

Die vorgestellten Ausprägungen von Graphdatenbanksystemen schließen sich nicht zwingend gegenseitig aus, Kombinationen der einzelnen Arten sind möglich. So ist es vorstellbar, dass ein hauptspeicher-zentriertes GDBMS als Client-Server-System eingesetzt wird oder native GDBMS in Desktopanwendungen eingebettet sind.

\subsection{Graph Processing Systems}
\label{subsec:graph_processing}

Eine zweite Art graphenbasierter Softwaresysteme sind diejenigen, welche sich mit der verteilten Analyse umfangreicher Graphen befassen. Sie werden als Graph Processing Systems (GPS) oder alternativ auch als Graph Compute Systems bezeichnet\cite{Malewicz:2010:PSL:1807167.1807184, robinson2013graph}. Ein umfangreicher Graph weist die Eigenschaft auf, dass seine Knoten- und Kantenmenge nicht mehr effizient auf einer einzelnen Maschine verarbeitet werden kann.

Anders als Graphdatenbanksysteme eignen sich GPS für Berechnungen, welche den gesamten Graphen berücksichtigen. Ein Beispiel hierfür ist der Page-Rank-Algorithmus\cite{Brin:1998:ALH:297805.297827} von Google, welcher jeder Website einen globalen Rang auf Basis ihrer Nachbarschaft und weiteren Faktoren zuweist. Bei der Analyse sozialer Netzwerke ist zum Beispiel die Berechnung der Zentralität eines Knotens interessant: Für jedes mögliche Nutzerpaar werden die kürzesten Pfade bestimmt um anschließend den Anteil jener Pfade zu berechnen, welche durch einen konkreten dritten Nutzer verlaufen.

Eine weitere Eigenschaft dieser Systeme ist die batch-orientierte Datenverarbeitung. Die Daten werden von einer externen Quelle geladen, auf mehrere Rechner verteilt, verarbeitet und das Ergebnis der Verarbeitung ausgegeben oder aber in einer nachfolgenden Berechnung weiterverwendet. Dies ist ein wesentlicher Unterschied zur Definition eines operationalen Graphdatenbanksystems, welches die Datenbasis selbst verwaltet, den interaktiven Zugriff ermöglicht und Konsistenz sicherstellt. Durch die batch-orientierte Verarbeitung können GPS eher mit OLAP-Systemen (engl. \textit{online analytical processing}) verglichen werden.

GPS werden im Rahmen dieser Arbeit nicht betrachtet, da ihr Einsatzzweck nicht zu den gestellten Anforderungen passt. Hierzu zählen u.a. der interaktive Zugriff und der lokale Bezug von Anfragen. Bekannte GPS-Vertreter sind die quelloffenen Projekte Apache Giraph\footnote{\url{http://giraph.apache.org/}} und Phoebus\footnote{\url{https://github.com/xslogic/phoebus}}. Beide Systeme implementieren das von Google vorgestellte Pregel-Modell\cite{Malewicz:2010:PSL:1807167.1807184}, welches unter anderem für die Berechnung des Page-Rank-Algorithmus eingesetzt wird und im Gegensatz zu anderen Systemen Ausfälle von Rechnern während der Verarbeitung toleriert. MapReduce\cite{Dean:2008:MSD:1327452.1327492} ist ebenfalls ein verteiltes Berechnungsmodell für große Datenmengen. Apache Hadoop\footnote{\url{http://hadoop.apache.org/}} ist eine bekannte Implementierung des Modells und wird im Rahmen des Pegasus-Projektes\footnote{\url{http://www.cs.cmu.edu/~pegasus/}} für die Berechnung von Graphalgorithmen auf umfangreichen Graphen eingesetzt.

\subsection{Software zur Analyse und Visualisierung}

Die dritte Kategorie graphenbasierter Softwaresysteme bilden unterstützende Werkzeuge zur Analyse und bzw. oder Visualisierung von Graphen. Es handelt sich um zentral ausführbare oder als Softwarebibliothek verwendbare Programme. Die Größe der unterstützten Graphen ist durch die zur Verfügung stehende Menge an Hauptspeicher begrenzt. Die Systeme selbst bieten keine Unterstützung für eine automatische Datenverwaltung, Mehrbenutzerfähigkeit oder Konsistenzerhaltung an. Der analytische Funktionsumfang variiert je nach System, so werden typischerweise die Berechnung globaler Eigenschaften, wie zum Beispiel die Dichte\footnote{Die Dichte eines Graphen beschreibt das Verhältnis zwischen der Anzahl von Kanten und der maximal möglichen Anzahl von Kanten\cite{DBLP:books/daglib/0030488}.} des Graphen, der durchschnittliche Grad oder die Anzahl maximal zusammenhängender Teilgraphen\footnote{Ein Graph ist zusammenhängend, wenn alle möglichen Knotenpaare innerhalb des Graphen durch einen Weg verbunden sind\cite{DBLP:books/daglib/0030488}.} genauso unterstützt wie lokale Operationen. Letztere umfassen zum Beispiel das Berechnen kürzester Pfade oder maximaler Flüsse.

Die Visualisierung von Graphen stellt ebenfalls ein wichtiges Forschungsgebiet dar\cite{kaufmann2001drawing}. Die grafische Aufbereitung komplexer Netzwerke kann dem Endanwender das Verständnis erleichtern und auch neue Erkenntnisse über Eigenschaften oder Besonderheiten des Graphen ermöglichen. Verschiedene Layout-Algorithmen werden in den jeweiligen Systemen implementiert, um je nach Topologie des Graphen die optimale Visualisierung wählen zu können. Einige der Systeme stellen Erweiterungen für die Kommunikation mit GDBMS zur Verfügung, wodurch die im Datenbanksystem hinterlegten Daten visualisiert werden können.

Die dritte Kategorie graphenbasierter Softwaresysteme wird im Rahmen der vorliegenden Arbeit nicht betrachtet, da die Systeme für die dauerhafte Datenverwaltung ungeeignet sind. Beispiele für Softwaresysteme zur Analyse und Visualisierung sind JUNG\footnote{\url{http://jung.sourceforge.net/}}, GraphViz\footnote{\url{http://www.graphviz.org/}} und Gephi\footnote{\url{https://gephi.org/}}.

\section{Datenmodelle in GDBMS}
\label{sec:datamodels}

Datenbankmanagementsysteme implementieren ein Datenmodell, welches die Modellierungskonstrukte festlegt, mittels derer ein Informationsabbild der realen Welt generiert werden kann. Ein Datenbankmodell ist somit eine Form der Abstraktion und bietet die Möglichkeit zur Modellierung von Datenobjekten und zur Festlegung der anwendbaren Operatoren und deren Wirkung\cite{elmasri2009grundlagen, kemper2006datenbanksysteme}. Die in GDBMS häufig eingesetzten Datenmodelle sind das Property-Graph-Modell und das Hypergraph-Modell. Im Bereich des Semantic Web findet das Resource Description Framework zur Modellierung von Graphen Anwendung.

\subsection{Property-Graph-Modell}
\label{subsec:propgraph}

Das Property-Graph-Modell (PGM) ist ein gerichteter, kantenbezeichneter, attributierter Multigraph\cite{DBLP:journals/corr/abs-1006-2361, DBLP:journals/corr/abs-1004-1001}. Formal betrachtet lässt sich dieser als ein Tupel in der Form \linebreak$G = (V,E,\Sigma_{E_L}, \Sigma_{V_A}, \Sigma_{E_A}, A, \sigma_e, \gamma_v, \gamma_e)$ definieren. $\Sigma_{E_L}$ beschreibt das Alphabet der Kantenbezeichner, dessen Symbole durch die Abbildung $\sigma_e:E \rightarrow \Sigma_{E_L}$ den Kanten zugeordnet werden. $\Sigma_{V_A}$ bzw. $\Sigma_{V_E}$ bilden die Schlüsselalphabete, $A$ die Wertemenge für Knoten- bzw. Kantenattribute. Die Abbildungen $\gamma_v: \Sigma_{V_A} \times V \rightarrow \mathcal P(A)$ und $\gamma_e: \Sigma_{V_E} \times E \rightarrow \mathcal P(A)$ ordnen die Knotenschlüssel ihren entsprechenden Werten oder Wertemengen zu. 

Großer Vorteil des PGM ist dessen Flexibilität hinsichtlich der Abbildung verschiedener Arten von Graphen\cite{DBLP:journals/corr/abs-1006-2361}. Neben der grundlegenden ungerichteten Form ohne zusätzliche Eigenschaften, lässt sich jede Kombination aus gerichteten, gewichteten und attributierten Graphen und Multigraphen darstellen. Das Modell eignet sich somit zur Repräsentation einer Vielzahl der im vorhergehenden Abschnitt vorgestellten Netzwerke.

Das Modell sieht keine strenge Typisierung von Knoten und Kanten vor, d.h. deren Attribute sind grundsätzlich nicht durch ein Schema festgelegt und können damit beliebig auf Instanzebene vergeben werden. Es handelt sich demnach um ein semistrukturiertes Modell, da keine explizite Unterscheidung zwischen Strukturinformationen und Daten vorgenommen wird, sondern vielmehr jede Instanz eines Knotens bzw. einer Kante die jeweiligen Informationen in sich vereint. Der sich daraus ergebende Vorteil ist die hohe Flexibilität zum Einen gegenüber der Schemaevolution an Knoten und Kanten innerhalb des Modells und zum Anderen im Datenaustausch zwischen verschieden modellierten Datenquellen. In diversen Anwendungen kann es jedoch sinnvoll sein, den Typ eines Knotens zu modellieren. Auf logischer Ebene erlaubt dies eine semantisch eindeutige Beschreibung der einzelnen Instanzen, auf physischer Ebene die Definition von Indizes und Konsistenzkriterien oder die Berücksichtigung des Typen im Rahmen der Anfrageoptimierung\cite{EdlichFriedlandHampeBrauer201010}. Eine Möglichkeit der Realisierung ist der Einsatz dedizierter Attributschlüssel, wie zum Beispiel \texttt{Type}. Die Zuständigkeit für Definition und Einhaltung eines Schemas liegt in diesem Fall bei der Anwendung. Einige GDBMS bieten die Möglichkeit Knoten- und Kantentypen zu definieren und übernehmen somit ihrerseits die Verantwortung für die Einhaltung anwendungsspezifischer und modellinhärenter Integritätsbedingungen.

Abbildung \ref{fig:propertygraph} zeigt am Beispiel eines sozialen Netzwerkes die Instanz eines Property-Graphen. Personen stehen miteinander über Freundschaften in Beziehung, studieren an Hochschulen oder sind Mitglied in Vereinen, die wiederum von Hochschulen betreut werden. Knotenattribute werden in der Form \texttt{Schlüssel : Wert} dargestellt. Die Knotentypen Hochschule, Person und Verein sind farblich voneinander abgehoben, der jeweilige Typ wird durch den Attributschlüssel \texttt{Type} definiert. Das Beispiel verzichtet auf Kantenattribute, vorstellbar wären aber zum Beispiel die Rolle einer Person in einem Verein oder Datumsangaben, welche den Erstellungszeitpunkt der Beziehung dokumentieren.

\begin{figure}[htb] 
	\centering
		\includegraphics{PropertyGraph.pdf}
	\caption[Beispiel: Property-Graph]{Beispiel eines Property-Graphen mit den drei Knotentypen Hochschule, Verein und Person, welche über verschiedene Kantentypen in Relation miteinander stehen.}
	\label{fig:propertygraph}
\end{figure}

Bis auf wenige Ausnahmen wird das Property-Graph-Modell in nahezu allen kommerziell verfügbaren GDBMS eingesetzt\cite{EdlichFriedlandHampeBrauer201010}. Teilweise wird das Modell modifiziert, ein Beispiel hierfür sind explizite Knotenbezeichner in Neo4j 2.0\cite{Neo4j_web_labels:2013}.

\subsection{Hypergraph-Modell}
\label{subsec:hgm}

Die zu Beginn des Kapitels betrachteten Graphen-Definitionen sowie das PGM erlauben ausschließlich binäre Beziehungen zwischen Objekten, d.h. eine Kante verbindet genau zwei Knoten. Es existieren jedoch Anwendungsgebiete, in denen die Modellierung von n-ären Beziehungen von Interesse ist. Ein Beispiel hierfür ist die Wissensrepräsentation, welche unter anderem in den Bereichen künstliche Intelligenz, Bioinformatik und Computerlinguistik eingesetzt wird\cite{Iordanov:2010:HGG:1927585.1927589}. Grundsätzlich lassen sich n-äre Beziehungen durch mehrere binäre Relationen ausdrücken. Dies erhöht jedoch die Komplexität und Fehleranfälligkeit der Repräsentation und verringert gleichzeitig deren Verständlichkeit und Übersichtlichkeit. In Hypergraphen wird von dieser Komplexität abstrahiert, indem mehrere binäre Relationen in Hyperkanten zusammengefasst werden.

Das Hypergraph-Modell (HGM) beschreibt einen Hypergraph $H=(V,E)$ bestehend aus einer Menge $V=\{v_1,v_2,\ldots,v_n\}$ von Knoten und einer Menge $E = \{E_1,E_2,\ldots E_m\} = \mathcal P(V) \setminus \emptyset$ von Hyperkanten, wobei $E_i \subseteq V$ für $i=1,\ldots,m$. Eine gerichtete Hyperkante ist ein geordnetes Paar $E = (A,B)$ mit $A,B \subseteq V$ und $A \cap B = \emptyset$. Ein gerichteter Hypergraph besteht aus gerichteten Hyperkanten\cite{Gallo:1993:DHA:153578.153586}.

\begin{figure}[htb] 
	\centering
		\includegraphics{PropertyHyperGraph.pdf}
	\caption[Beispiel: Property-Hypergraph]{Beispiel eines Property-Hypergraphen mit zwei gerichteten Hyperkanten $\texttt{Studenten} = (\{\texttt{Eve}, \texttt{Bob}\}, \{\texttt{FH Jena}\})$ und $\texttt{Mitglieder} = (\{\texttt{Alice}, \texttt{Bob}\}, \{\texttt{Schach}\})$.}
	\label{fig:propertyhypergraph}
\end{figure}

Abbildung \ref{fig:propertyhypergraph} greift das Beispiel des sozialen Netzwerkes erneut auf. Die binären Relationen \texttt{studiert an} und \texttt{mitglied von} werden zu den gerichteten Hyperkanten \texttt{Studenten} und \texttt{Mitglieder} zusammengefasst. Knoten, Kanten und Hyperkanten können auch in Hypergraphen mit Attributen und Bezeichnern versehen werden. Ein Property-Graph-Modell mit der Möglichkeit, n-äre Beziehungen zu definieren, wird als Property-Hypergraph-Modell (PHGM) bezeichnet und weist die gleichen Eigenschaften bezüglich Strukturiertheit bzw. Typisierung wie das PGM auf.

Im Vergleich zum PGM ist das HGM in kommerziellen GDBMS wenig verbreitet. Ein Vertreter ist das Graphdatenbanksystem HyperGraphDB, welches das HGM um ein flexibles Typsystem und die Möglichkeit Hyperkanten auf Hyperkanten zeigen zu lassen erweitert\cite{Iordanov:2010:HGG:1927585.1927589}.

\subsection{Resource Description Framework}
\label{subsec:rdf}

Das Resource Description Framework\cite{RDF:2013} (RDF) ist ein vom World Wide Web Consortium (W3C) standardisiertes Datenmodell für die Formulierung und den Austausch von Aussagen über beliebige Dinge, welche innerhalb des Modells als Ressourcen bezeichnet werden. RDF wurde im Umfeld des Semantic Web\cite{SEMWEB:2013} entwickelt, dieses widmet sich der semantischen Auszeichnung von Informationen und deren maschineller Interpretation und Verarbeitung.

Eine Aussage ist als ein Tripel bestehend aus Subjekt, Prädikat und Objekt definiert. Das Subjekt ist die zu beschreibende Ressource, das Prädikat definiert eine Eigenschaft des Subjektes und das Objekt den Wert dieser Eigenschaft. Prädikate sind ebenfalls Ressourcen, Objekte können entweder Ressource oder Literal sein. Eine Menge von Aussagen zu einem Subjekt bildet somit dessen Beschreibung. Eine Ressource wird durch einen Uniform Resource Identifier (URI) eindeutig identifiziert. Für die automatisierte maschinelle Verarbeitung ist diese Eindeutigkeit obligatorisch, da sie Mehrdeutigkeiten und folglich Fehlinterpretationen verhindert\cite{DBLP:journals/dlib/Miller98}. 

Aus mathematischer Sicht betrachtet ist das RDF-Modell ein gerichteter, bezeichneter Multigraph. Ein wesentlicher Unterschied zum PGM besteht darin, dass Knoten- und Kanteneigenschaften durch dedizierte Tripel modelliert werden müssen. Eine modellinhärente Differenzierung in eine Beziehung zwischen Ressourcen und einer Beschreibung einer einzelnen Ressource ist dabei nicht gegeben. Das Modell erfordert keine strenge Typisierung und eignet sich somit genau wie PGM und HGM für die Speicherung semistrukturierter Daten. Abbildung \ref{fig:rdfgraph} zeigt dies am Beispiel eines sozialen Netzwerkes.

\begin{figure}[htb] 
	\centering
		\includegraphics{RDFGraph.pdf}
	\caption[Beispiel: RDF-Instanz]{Instanz eines RDF-Modells am Beispiel eines sozialen Netzwerkes. Gezeigt werden die Ressourcen Alice  und Bob, welche durch die entsprechenden Wikipedia-URIs eindeutig bestimmt sind. Ihre Beziehung wird durch das Prädikat \texttt{foaf:knows} beschrieben. Beide Ressourcen sind vom Typ \texttt{foaf:Person}. Die Beziehungen selbst sind ebenfalls Ressourcen, Friend-of-a-friend (\texttt{foaf}) repräsentiert den Namensraum \texttt{http://xmlns.com/foaf/spec/}, das Prefix \texttt{rdf} den Namensraum \texttt{http://www.w3.org/1999/02/22-rdf-syntax-ns\#}. Die Beschreibung von Alice und Bob wird durch deren Beziehungen zu den Literalen \texttt{Alice} und \texttt{42} bzw. \texttt{Bob} und \texttt{23} ergänzt.}
	\label{fig:rdfgraph}
\end{figure}

Für die Manipulation und den Zugriff auf Daten im RDF-Modell wird die graphenbasierte Anfragesprache SPARQL\cite{SPARQL:2013} entwickelt und eingesetzt. Deren grundlegender Ansatz ist die Definition eines Teilgraphen als Muster, nach welchem die Datenbasis durchsucht wird. Innerhalb des Musters können Variablen definiert werden, diese werden während der Anfrageverarbeitung instanziiert. Wird das Muster in der Datenbasis gefunden, besteht die Ergebnismenge aus den definierten Variablen und deren Belegung.

Einer der Schwerpunkte des Semantic Web ist das Ableiten neuer Beziehungen zwischen Ressourcen auf der Basis vorhandener Informationen und zusätzlich definierter Regeln. Dieses Vorgehen wird auch als Inferenz bezeichnet\cite{Inference:2013}. Ein zweiter Schwerpunkt ist das Konzept des Linked Data\cite{linked_data:2013}. Es beschreibt, wie eigenständige Datenquellen im Web virtuell zusammengeführt und quellenübergreifende Beziehungen zwischen den Ressourcen definiert werden. Mit Hilfe dieser umfassenden,  virtuell integrierten Datenbasis können komplexe Anfragen beantwortet und neue Informationen abgeleitet werden.

Für die Speicherung von RDF-Daten werden entweder spezielle Datenbanksysteme, sog. Triple-Stores, eingesetzt oder aber bestehende Datenbanksysteme, wie zum Beispiel \linebreak RDBMS, mit entsprechender Funktionalität erweitert. Beide Systemarten unterstützen nicht die im vorhergehenden Abschnitt definierte indexfreie Adjazenz und zählen somit zu den nicht-nativen GDBMS\cite{robinson2013graph}. Die Systeme selbst bieten SPARQL-Endpunkte an, über welche auf die hinterlegte Datenbasis zugegriffen werden kann.

Das RDF-Modell und SPARQL gehören zu den grundlegenden Komponenten des Semantic Web. Wie bereits erwähnt, sind die wesentlichen Einsatzszenarien das Ableiten neuer Beziehungen und das virtuelle Integrieren von Daten aus verschiedenen Quellen. Diese Szenarien sind jedoch nicht wesentlich für die vorliegende Arbeit. Aus technischer Sicht sind RDF-Datenbanksysteme für das schnelle Auffinden statischer Muster innerhalb der Datenbasis optimiert\cite{de2013choosing}. Insbesondere für die Analyse von Netzwerken ist jedoch das dynamische Traversieren von Graphen relevant. Hierfür eignen sich RDF-Datenbanksysteme weniger als native GDBMS, welche das PGM implementieren und für das Traversieren von Graphen optimiert sind\cite{robinson2013graph}.\\
Eine weiteres Defizit für den in der Arbeit gewählten Anwendungsfall steht im Zusammenhang mit SPARQL, die Sprache ermöglicht das Traversieren nur in eingeschränkter Form. Sie bietet zwar mit dem Konzept der Property Paths\cite{prop_paths:2013} eine Möglichkeit Pfade und Wege zu finden, dafür ist es jedoch erforderlich, diese ebenfalls in Form eines Musters zu definieren. Durch diese Einschränkung kann die Existenz beliebiger, unbekannter Wege geprüft, deren Instanzen allerdings nicht als Ergebnis einer Anfrage zur Verfügung gestellt werden. Dies ist insbesondere dann notwendig, wenn die Instanzen in einer weiterführenden Analyse verwendet werden sollen. Aus den genannten Gründen werden RDF-Datenbanksysteme in dieser Arbeit nicht betrachtet.

\section{Graphenspezifische Operationen}
\label{sec:operations}

Wie bereits in Abschnitt \ref{subsec:gdbms} definiert, ist das Bereitstellen von Operationen zur Definition, Manipulation und Abfrage einer Instanz des Graph-Datenmodells eine der Hauptaufgaben eines GDBMS. Nachfolgend werden grundlegende und die für die Analyse von Netzwerken geeigneten Operationen kurz beschrieben. Deren Unterstützung und konkrete Umsetzung in GDBMS-Implementierungen ist Bestandteil der sich anschließenden Evaluation.

\subsection{Grundlegende Operationen}

\paragraph*{CRUD} Zu den grundlegenden Operationen eines GDBMS gehören das Erzeugen, Lesen, Aktualisieren und Löschen (engl. \textit{Create, Read, Update, Delete}, CRUD) von Knoten- und Kanteninstanzen. Sie ermöglichen sowohl die Definition und Manipulation der Datenbasis als auch den atomaren Zugriff auf die hinterlegten Elemente. Je nach Art des Datenmodells können Knoten- und Kantenbezeichner bzw. -attribute in Form von Prädikaten in die Operation einbezogen werden. Analog zur relationalen Algebra lässt sich dadurch die Menge der von einer Operationen betroffenen Instanzen einschränken\cite{kemper2006datenbanksysteme}. In attributierten Graphen beziehen sich CRUD-Operationen auf Knoten- und Kanteninstanzen und auch auf deren Attribute.

\paragraph*{Traversierung} Der Begriff Traversierung bezeichnet das Durchlaufen des Graphen unter Verwendung verschiedener algorithmischer Ansätze ausgehend von einem Knoten oder einer Knotenmenge\cite{ottmann2002algorithmen}. Die Traversierung zählt ebenfalls zu den grundlegenden Operationen in Graphdatenbanken, da sie die selektive Datenanalyse und Datenmanipulation ermöglicht\cite{DBLP:journals/corr/abs-1004-1001}. Der analytische Prozess wird durch die abstrakte Definition eines Weges innerhalb des Graphen beschrieben, das Ergebnis der Traversierung sind Seiteneffekte des Prozesses\cite{Rodriguez_Traversal:2011}. Dies kann zum Beispiel die Menge der abgeleiteten Instanzen des abstrakten Weges sein oder ausschließlich die Menge ihrer Zielknoten. Darüber hinaus ermöglicht die Traversierung Berechnungen auf Basis der Attribute besuchter Knoten- und Kanteninstanzen. Datenmanipulation findet statt, wenn der Zustand eines traversierten Objektes durch eine am Objekt ausgeführte Berechnung dauerhaft verändert wird.

Ein einfaches Beispiel für eine Traversierung ist das Abfragen der Nachbarschaft eines Knotens in einem gerichteten Graphen. Eine Anfrage könnte zum Beispiel lauten: \textit{\glqq Welche Knoten sind mit Knoten x verbunden?\grqq}. Dabei werden ausgehend vom Startknoten $x$ dessen ein- und ausgehende Kanten traversiert und die Menge ihrer jeweiligen Start- bzw. Zielknoten zur Ergebnismenge hinzugefügt. Sei zum Beispiel $n: \mathcal{P}(V) \rightarrow \mathcal{P}(V)$ ein Operator, welcher die Nachbarschaft einer gegebenen Knotenmenge elementweise berechnet und sei $n$ Teil einer beliebigen Anfragesprache, so ist der Aufruf der Funktion $f(x) := n(x)$ eine mögliche abstrakte Weg-Definition. Erweitert man die gesuchte Knotenmenge auf alle Knoten mit Abstand $k$ vom Startknoten, spricht man von einer $k$-hop-Operation\cite{Dominguez-Sal2011}. Die Traversierung kann beendet werden, wenn der Abstand $k$ erreicht ist. Die abstrakte Weg-Definition ist somit die $k$-fache Komposition von $n$. Für die Anfrage: \textit{\glqq Welche Knoten sind drei Schritte von x entfernt?\grqq} lautet die abstrakte Weg-Definition: $f(x) := n(n(n(x))) = (n \circ n \circ n)(x)$.

In attributierten oder bezeichneten Graphen und Multigraphen kann das Traversieren durch definierte Einschränkungen beeinflusst werden. Zum Beispiel würde die Anfrage \textit{\glqq Wer sind die Freunde von Alice?\grqq} ausgehend vom Startknoten \texttt{Alice} nur die Kanten mit dem Bezeichner \texttt{befreundet mit} traversieren, während die Anfrage \textit{\glqq Wer sind die Freunde von Alice, die an der Universtität Leipzig studieren, über 25 Jahre alt und Mitglied in einem Verein sind?\grqq} zusätzlich die Attribute der Nachbarknoten und deren jeweilige Nachbarschaft berücksichtigt. Eine Anfragesprache, welche diese Einschränkungen unterstützt, stellt hierfür Operatoren bereit. Diese ermöglichen zum Beispiel das Filtern von Knoten und Kanten auf der Grundlage ihrer Attribute oder Bezeichner.

Aus den genannten Beispielen geht hervor, dass die Reihenfolge, in welcher Knoten und Kanten durch den Prozess besucht werden, verschiedenartig sein kann. Bei der Traversierung werden drei Methoden unterschieden: Breitensuche, Tiefensuche und randomisierte Suche\cite{EdlichFriedlandHampeBrauer201010, ottmann2002algorithmen}. Bei der Breitensuche (engl. \textit{Breadth First Search}, BFS) werden zunächst alle Nachbarn eines Knotens betrachtet bevor der Abstand zum Startknoten erhöht wird. Diese Methode eignet sich für eine lokale Suche in der Umgebung des Startknotens. Anders verhält es sich bei der Tiefensuche (engl. \textit{Depth First Search}, DFS), welche zunächst tiefer in den Graphen vordringt, bevor weitere Nachbarn eines Knotens betrachtet werden. BFS und DFS benötigen dedizierte Datenstrukturen, um die Menge der bereits betrachteten Knoten zu speichern und den nächsten Knoten auszuwählen. Letzteres kann insbesondere bei der Speicherung aller abgeleiteten Pfadinstanzen bei umfangreichen Graphen zu Speicherproblemen führen\cite{ottmann2002algorithmen}. Die randomisierte Suche begegnet diesem Problem mit der zufälligen Auswahl des nächsten zu betrachtenden Knotens. Diese Methode ist jedoch mit einer gewissen Fehlerwahrscheinlichkeit behaftet resp. weist sie eine Unvollständigkeit auf, sie eignet sich somit nur für jene Anfragen, in denen dies toleriert werden kann\cite{EdlichFriedlandHampeBrauer201010}.

\subsection{Komplexe Operationen}
\label{subsec:graph_operations}

\paragraph*{Erreichbarkeit} Eine mögliche Anwendung der Traversierung ist die Berechnung eines Weges zwischen zwei definierten Knoten bzw. die Überprüfung, ob ein Zielknoten ausgehend von einem Startknoten erreichbar ist. Die Anforderungen, welche an die zu suchenden Wege gestellt werden, können verschieden sein: Bei Pfaden fester Länge ist die Anzahl der Knoten bzw. Kanten vorgegeben, während Pfade beliebiger Länge diese Einschränkung nicht aufweisen\cite{Angles:2012}. Eine weitere Anforderung ist das Berechnen des kürzesten Pfades zwischen zwei Knoten, dabei handelt es sich um die grundlegende Berechnung in einer Vielzahl analytischer Algorithmen\cite{Newman:2010:NI:1809753}. Bei der Definition der Traversierung wurde darauf hingewiesen, dass in attributierten oder bezeichneten Graphen zusätzliche Informationen in die Anfrage einbezogen werden können. Dies gilt ebenfalls für die Berechnung von Pfaden.

In ungewichteten Graphen kann der kürzeste Pfad durch Traversierung mittels Breitensuche berechnet werden\cite{Yannakakis:1990:GMD:298514.298576}, wohingegen sich für Pfade beliebiger Länge die Tiefensuche anbietet. Für kantengewichtete Graphen existiert eine Vielzahl von Verfahren, so zum Beispiel der Algorithmus von Dijkstra für nicht-negative Gewichte oder der Algorithmus von Bellman und Ford für beliebige Gewichte\cite{ottmann2002algorithmen}. Verschiedene kommerzielle GDBMS bieten für das Finden von Pfaden beliebiger und fester Länge, die Berücksichtigung von Einschränkungen und das Finden des kürzesten Pfades entsprechende Operatoren an\cite{Angles:2012}.

\paragraph*{Mustersuche} Neben der Traversierung ist die Mustersuche innerhalb der Datenbasis (engl. \textit{graph pattern matching}) eine weitere wichtige Operation in GDBMS. Ihr Ziel ist es, jene (Teil-)Graphen zu finden und zu extrahieren, die unter Einhaltung definierter Bedingungen auf einen gegebenen Mustergraphen abgebildet werden können\cite{Barcelo:2011:QGP:1989284.1989307, DBLP:journals/ijprai/ConteFSV04}. Der Mustergraph wird innerhalb der Anfrage formuliert und kann aus einer beliebigen Anzahl Konstanten und Variablen bestehen. Konstanten sind Knoten- und Kanteninstanzen innerhalb der Datenbasis. Das GDBMS findet alle (Teil-)Graphen, welche dem Muster entsprechen und bindet vorhandene Variablen an deren Werte (vgl. Abschnitt \ref{subsec:rdf}, SPARQL).

Inexakt und exakt sind die Differenzierungen für die Mustersuche. Das wesentliche Unterscheidungskriterium sind die Bedingungen, welche an die Abbildungen gestellt werden. Bei der exakten Mustersuche muss die Abbildung zwischen zwei Graphen kantenerhaltend (engl. \textit{edge-preserving}) sein, was bedeutet, dass adjazente Knoten im ersten Graphen auf adjazente Knoten im zweiten Graph abgebildet werden müssen. In der stringentesten Form der exakten Mustersuche, dem Graph-Isomorphismus, gilt diese Forderung für alle Knoten in beiden Graphen\cite{Barcelo:2011:QGP:1989284.1989307}. Eine abgeschwächte Form der Mustersuche ist der Subgraph-Isomorphismus. Hier gilt die Kantenerhaltung zwischen einem der beiden Graphen, dem Mustergraphen, und einem induzierten Teilgraphen der Datenbasis. Die in Bezug auf die Bedingungen schwächste und für GDBMS interessanteste Form der Mustersuche ist der Subgraph-Homomorphismus. Bei diesem entfällt die Anforderung der eindeutigen Zuordnung zwischen Knoten, was bedeutet, dass ein Mustergraph auf mehrere Subgraphen innerhalb der Datenbasis abgebildet werden kann. Subgraph-Isomorphismus und -Homomorphismus sind insbesondere in Multigraphen interessant, da eine Mustersuche auch dann ein Ergebnis liefert, wenn zwei Knoten durch zusätzliche, nicht im Muster definierte, Kanten verbunden sind. Dies wäre zum Beispiel bei einem induzierten Subgraph-Isomorphismus nicht möglich. Subgraph-Isomorphismus und Subgraph-Homomorphismus zählen zur Klasse der NP-vollständigen Probleme, für den Graph-Isomorphismus konnte bisher nicht gezeigt werden, ob er zu NP gehört\cite{Barcelo:2011:QGP:1989284.1989307}.

Algorithmen, welche die exakte Mustersuche implementieren, benötigen im ungünstigsten Fall eine exponentielle Laufzeit\cite{Barcelo:2011:QGP:1989284.1989307}. Es kann demzufolge sinnvoll sein, die Anforderungen an die Abbildung zu lockern und nicht zwingend das beste, sondern ein akzeptables Ergebnis in vertretbarer Zeit zu berechnen. Bei der inexakten Mustersuche werden auch Abbildungen akzeptiert, welche die Kantenerhaltung nicht erfüllen. Diese Abbildungen werden auf der Grundlage eines Kostenmodells bewertet. Ein Beispiel hierfür ist die Menge der Änderungsoperationen, die notwendig sind, um den ersten Graph in den zweiten Graph zu überführen. Je mehr Operationen hierfür nötig sind, desto schlechter wird die Abbildung bewertet. Die Abbildung mit den geringsten Kosten bzw. alle Abbildungen unter einem definierten Schwellwert stellen das Ergebnis der Operation dar\cite{Barcelo:2011:QGP:1989284.1989307}.

\paragraph*{Aggregation und Summierung} Aggregatfunktionen fassen eine Menge von  Werten zu einem einzelnen Wert zusammen. Beispiele hierfür sind \texttt{count} zur Bestimmung der Anzahl der Elemente einer Ergebnismenge, \texttt{min} und \texttt{max} bestimmen das kleinste und größte Element und \texttt{avg} berechnet den Durchschnitt einer Menge von numerischen Werten\cite{Angles:2012, kemper2006datenbanksysteme}. Das Ergebnis einer Mustersuche oder einer Traversierung lässt sich entweder vollständig oder gruppiert nach Eigenschaftswerten aggregieren. Die Operationen sind insbesondere für die Analyse eines (Teil-)Graphen von Interesse. Eine mögliche Anfrage, in der das vollständige Ergebnis für die Aggregation genutzt wird, lautet: \textit{\glqq Welches ist das durchschnittliche Alter aller Studenten der Universität Leipzig?\grqq}. Darüber hinaus sind Gruppierungen, wie zum Beispiel \textit{\glqq Welches ist das durchschnittliche Alter der Studenten in den Studiengängen der Universität Leipzig?\grqq}, möglich. Die bisher genannten Beispiele können auch in einem RDBMS ausgeführt werden. Ein Beispiel für eine graphenorientierte Anfrage lautet hingegen: \textit{\glqq Wie ist die Häufigkeitsverteilung der Pfadlängen bezüglich der Freundschaftsbeziehungen zwischen zwei Studenten der Universität Leipzig?\grqq}. Das Ergebnis ist eine Menge von Pfaden, diese werden anhand ihrer Länge zusammengefasst und gruppenweise gezählt.

Während die Aggregation einzelne, numerische Werte berechnet, dient die Summierung dem topologischen Zusammenfassen komplexer, umfangreicher Graphen zu kompakteren Graphen. Durch das Subsumieren von Informationen kann der resultierende Graph besser analysiert und möglicherweise auch visualisiert werden. Das Zusammenfassen kann auf zwei Arten erfolgen: Zum Einen lassen sich wiederkehrende Muster identifizieren und durch einzelne Knoten ersetzen\cite{EdlichFriedlandHampeBrauer201010}. Zum Anderen ist die Gruppierung von Knoten und Kanten auf der Grundlage benutzerdefinierter Attribute möglich\cite{Tian:2008:EAG:1376616.1376675, Zhao:2011:GCW:1989323.1989413}. Die Gruppen werden durch neue Knoten repräsentiert, Beziehungen zwischen den Elementen verschiedener Gruppen werden durch Kanten zwischen den jeweiligen Gruppen ersetzt.

\paragraph*{Metriken} Die letzte Gruppe umfasst Operatoren zur Berechnung von Metriken bzgl. der Topologie des Graphen. Diese sind vor allem für Anwendungen interessant, in denen das komplette Netzwerk analysiert werden soll\cite{Newman:2010:NI:1809753}. Beispiele für einfache Metriken sind die Knoten- und Kantenanzahl oder die Häufigkeitsverteilung der Knotengrade. Zu den komplexeren Metriken zählen die durchschnittliche Länge der kürzesten Pfade zwischen allen möglichen Knotenpaaren und der Durchmesser des Graphen. Letzterer ist der maximale Abstand zwischen zwei Knoten. Darüber hinaus lassen sich Aussagen über den Zusammenhang des Graphen ebenfalls in diese Kategorie einordnen. Hierbei ist es zum Beispiel von Interesse die Anzahl der maximal zusammenhängenden Teilgraphen eines Graphen zu bestimmen.

\section{Zusammenfassung}

Dieses Kapitel widmete sich zunächst den graphentheoretischen Grundlagen der Arbeit. Im Folgenden wurden die verschiedenen Arten realer Netzwerke und jeweils einzelne Beispiele vorgestellt. Eine Übersicht über graphenbasierte Softwaresysteme zeigte deren Anwendungsbereiche, der Schwerpunkt lag dabei auf Graphdatenbanksystemen und den verschiedenen Ausprägungen. Der zweite Teil des Kapitels konzentrierte sich ausschließlich auf GDBMS. Der Erläuterung verschiedener Datenmodelle folgte im letzten Abschnitt die Definition der Operationen, welche für das Auslesen und das Manipulieren der Datenbasis relevant sind. Im nächsten Kapitel werden konkrete Graphdatenbanksysteme auf der Grundlage definierter Anforderungen ausgewählt und in einem funktionalen Vergleich gegenübergestellt.