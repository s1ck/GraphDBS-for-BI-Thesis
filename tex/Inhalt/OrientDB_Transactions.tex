\paragraph*{Transaktionen}

OrientDB unterstützt die Ausführung von Zugriffen innerhalb von Transaktionen. Im Fall von SQL werden diese für Änderungen implizit erzeugt, der Commit erfolgt unmittelbar nach der Ausführung. Alternativ können Transaktionen explizit begonnen, beendet und zurückgesetzt werden. Bei der Verwendung der Java API ist die Ausführung von Änderungen nur in Verbindung mit dem expliziten Verwalten einer Transaktion möglich. Analog zu HyperGraphDB lassen sich Transaktionen zur Beschleunigung des Datenimports beim Systemstart deaktivieren.

Anders als bei den bisher betrachteten Systemen wird das Schachteln von Transaktionen in OrientDB nicht unterstützt. Zu jedem Zeitpunkt ist je Thread im eingebetteten Betrieb bzw. pro Datenbankverbindung im Client-Server-Betrieb nur eine Transaktion möglich. Ist zu Beginn einer Transaktion bereits eine weitere aktiv, wird diese zurückgesetzt.

OrientDB bezeichnet sich selbst als ACID-konformes GDBMS: Zur Vermeidung von Mehrbenutzeranomalien wird das optimistische Synchronisationsverfahren MVCC eingesetzt, das bereits im Zusammenhang mit HyperGraphDB beschrieben wurde. Die Ausführung einer Transaktion erfolgt zunächst ausschließlich innerhalb der Anwendung bzw. beim Client. Werden Objekte erzeugt, so erhalten sie eine temporäre Identität, Änderungen an gelesenen Objekten erfolgen ebenfalls unabhängig vom GDBMS im Kontext der Anwendung. Beim Commit werden alle Operationen an das Datenbanksystem übertragen, dort werden sie chronologisch ausgeführt und die Änderungen in die Datenbasis eingebracht.\footnote{Die Speicherschicht ist während des Ausführung des Commit exklusiv gesperrt, Dirty Reads werden somit vermieden. Dies kann im Quelltext unter \url{https://github.com/orientechnologies/orientdb/blob/1.5.1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/OStorageLocalTxExecuter.java\#L83-L88} nachvollzogen werden.} Ein Konflikt besteht, wenn ein von der Transaktion geändertes Objekt innerhalb der Datenbasis eine neue Version aufweist, in diesem Fall wird die Transaktion zurückgesetzt.\footnote{Dies kann im Quelltext unter \url{https://github.com/orientechnologies/orientdb/blob/1.5.1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/OStorageLocal.java\#L1839-L1854} nachvollzogen werden.}\\
Im Gegensatz zu HyperGraphDB berücksichtigen Lesezugriffe nicht ausschließlich Objektversionen, die zu Beginn der Transaktion aktuell waren, stattdessen wird beim ersten Zugriff auf ein Objekt dessen neueste Version aus der Datenbasis geladen.\footnote{Dies entspricht dem Konzept der chronologieerhaltenden Serialisierbarkeit\cite{DBLP:books/sp/HarderR01}.} Alle nachfolgenden Lesezugriffe beziehen sich auf diese Objektversion. Daraus geht hervor, dass alle Mehrbenutzeranomalien vermieden werden, was der Isolationsebene \texttt{SERIALIZABLE} entspricht.\footnote{Zu beachten ist, dass dies ausschließlich für die eingebettete Verwendung gilt. Im Client-Server-Betrieb werden Lesezugriffe immer vom Server beantwortet, folglich können die Anomalien Non-Repeatable Read und Phantom Problem auftreten. Dies entspricht der Isolationsebene \texttt{READ COMMITTED}. Die getroffenen Annahmen wurden durch den Entwickler bestätigt\cite{Orient_acid:2013}.}

Für den Fall, dass es vor dem Commit einer Transaktion zum Ausfall des GDBMS oder des Clients kommt, so sind die bis zu diesem Zeitpunkt erfolgten Änderungen nicht in der Datenbasis geschrieben; folglich ist in den genannten Situationen die atomare Ausführung der Transaktion sichergestellt. Kommt es hingegen beim Ausführen des Commit zum Ausfall des GDBMS, können bereits Teile einer Transaktion in der Datenbasis vorhanden sein. Um diese Änderungen widerrufen zu können, wird vor dem Ausführen jeder Änderung ein zugehöriger UNDO-Eintrag in ein Transaktions-Log geschrieben. Beim Löschen oder Ändern enthält der Eintrag eine Kopie des ursprünglichen Datensatzes.\footnote{Dies entspricht dem Konzept des physischen Loggings\cite{DBLP:books/sp/HarderR01} und kann für das Aktualisieren im Quelltext unter \url{https://github.com/orientechnologies/orientdb/blob/1.5.1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/OStorageLocalTxExecuter.java\#L115} nachvollzogen werden.} Das Ausschreiben der Log-Daten auf den Externspeicher erfolgt unmittelbar, beim Neustart des GDBMS kann folglich ein konsistenter Zustand wiederhergestellt werden.\\
Bei der Betrachtung der Wiederholbarkeit erfolgreich beendeter Transaktionen muss zwischen den zwei verschiedenen in OrientDB auswählbaren Speichermechanismen unterschieden werden: \texttt{OStorageLocal} und \texttt{OLocalPaginatedStorage}. Erstgenanntes nutzt Memory Mapped Files und überlässt es demnach dem Betriebssystem, wann ausgeschriebene Änderungen tatsächlich auf den Externspeicher geschrieben werden. Das zugehörige Transaktions-Log enthält jedoch keine REDO-Informationen erfolgreich beendeter Transaktionen. Folglich sind deren Änderungen verloren, wenn diese sich zum Zeitpunkt eines Systemausfalls noch nicht auf dem Externspeicher befinden.\footnote{Das GDBMS ermöglicht das Aktivieren einer FORCE-Strategie, bei der sowohl Log-Informationen als auch Änderungen an der Datenbasis unmittelbar auf den Externspeicher geschrieben werden. Dies kann jedoch mit Performance-Einbußen verbunden sein\cite{DBLP:books/sp/HarderR01}.}\\
Im Gegensatz dazu verwaltet \texttt{OLocalPaginatedStorage} den Zugriff auf den Externspeicher unabhängig vom Betriebssystem und führt ein Transaktions-Log in dem sowohl UNDO- als auch REDO-Informationen gespeichert werden. Das Log selbst wird beim Commit auf den Externspeicher geschrieben, das Ausschreiben der eigentlichen Änderungen kann asynchron erfolgen, da die Log-Informationen ein Wiederherstellen im Fehlerfall ermöglichen.