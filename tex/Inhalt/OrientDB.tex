\section{OrientDB}

% Firma + Lizenz
OrientDB ist ein quelloffenes GDBMS, welches von der Firma Orient Technologies\footnote{\url{http://www.orientechnologies.com
}} entwickelt wird. Der Quellcode steht unter Apache 2.0 Lizenz\footnote{\url{http://www.apache.org/licenses/LICENSE-2.0.html}}, was bedeutet, dass er in freien, aber auch auch in kommerziellen Anwendungen eingesetzt werden darf. Das GDBMS wurde 2010 veröffentlicht, die erste stabile Version 1.0 erschien 2012. Für die Implementierung wird ausschließlich Java verwendet, die Ausführung ist somit analog zu Neo4j und HyperGraphDB an die JVM gebunden und auf kompatiblen Plattformen möglich. OrientDB ist ein Graphdatenbanksystem, in dem Modellierung und Zugriff graphenorientiert erfolgen, für die Speicherung wird ein dokumentenorientiertes Speicherkonzept eingesetzt.\\
Das GDBMS lässt sich in Java-Anwendungen einbetten oder alternativ in einer Client-Server-Konfiguration verwenden, entsprechende Clients stehen zur Verfügung.\footnote{Für den Zugriff via Rest wird eine Vielzahl von Client-Implementierungen angeboten. Diese sind unter \url{https://github.com/orientechnologies/orientdb/wiki/Programming-Language-Bindings} gelistet. Ein Binärprotokoll wird ebenfalls angeboten, jedoch aktuell nur von C/C++, PHP und nodejs unterstützt: \url{https://github.com/orientechnologies/orientdb/wiki/Network-Binary-Protocol}.} Neben einer zentralen Verwendung ist auch der Einsatz als verteiltes System möglich. Hierfür wird eine Master-Master-Replikation realisiert, was eine horizontale Skalierbarkeit von Lese- und Schreibanfragen sowie eine erhöhte Ausfallsicherheit verspricht. Die Speicherung der Datenbasis erfolgt disk-zentriert. Das System bietet zwar die ausschließliche Nutzung des Hauptspeichers an, dies entspricht jedoch nicht der definierten hauptspeicher-zentrierten Speicherung, sondern ist für die Verwendung im Rahmen von Unit-Tests vorgesehen.

% Besonderheiten (Dokumente, Typsystem) + Anwendungsfall
Eine besonderes Merkmal von OrientDB ist die Möglichkeit, das Datenbanksystemen mit verschiedenen Datenmodellen zu nutzen. Die Speicherung der Informationen erfolgt grundlegend in Form von Dokumenten, ein darauf aufbauendes graphenorientiertes Datenmodell ermöglicht die Definition von Beziehungen zwischen Dokumenten. Darüber hinaus lässt sich OrientDB als objektorientiertes Datenbanksystem einsetzen, wobei Objektinstanzen ebenfalls auf Dokumente abgebildet werden. In allen drei Datenmodellen ist die Definition eines Schemas zur Modellierung einer Anwendungsdomäne und zur Festlegung von Integritätsbedingungen möglich, der vollständige Verzicht auf ein Schema und die Kombination eines Schemas mit semi-strukturierten Daten werden ebenfalls unterstützt. Weitere Alleinstellungsmerkmale sind die Verwendung und Erweiterung des SQL-Standards und die systemseitige Implementierung einer Rechteverwaltung.

% Ausführungen beziehen sich auf ... + Quellen
Die nachfolgende Evaluation basiert auf der im September 2013 freigegebenen Version 1.5.1. Der Großteil der Informationen stammt aus den Ausführungen zu OrientDB in \cite{EdlichFriedlandHampeBrauer201010}, \cite{tesorierogetting} und der offiziellen Dokumentation\cite{Orient_doku:2013}. Es werden ausschließlich das Dokumenten- und das darauf aufbauende Graphdatenmodell berücksichtigt.

\subsection{Datenmodell, Typsystem und Rechteverwaltung}

Die Basiseinheit zur Darstellung von Informationen ist das \textit{Dokument}, welches sich aus einer Menge von Schlüssel-Wert-Paaren zusammensetzt. Schlüssel sind innerhalb eines Dokumentes eindeutige Bezeichner vom Typ \texttt{String}, zugehörige Werte sind typisiert und dienen zur Speicherung der Nutzdaten. Das System unterstützt eine Vielzahl vordefinierter Typen, wie zum Beispiel \texttt{int} oder \texttt{float}, und erlaubt darüber hinaus das Definieren eigener Typen.\footnote{Eine Liste aller vordefinierter Datentypen kann unter \url{https://github.com/orientechnologies/orientdb/wiki/Types} eingesehen werden.} Ein Wert kann auch ein Dokument bzw. eine Menge von Dokumenten sein, wodurch sich beliebige Einbettungen realisieren lassen.

% Graphenmodell
Zur Modellierung von Graphen verwendet OrientDB das Property-Graph-Modell. Dieses kann entsprechend der Definition schemalos verwendet werden, wie auch in Neo4j wird jedoch die Definition eines Schemas empfohlen, um das Formulieren von Anfragen zu vereinfachen und gleichzeitig deren effizientere Ausführung zu ermöglichen. Die Knoten innerhalb des Graphen und ihre Attribute werden auf Dokumente abgebildet. Ist die Vergabe von Knotenbezeichnern erforderlich, kann dies entweder durch ein dediziertes Schlüssel-Wert-Paar oder durch die Zuordnung des Knotens zu einer \textit{Klasse} erfolgen.

Für die Repräsentation von Beziehungen unterscheidet OrientDB zwei Arten: Referenzierte und eingebettete Beziehungen, für die beide gilt, dass Beziehungsinformationen generell als Schlüssel-Wert-Paare am Knoten abgelegt werden.\\
Eine referenzierte Beziehung entspricht dem Konzept einer gerichteten Kante. Der Schlüssel ist der Kantenbezeichner, welcher sich aus dem Typ der entsprechenden Kante ergibt. Werden keine Kantenattribute verwendet, so bildet der zugehörige Wert die Menge der Identitäten aller Zielknoten, die über eine entsprechend bezeichnete Kante mit dem Startknoten verbunden sind. Besitzt die Kante hingegen Attribute, so wird sie durch ein eigenes Dokument in der Datenbasis repräsentiert. Der Wert am Startknoten ist in diesem Fall eine Menge der Kanten-Identitäten. In beiden Fällen kann diese Menge unsortiert oder geordnet sein. Die Zielknoten enthalten ebenfalls dedizierte Schlüssel-Wert-Paare, welche Informationen über die eingehenden Kanten speichern. Auch hier wird entweder direkt auf Startknoten oder auf Kanten-Dokumente verwiesen, was bedeutet, dass auch in OrientDB eine einzelne Kante zur Darstellung einer bidirektionalen Beziehung ausreicht.\footnote{Die dargelegten Informationen basieren auf der Untersuchung der physischen Repräsentation eines Minimalbeispiels.}\\
Eine zweite Art Abhängigkeiten zwischen Informationen zu modellieren, ist die Verwendung eingebetteter Beziehungen. Diese werden in dokumentenorientierten Datenbanken eingesetzt, in welchen das Konzept der Fremdschlüssel nicht vorhanden ist. Die Beziehung zwischen zwei Objekten A und B wird durch das Einbetten von B in A, oder umgekehrt, modelliert. Das eingebettete Objekt besitzt keine eigene Identität innerhalb der Datenbasis. Der Schlüssel bezeichnet die Art der Beziehung, der Wert die referenzierte Information. Sollen mehrere Werte mit dem gleichen Schlüssel eingebettet werden, so ist dies analog zu referenzierten Beziehungen in geordneten Listen oder unsortierten Mengen möglich. Generell bietet sich diese Art der Modellierung an, wenn die eingebetteten Informationen nur für den jeweiligen Knoten relevant sind und sie nicht mehreren Knoteninstanzen zugeordnet sein können. Letzteres würde zu Redundanz führen und folglich die Konsistenzerhaltung erschweren.

% Identität
Die Identität eines Dokumentes wird systemseitig vergeben und ist unveränderbar. Dokumente können mittels ihrer Identität adressiert werden, diese entspricht somit dem Konzept des Primärschlüssels. Aus den bisherigen Ausführungen geht hervor, dass sowohl Knoten als auch Kanten in Form von referenzierten Beziehungen eine Identität besitzen. Bei nicht-attributierten Kanten setzt sich diese aus den Identitäten der Start- und Zielknoten zusammen. Anzumerken sei, dass eine Identität nach dem Löschen der zugehörigen Instanz neu vergeben werden kann. Im Zusammenhang mit der physischen Repräsentation des Graphen wird genauer auf den Aufbau der Identität eingegangen.

% Datenbank
Im Gegensatz zu den bisher vorgestellten GDBMS erlaubt OrientDB das Verwalten mehrerer Datenbanken in einer GDBMS-Instanz. Dabei benötigt jede Datenbank einen eindeutigen Bezeichner, ein datenbank-übergreifender Zugriff innerhalb von Anfragen ist jedoch nicht möglich. Beim Initialisieren einer Datenbank kann festgelegt werden, ob sich diese lokal im Dateisystem oder entfernt im Netzwerk befindet, alternativ kann sie für Testzwecke komplett im Hauptspeicher gehalten werden.

\paragraph*{Typsystem} 

Anzahl und Struktur der Schlüssel-Wert-Paare können für jedes Dokument individuell verschieden oder aber durch ein Schema festgelegt sein. Darüber hinaus ist es in OrientDB möglich, auch nur einen Teil der Informationen durch ein Schema zu beschreiben und dieses beliebig zu erweitern. Folglich ist auch hier eine hohe Flexibilität hinsichtlich der Schemaevolution innerhalb einer Anwendung gegeben.\\
Ein Schema definiert sich in OrientDB durch eine Menge von Klassen, wobei eine Klasse an das entsprechende Konzept in der Objektorientierung angelehnt ist. Eine Klasse legt den Typ eines Dokumentes fest und definiert, welche Attribute es besitzt und welche Integritätsbedingungen diese aufweisen. Beispielsweise kann der Wertebereich durch den entsprechenden Typ implizit eingeschränkt werden. Zusätzlich lassen sich Wertebereiche numerischer Datentypen durch das Angeben von Intervallen oder, im Fall von alphanumerischen Typen, durch das Formulieren regulärer Ausdrücke explizit einschränken. Weiter lässt sich festlegen, ob ein Attribut obligatorisch ist und ob es den Wert \texttt{null} annehmen darf. Wird ein Attribut als \texttt{UNIQUE} deklariert, erzeugt das System einen Index und das Attribut kann neben der eigentlichen Identität des Dokuments als Primärschlüssel verwendet werden. Mittels des Konzeptes der eingebetteten Beziehungen können zur Beschreibung der Struktur entsprechender Dokumente Typen auch verschachtelt werden.

Das Modellieren von Vererbungshierarchien ist ebenfalls möglich: Attribute von Oberklassen werden an alle Unterklassen weitergegeben, eine Einschränkung der Sichtbarkeit ist nicht vorgesehen. OrientDB erlaubt das Anlegen abstrakter Klassen, welche analog zur Objektorientierung nicht instanziiert werden, sondern ausschließlich Attribute für ihre Spezialisierungen vorgeben. Mehrfachvererbungen sind generell nicht möglich.

\paragraph*{Rechteverwaltung} Als einziges der evaluierten Systeme bietet OrientDB eine integrierte Nutzer- und Rollenverwaltung auf Datenbankebene an. Ein Nutzer wird durch einen Namen und ein optionales Passwort identifiziert und besitzt eine oder mehrere Rollen. Eine Rolle definiert sich wiederum durch eine Menge von Regeln, die entweder nach Whitelist-Prinzip erlaubt oder nach Blacklist-Prinzip verboten werden. Eine Rolle \texttt{Reader} verbietet zum Beispiel alle Regeln bis auf das Lesen anwendungsspezifischer Datenbanken, wohingegen eine Rolle \texttt{Writer} alles bis auf das Lesen und Schreiben von Nutzerinformationen erlaubt. Innerhalb des Systems existiert ein Nutzer \texttt{admin}, dessen Rolle alle Regeln erlaubt. Da Rollen selbst in Form typisierter Dokumente verwaltet werden, unterstützen sie auch das Konzept der Vererbung. Die Granularität einer Regel lässt sich standardmäßig bis auf Klassenebene einstellen, durch das Erben einer dedizierten Klasse erlaubt OrientDB darüber hinaus eine Rechteverwaltung auf Instanzebene. Letzteres ist insbesondere dann sinnvoll, wenn innerhalb einer Datenbank nutzerabhängige Sichten auf den Graphen definiert werden sollen. Die im Forschungsvorhaben beschriebene Verwaltung extrahierter Teilgraphen in einer Datenbasis ist somit realisierbar. Mit einer entsprechenden Rolle sind Teilgraph-übergreifende Anfragen möglich.

\subsection{Zugriffsmechanismen und Indexverwaltung}

Das GDBMS bietet mehrere Optionen für den Zugriff auf die Datenbasis. Wie HyperGraphDB und Neo4j enthält auch OrientDB eine Java API zur Verwaltung des Graphen mittels CRUD-Operationen. Hierfür implementiert das GDBMS die Blueprints API\footnote{An dieser Stelle sei angemerkt, dass es sich bei der Blueprints API um einen Quasi-Standard für GDBMS handelt. Viele Anbieter, u.a. Neo4j, Dex und InfiniteGraph, bieten neben ihren proprietären APIs eine Implementierung der Blueprints API an. Diese Implementierung bildet CRUD-Operationen auf die jeweilige proprietäre API ab und stellt somit eine zusätzliche Indirektion im Aufruf dar. Teilweise kann hierdurch nicht der volle Funktionsumfang des GDBMS genutzt werden. OrientDB und Titan implementieren die Blueprints API hingegen nativ, was bedeutet, dass Aufrufe unmittelbar an das GDBMS weitergegeben werden und der komplette Funktionsumfang zur Verfügung steht. Eine Beschreibung der API kann unter \url{https://github.com/tinkerpop/blueprints/wiki} eingesehen werden.}, eine im TinkerPop-Projekt definierte Referenz-Schnittstelle für das PGM.\footnote{OrientDB enthält auch eine eigene Core API, diese wurde jedoch in Version 1.4 als veraltet deklariert und wird folglich in der Evaluation nicht betrachtet.} Infolgedessen lässt sich auch die Anfragesprache Gremlin in OrientDB verwenden, primäre Anfragesprache ist jedoch der deklarative OrientDB-SQL-Dialekt, welcher einen Teil des SQL-92-Standards\cite{SQL_92:2013} übernimmt und um graphenspezifische Operatoren erweitert.\footnote{Zu beachten ist, dass der Orient-SQL-Dialekt nicht mit dem ANSI SQL Standard konform ist\cite{tesorierogetting}.}

\paragraph*{CRUD-Operationen via Blueprints API}

Die Blueprints API ist eine imperative Java API und der Core API von Neo4j sehr ähnlich. Es stehen Methoden zum Erzeugen und Lesen von Knoten und Kanten zur Verfügung, ihr Ergebnis ist eine Referenz auf das persistente Objekt mit einer eindeutigen Identität. Kanten können nur unter Angabe existierender Knoten erzeugt werden, ihre Reihenfolge bei der Parameterangabe bestimmt die Kantenrichtung. Die Spezifikation eines Kantenbezeichners ist obligatorisch, dieser ist ein Wert vom Typ \texttt{String} und kann folglich statisch in der Anwendung oder dynamisch zur Laufzeit festgelegt werden. Sowohl Knoten als auch Kanten verfügen über Methoden zum Anlegen von Attributen. Werden Arrays, Mengen oder assoziative Arrays unterstützter Datentypen als Wert angegeben, erzeugt das GDBMS automatisch eine eingebettete Beziehung. Knoten- und Kantenattribute können aktualisiert oder gelöscht werden. Knoten verfügen über zusätzliche Funktionen zum Auslesen inzidenter Kanten und adjazenter Knoten, Kanten verfügen wiederum über Methoden zum Auslesen von Start- und Zielknoten sowie ihres Bezeichners. Sowohl Knoten als auch Kanten lassen sich aus der Datenbasis entfernen, dabei stellt das GDBMS die referentielle Integrität sicher.

% Vertex Query
Für das Formulieren lokaler Anfragen innerhalb des Graphen stellt die Blueprints API das Konzept der knoten-zentrierten Anfragen zur Verfügung, bei denen der Graph aus der Sicht eines Knotens untersucht werden kann. Das Konzept bietet die Möglichkeit, die Menge der inzidenten Kanten eines Knotens durch die Angabe von Richtung, Bezeichner und Prädikaten auf Attributen einzuschränken. Vorteil der Einschränkung ist die mögliche Minimierung der Datenmenge, welche vom Hintergrundspeicher geladen werden muss. Dies ist insbesondere dann relevant, wenn es sich um Knoten mit einem überdurchschnittlich hohen Grad handelt, wie sie typischerweise in realen Netzwerken vorkommen und welche als Hubs bezeichnet werden\cite{Newman:2010:NI:1809753}. Voraussetzung ist jedoch, dass das jeweilige GDBMS eine Einschränkung der inzidenten Kanten unterstützt. In OrientDB sind Kanten anhand ihres Bezeichner innerhalb eines Dokumentes gruppiert gespeichert, eine Indexierung von Kantenattributen ist jedoch nicht möglich.

% Klassen
OrientDB erweitert die API um Methoden zur Verwaltung von Klassen, welche unter Angabe eines Namens erzeugt werden. Anschließend lassen sich Attributdefinitionen, bestehend aus Attributname, Datentyp sowie eventuellen Integritätsbedingungen, für die Klasse festlegen. Wird diese als strikt deklariert, sind alle Attribute obligatorisch und müssen von den Instanzen angegeben werden. Eine Klasse ohne jegliche Attribute entspricht hingegen dem Konzept des Knotenlabels in Neo4j. Beim Erzeugen einer Klasse kann diese als abstrakt deklariert und wahlweise eine Oberklasse angegeben werden. Die Zuordnung einer Knoten- oder Kanteninstanz zu einer Klasse erfolgt beim Erzeugen; der Knoten- bzw. Kantenbezeichner entspricht dabei dem Klassennamen. Pflichtattribute müssen unmittelbar, optionale Attribute können nachträglich angegeben werden. Wird ein Schema definiert, erlaubt dies eine Verwendung zusätzlicher API-Methoden für die Selektion von Instanzen anhand ihrer Klasse. Hierbei ist zu beachten, dass die Methoden polymorph sind und folglich auch die Instanzen aller Unterklassen im Ergebnis enthalten sind. Ein Beispiel für die Verwendung der API in Verbindung mit dem Typsystem findet sich in Anhang \ref{list:orientdb_api_example}.

% Algorithmen
Es zeigt sich, dass sich unter Verwendung der Blueprints API beliebige Graphalgorithmen anwendungsseitig implementieren lassen, OrientDB selbst bietet keine Implementierungen an. Innerhalb des Blueprints-Projektes stellt jedoch das Paket Furnace\footnote{\url{https://github.com/tinkerpop/furnace/wiki}} bereits einige Algorithmen zur Verfügung. So werden Suchverfahren, wie der A*-Algorithmus und die Tiefen- bzw. Breitensuche genauso angeboten, wie der Dijkstra- und Bellman-Ford-Algorithmus für das Finden kürzester Pfade in gewichteten Graphen. Neben den Pfadsuchalgorithmen wird mit dem Bron-Kerbosch-Algorithmus\cite{Bron:1973:AFC:362342.362367} auch ein Verfahren zum Auffinden von Cliquen implementiert. Anzumerken ist, dass keines der implementierten Verfahren Einschränkungen hinsichtlich zu berücksichtigender Knoten- oder Kantenklassen zulässt.

\paragraph*{CRUD-Operationen via OrientDB-SQL}

OrientDB verwendet einen eigenen SQL-Dialekt für Schemadefinition, Anfrageformulierung, Datenmanipulation und Nutzerverwaltung. Die Entwickler entschieden sich für SQL, da sie im Bereich der relationalen Datenbanksysteme etabliert ist und den Einstieg in das GDBMS erleichtern soll. Nachfolgend bezeichnet SQL den in OrientDB verwendeten Dialekt, Standard-SQL hingegen bezieht sich auf SQL-92. Es ist nicht Ziel, den Standard komplett zu erläutern, sondern vielmehr auf die Besonderheiten hinsichtlich der graphenorientierten Verwendung in OrientDB einzugehen. Dies erfolgt analog zu Cypher an einem einfachen Beispiel, eine ausführlichere Beschreibung der Sprache findet sich in der offiziellen Dokumentation\cite{Orient_doku:2013} sowie in \cite{tesorierogetting}.

\begin{figure}[h] 
	\centering
		\includegraphics[scale=1]{orientdb_example.pdf}
	\caption[OrientDB: Beispielgraph]{Einfaches Beispiel eines Graphen mit den Knotenklassen \texttt{Employee} und \texttt{Project} sowie den Kantenklassen \texttt{WorksWith}, \texttt{WorksIn} und \texttt{ResponsibleFor}. Die \texttt{WorksWith}-Beziehung besitzt ein zusätzliches Attribut, welches den Erstellzeitpunkt der Beziehung datiert.}
	\label{fig:orientdb_example}
\end{figure}

Abbildung \ref{fig:orientdb_example} zeigt einen schematisierten Graphen, welcher die Beziehungen zwischen Mitarbeitern und Projekten repräsentiert; sowohl Knoten als auch Kanten sind Klassen zugeordnet. Für deren Definition stellt OrientDB den \texttt{CREATE CLASS}-Operator zur Verfügung. Nachfolgend wird eine Klasse \texttt{Employee} erzeugt, dieser wird ein Pflichtattribut \texttt{name} vom Typ \texttt{STRING} und ein optionales Attribut \texttt{age} vom Typ \texttt{INTEGER} zugewiesen. Mit Angabe der Integritätsbedingung \texttt{MIN} erfolgt für Letzteres die Einschränkung zulässiger Werte. Die Klasse selbst erbt von \texttt{V}, welche alle Knoten innerhalb des Graphen repräsentiert. Die Definition der Klasse \texttt{Project} erfolgt analog.

\texttt{CREATE CLASS Employee EXTENDS V;}\newline
\texttt{CREATE PROPERTY Employee.name STRING;}\newline
\texttt{CREATE PROPERTY Employee.age INTEGER;}\newline
\texttt{ALTER PROPERTY Employee.name MANDATORY true;}\newline
\texttt{ALTER PROPERTY Employee.age MIN 18;}

Das Definieren von Kantentypen erfolgt ebenfalls mit dem gezeigten Operator, sie erben jedoch von \texttt{E}, der Klasse aller Kanten. Attribute werden definiert, wie es bereits für Knoten gezeigt wurde. Nachfolgend ist stellvertretend der Befehl für das Anlegen des Kantentyps \texttt{WorksWith} dargestellt:

\texttt{CREATE CLASS WorksWith EXTENDS E;}

Für die Manipulation der Datenbasis stehen in Standard-SQL die Befehle \texttt{INSERT}, \texttt{UPDATE} und \texttt{DELETE} zur Verfügung. Diese werden auch in OrientDB angeboten, \texttt{INSERT} ist jedoch nur für die Verwendung mit Dokumenten vorgesehen, das Erzeugen von Knoten- und Kanteninstanzen erfolgt mit den Befehlen \texttt{CREATE VERTEX} bzw. \texttt{CREATE EDGE}. Die folgende Anweisung fügt dem Graphen eine attributierte Knoteninstanz vom Typ \texttt{Employee} hinzu:

\texttt{CREATE VERTEX Employee SET name=\string"Alice\string", age=25;}

Das Erzeugen einer Kanteninstanz erfordert die Angabe der Identitäten von Start- und Zielknoten, diese können entweder direkt angegeben oder durch eine geschachtelte Selektion gelesen werden. Nachfolgend wird stellvertretend die Instanz der \texttt{WorksWith}-Beziehung zwischen den Mitarbeitern \texttt{Alice} und \texttt{Bob} eingefügt, Kantenattribute können ohne Beachtung der Schemadefinition angefügt werden:

\texttt{CREATE EDGE WorksWith}\newline
\texttt{FROM (SELECT FROM Employee WHERE name=\string"Alice\string")}\newline
\texttt{TO (SELECT FROM Employee WHERE name=\string"Bob\string")}\newline
\texttt{SET since=2011;}

\paragraph*{Mengenorientierte Operationen via OrientDB-SQL}

Die Informationsextraktion erfolgt entweder über den \texttt{SELECT}- oder den \texttt{TRAVERSE}-Operator. Analog zu Standard-SQL können diese beliebig geschachtelt werden. Die folgende Anfrage selektiert die Namen der Mitarbeiter zu denen \texttt{Alice} eine ausgehende Kante vom Typ \texttt{WorksWith} besitzt:

\texttt{SELECT name FROM}\newline
\texttt{(SELECT expand(out(\string"WorksWith\string")) FROM Employee WHERE name=\string"Alice\string");} 

Die Funktion \texttt{out} legt dabei die Richtung der Kante fest und kann wahlweise durch \texttt{in} oder \texttt{both} ersetzt werden. Das Ergebnis der drei Funktionen ist eine Menge von Knoten-Identitäten, deren Instanzen durch \texttt{expand} aufgelöst werden und die damit in übergeordneten Anfragen verwendbar sind.\footnote{Sollen inzidente Kanten-Identitäten selektiert werden, so ist dies mit den Funktionen \texttt{outE}, \texttt{inE} und \texttt{bothE} ebenfalls möglich.} Das gezeigte Beispiel entspricht einer Verbundoperation in einem RDBMS. Der wesentliche Unterschied ist, dass die Beziehungsinformationen materialisiert an Knoten gespeichert sind und nicht zur Laufzeit berechnet werden müssen. Ersetzt man die Projektion der inneren \texttt{SELECT}-Anweisung durch

\texttt{expand(out(\string"WorksWith\string").out(\string"ResponsibleFor\string"))}

werden die Namen der Projekte ausgegeben, für welche die Kollegen von \texttt{Alice} verantwortlich sind. Handelt es sich bei beiden Beziehungen um $n:m$ Relationen, erfordert diese Anfrage in einer relationalen Datenbank vier Verbundoperationen. In OrientDB ist die Berechnung ausschließlich von der Anzahl der Beziehungen zwischen den einzelnen Knoteninstanzen abhängig.

Eine komplexere Anfrage bezieht Kantenattribute ein und selektiert alle Kollegen von \texttt{Bob} mit denen er seit 2012 zusammenarbeitet und welche älter als 25 sind:

\texttt{SELECT since, in.name as name, in.age as age FROM}\newline
\texttt{(SELECT expand(outE(\string"WorksWith\string")) FROM Employee WHERE name=\string"Bob\string")}\newline
\texttt{WHERE since > 2011 AND in.age > 25;}

Die innere Anfrage selektiert mittels \texttt{outE} alle ausgehenden Kanten von \texttt{Bob}, welche anschließend durch das Prädikat \texttt{since > 2011} eingeschränkt werden. Die Funktion \texttt{in} verweist auf die Zielknoten der inzidenten Kanten, diese müssen den Attributschlüssel \texttt{age} mit einem zugehörigen Wert größer als 25 aufweisen.

Die aufgeführten Beispiele zeigen, dass die Selektion durch die optionale Angabe einer \texttt{WHERE}-Klausel möglich ist. OrientDB stellt vergleichende, boolesche und mathematische Operatoren für die Definition und Verknüpfung von Prädikaten zur Verfügung. Diese können in Verbindung mit einzelnen oder mehreren Attributwerten definiert werden. Ein Prädikat berücksichtigt ausschließlich Dokumente, welche das Attribut aufweisen, alle anderen sind nicht in der Ergebnismenge enthalten.\\
Die Projektion ermöglicht die Auswahl einzelner Attribute aus der Ergebnismenge, die Berechnung von Aggregaten und das Ausführen von Funktionen. Verschiedene Aggregatfunktionen, wie zum Beispiel \texttt{count}, \texttt{min}, \texttt{max} und \texttt{avg} stehen zur Verfügung. Analog zu Neo4j erlaubt OrientDB die Verwendung zusätzlicher skalarer, mathematischer, string-basierter und mengenorientierter Funktionen.\footnote{Eine vollständige Übersicht über Operatoren und Funktionen findet sich unter \url{https://github.com/orientechnologies/orientdb/wiki/SQL-Where}.} Die Ergebnismenge kann gruppiert\footnote{In OrientDB 1.5.1 ist die Gruppierung nur für ein Attribut möglich.}, sortiert sowie durch \texttt{SKIP} und \texttt{LIMIT} eingeschränkt werden.

% Traversierung
\paragraph*{Traversierung via OrientDB-SQL}

Das Prüfen der Erreichbarkeit und das Berechnen von Pfaden ist in SQL ebenfalls möglich. Der \texttt{TRAVERSE}-Operator führt eine Traversierung ausgehend von einem konkreten Knoten oder einer Knotenmenge durch. Ein mehrfaches Besuchen von Knoten- und Kanteninstanzen wird durch das GDBMS verhindert, Möglichkeiten einer feingranularen Einstellung wie bei Neo4j oder einer manuellen Definition analog zu HyperGraphDB bestehen nicht. Folgende Anfrage selektiert alle Knoten, die über eine \texttt{WorksWith}-Beziehung mit einem Startknoten verbunden sind und einen maximalen Abstand von drei zu diesem aufweisen:

\texttt{TRAVERSE out(\string"WorksWith\string") FROM \#11:0 WHILE \$depth<=3;}

Der Ausgangsknoten ist hierbei durch seine Identität \texttt{\#11:0} vorgegeben, alternativ können auch Klassen oder eingebettete Anfragen angegeben werden. Die Traversierung definiert einen abstrakten Weg, dessen Kanten gerichtet und vom Typ \texttt{WorksWith} sind. Der Abstand zum Startknoten beträgt höchstens drei und wird sowohl zur Laufzeit als auch im Ergebnis an die Systemvariable \texttt{\$depth} gebunden. Das Ergebnis dieses Operators ist die Menge aller Knoten und Kanten, welche in den Instanzen des beschriebenen Weges enthalten sind. Diese lassen sich in übergeordneten Anfragen weiter verarbeiten:

\texttt{SELECT name, min(\$depth) as dist FROM}\newline
\texttt{(TRAVERSE out(\string"WorksWith\string") FROM \#11:0 WHILE \$depth<=3 STRATEGY breadth\_first)}\newline
\texttt{GROUP BY name ORDER BY dist;}

Die gezeigte Anfrage sortiert alle Kollegen eines Mitarbeiters nach ihrem minimalen Abstand zueinander und listet sie auf. Die \texttt{TRAVERSE}-Operation berechnet unter Verwendung der Breitensuche alle Pfadinstanzen.\footnote{Standardmäßig entspricht die Reihenfolge der zu traversierenden Knoten einem Tiefendurchlauf. Da Knoten jedoch systemseitig nicht mehrfach besucht werden können, weisen die gefundenen Pfadinstanzen nicht zwingend die minimale Länge auf.} Da zwei Mitarbeiter über mehrere Pfade verbunden sein können, werden diese anschließend nach dem Namen des Kollegen gruppiert. Die Projektion schränkt die Ergebnismenge durch Aggregation der Pfadlängen mittels \texttt{min} ein.\\
Die Definition von Filterkriterien hinsichtlich Bezeichnern und Attributen erfolgt mittels Verwendung einer Selektion. Nachfolgend sollen alle Projekte mit denen ein Mitarbeiter direkt oder transitiv verbunden ist, zusammen mit dem Abstand zum Mitarbeiter ausgegeben werden:

\texttt{SELECT name, min(\$depth) FROM}\newline
\texttt{(TRAVERSE both() FROM \#11:0 WHILE \$depth<=4 STRATEGY breadth\_first)}\newline
\texttt{WHERE @Class=\string"Project\string" GROUP BY name;}

In dieser Anfrage werden durch die Verwendung von \texttt{both} ein- und ausgehende Kanten jeglichen Typs traversiert. Die Knotenmenge wird durch das Prädikat \texttt{@Class=\string"Project\string"} auf Projekte eingeschränkt.

Für das Berechnen kürzester Pfade stellt OrientDB die Funktionen \texttt{shortestPath} für ungewichtete und \texttt{dijkstra} für gewichtete Graphen zur Verfügung. Beide Funktionen unterstützen lediglich das Festlegen einer Kantenrichtung, Typ- oder Attributeinschränkungen sind weder für Knoten noch für Kanten möglich.

%\paragraph*{Besonderheiten}
%
%- Hooks (Trigger)
%	- \url{https://github.com/orientechnologies/orientdb/wiki/Hook}
%- Functions 
%	- \url{https://github.com/orientechnologies/orientdb/wiki/Functions}
%	- Stored Procedures in JavaScript
%	- können via REST und auch embedded ausgeführt werden
%	- gegenseitiger Aufruf + Rekursion


%\input{Inhalt/OrientDB_Transactions}

\paragraph*{Indexverwaltung}

OrientDB unterstützt die Verwendung von Indexstrukturen für den effizienten Zugriff auf die gespeicherten Dokumente. Ein Index kann auf einem oder mehreren Attributen definiert werden und besitzt einen eindeutigen Bezeichner. Handelt es sich um ein schematisiertes Attribut, übernimmt das GDBMS die Aktualisierung des Index, bei Attributen, die nicht im Schema definiert sind, erfolgt die Verwaltung hingegen manuell. Es werden Befehle für das Einfügen von Dokumenten, das Ausführen von Punkt- und Bereichsanfragen und das Löschen einzelner oder mehrerer Einträge bereitgestellt. Darüber hinaus kann ein Index vollständig entfernt werden.

Indizes können sowohl via Java API als auch in SQL definiert werden. Der nachfolgende Befehl erzeugt einen mehrdimensionalen Index auf den Attributen \texttt{name} und \texttt{age} eines Mitarbeiters:

\texttt{CREATE INDEX idx1 ON Employee (name, age) UNIQUE;}

Der Indextyp \texttt{UNIQUE} erlaubt die Verwendung als Primärindex. Anzumerken ist, dass mehrdimensionale Indizes auch dann berücksichtigt werden, wenn nur eine der Dimensionen in einer \texttt{WHERE}-Klausel angegeben wird.

OrientDB beinhaltet zwei Index-Implementierungen: MVRB-Baum und Hash-Index. Der MVRB-Baum ist eine von Orient Technologies entwickelte Datenstruktur, welche die Eigenschaften des B$^+$-Baumes mit denen eines Rot-Schwarz-Baumes\cite{ottmann2002algorithmen} kombiniert. Die Struktur unterstützt Punkt- und Bereichsanfragen und kann als Indextyp \texttt{UNIQUE}, \texttt{NONUNIQUE}, \texttt{FULLTEXT} und \texttt{DICTIONARY} verwendet werden.\footnote{\texttt{DICTIONARY} ist identisch zu \texttt{UNIQUE}, existiert beim Einfügen bereits ein entsprechender Eintrag wird dieser jedoch überschrieben.} Indexoperationen sind logarithmisch von der Anzahl der Einträge und der Höhe des Baumes abhängig.\\
Eine zweite Implementierung fußt auf der Verwendung einer Hashtabelle, welche ausschließlich Punktanfragen unterstützt. Indexoperationen sind im Idealfall in konstanter Zeit möglich, die nutzbaren Indextypen sind analog zum MVRB-Baum.
	
\subsection{Persistenz- und Cacheverwaltung}

OrientDB unterstützt zwei Speichermechanismen: \texttt{OStorageLocal} und \texttt{OLocalPaginatedStorage}. Nachfolgend wird die Persistenzverwaltung anhand der Standardeinstellung \texttt{OStorageLocal} erläutert. Laut Aussage der Entwickler soll \texttt{OLocalPaginatedStorage} in einer der folgenden Versionen die standardmäßige Implementierung sein\cite{Orient_acid:2013}, die offizielle Dokumentation enthält bisher - Stand Oktober 2013 - jedoch keine detaillierten Informationen über den Speichermechanismus.

Knoten und attributierte Kanten werden auf Dokumente abgebildet, die innerhalb der Speicherschicht als \textit{Record} bezeichnet werden, ein Record ist genau einem \textit{Cluster} zugeordnet. Ein Cluster ist die physische Gruppierung von Records anhand einer definierten Eigenschaft, dies kann der Typ oder ein beliebiges Attribut des Dokumentes sein. Bei der Verwendung des Typsystems wird für jede Klasse automatisch ein Cluster erzeugt.\footnote{Wird auf ein Schema verzichtet, werden alle Dokumente einem Cluster zugeordnet.} Darüber hinaus erlaubt das GDBMS aber auch das manuelle Zuweisen mehrerer Cluster zu einer Klasse:

\texttt{CREATE CLUSTER Projects2012;}\newline
\texttt{CREATE CLUSTER Projects2013;}\newline
\texttt{CREATE CLASS Project EXTENDS V CLUSTER Projects2012,Projects2013;}\newline
\texttt{CREATE VERTEX Project CLUSTER Projects2012 SET year=2012;}\newline
\texttt{CREATE VERTEX Project CLUSTER Projects2013 SET year=2013;}\newline
\texttt{SELECT FROM Project WHERE year=2013; // scans all clusters}\newline
\texttt{SELECT FROM cluster:Project2013; // scans one cluster}

In diesem Beispiel sind der Klasse \texttt{Project} zwei Cluster zugewiesen: \texttt{Projects2012} und \texttt{Projects2013}. Zwei Knoteninstanzen werden erzeugt und ihrem entsprechenden Cluster zugeordnet. Die gezeigten Leseanfragen besitzen eine identische Ergebnismenge, die zweite Anfrage kann jedoch effizienter ausgeführt werden, da lediglich ein Cluster berücksichtigt werden muss. Folglich lässt sich durch Cluster eine semantische Gruppierung physisch abbilden. An dieser Stelle wird auch deutlich, warum OrientDB das Verwenden eines Schemas empfiehlt: Knoten und Kanten werden im Speichersystem nach Typ gruppiert verwaltet, wodurch entsprechend eingeschränkte Anfragen effizienter beantwortet werden können.\\
Die Identität eines Records, die sog. \textit{RecordID}, setzt sich aus der Identität des Clusters und der absoluten Position des Records innerhalb des Clusters zusammen: Ist zum Beispiel der Knoten \texttt{Alice} an Position 37 im Mitarbeiter-Cluster mit der Identität 13 gespeichert, dann ist die RecordID \texttt{\#13:37}.

Wie bei Neo4j wird die Datenbasis in OrientDB auf mehrere Dateien aufgeteilt. Hierbei erfolgt jedoch keine explizite Trennung in Topologie und Nutzdaten, stattdessen orientiert sich die Speicherung am Dokumentenmodell. Ein Cluster wird durch eine oder mehrere Dateien repräsentiert. Jeder Eintrag innerhalb eines Clusters besitzt ein festes Format, was bedeutet, dass analog zu Neo4j die Berechnung der physischen Position effizient möglich ist. Im Cluster werden keine Nutzdaten gespeichert, sie dienen lediglich der Gruppierung von Records, Cluster-Einträge verweisen auf deren Nutzdaten. Diese befinden sich in der zweiten Komponente des Speichersystems, dem \textit{Data Segment}. 

\begin{figure}[h] 
	\centering
		\includegraphics[scale=0.75]{orientdb_cluster_record.pdf}
	\caption[OrientDB: Datensatz eines Clusters]{Physische Repräsentation eines Eintrags in einem Cluster in OrientDB. Der Datensatz hat eine feste Länge von 15 Byte.\footnote{\url{https://github.com/orientechnologies/orientdb/blob/1.5.1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/OClusterLocal.java?source=cc}}}
	\label{fig:orientdb_cluster_record}
\end{figure}

Abbildung \ref{fig:orientdb_cluster_record} zeigt den schematischen Aufbau eines Satzes in einem Cluster:
Die ersten zwei Byte verweisen auf das Data Segment, in welchem die Nutzdaten zu diesem Record hinterlegt sind, die nachfolgenden acht Byte legen die physische Position innerhalb des Data Segment fest. Die letzten fünf Byte speichern Typ\footnote{Damit ist nicht der Datentyp gemeint. Ein Record kann entweder ein Dokument oder ein sog. Plain-Objekt sein. Letzteres ist für die Evaluation nicht relevant.} und Version des Dokumentes. Beim Löschen eines Datensatzes wird dessen Position in einer zusätzlichen Datei vermerkt und steht für neue Dokumente zur Verfügung.

Das Data Segment speichert die Nutzdaten eines Record, es wird ebenfalls durch eine oder mehrere Dateien repräsentiert. Da die an einem Dokument hinterlegten Informationen individuell verschieden sein können, ist auch die Länge eines Datensatzes variabel. Abbildung \ref{fig:orientdb_datasegment_record} zeigt dies schematisch.

\begin{figure}[h] 
	\centering
		\includegraphics[scale=0.75]{orientdb_datasegment_record.pdf}
	\caption[OrientDB: Datensatz eines Datensegmentes]{Physische Repräsentation eines Eintrags im Data Segment zur Speicherung der Nutzdaten. Der statische Teil des Datensatzes hat eine Länge von 14 Byte, der dynamische Teil variiert je nach Umfang der hinterlegten Daten.}
	\label{fig:orientdb_datasegment_record}
\end{figure}

Ein Datensatz besteht aus einem Abschnitt fester Länge und einem dynamischen Teil, welcher je nach Umfang der Nutzdaten verschieden groß sein kann.\footnote{Nachzuvollziehen unter \url{https://github.com/orientechnologies/orientdb/blob/1.5.1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/ODataLocal.java}.} Die ersten vier Byte speichern die Länge der Nutzdaten. Diese Information ermöglicht es, die Rohdaten aus dem Datensatz zu extrahieren um sie anschließend zu deserialisieren. Die nachfolgenden zehn Byte sind ebenfalls fest vergeben und enthalten Informationen über das zugeordnete Cluster. Der Rest des Datensatzes ist für die Speicherung der Rohdaten vorgesehen.

Das Auslesen der physischen Adressen im Cluster und im Datensegment ist in konstanter Zeit möglich.
Daraus ergibt sich, dass sich die Nachbarschaft eines Knotens $v$ in $\mathcal{O}(\left|N_v\right|)$ berechnen lässt. Dabei ist jedoch zu beachten, dass Beziehungsinformationen ebenfalls als Attribute in einem Dokument hinterlegt sind. Beim Lesen eines Records werden die kompletten Rohdaten geladen\footnote{Nachzuvollziehen unter \url{https://github.com/orientechnologies/orientdb/blob/1.5.1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/ODataLocal.java?source=cc\#L248}}, das Deserialisieren der Nutzdaten erfolgt jedoch erst beim Zugriff auf das entsprechende Attribut.\footnote{Nachzuvollziehen unter \url{https://github.com/orientechnologies/orientdb/blob/1.5.1/core/src/main/java/com/orientechnologies/orient/core/record/impl/ODocumentHelper.java?source=c\#L224}.}  Folglich müssen beim Traversieren des Graphen die kompletten Rohdaten gelesen und die angefragten Kanten deserialisiert werden. Weiterhin stellen attributierte Kanten eine zusätzliche Indirektion dar, da sie in einem dedizierten Dokument, und damit auch in einem physisch unabhängigen Record, gespeichert sind.

Beim Löschen eines Datensatzes im Data Segment werden Position und Länge des Satzes in einer zusätzlichen Datei hinterlegt, der somit definierte Bereich steht als freier Speicher zur Verfügung. Aus der dynamischen Länge des Satzes ergeben sich weitere Problemstellungen: Beim Aktualisieren eines Dokumentes kann der zur Verfügung stehende Speicher zu gering sein, das Löschen führt zur Entstehung von freien Bereichen unterschiedlicher Länge. Das GDBMS implementiert hierfür eine Freispeicherverwaltung und eine automatische Defragmentierung. Eine detaillierte Betrachtung dieser Prozesse geht über den Rahmen dieser Arbeit hinaus, kann jedoch bei Interesse anhand des Quelltextes nachvollzogen werden.

Eine dritte Komponente des Speichersystems ist der \textit{Storage}. Dieser nimmt Anfragen der Datenbankschicht entgegen und verwaltet den Zugriff auf Cluster und Data Segments.% Abbildung \ref{fig:orientdb_storage_sequence} fasst die Funktionsweise der Persistenzverwaltung am Beispiel des Lesens eines Dokumentes zusammen.

\paragraph*{Cacheverwaltung}

Für den effizienten wahlfreien Zugriff auf deserialisierte Dokumente verwendet OrientDB mehrere Caches. Nachfolgend wird die Architektur im Kontext der eingebetteten Verwendung erläutert.

Records werden aus dem Speichersystem geladen, deserialisiert und im Level-2-Cache abgelegt. Dabei handelt es sich um einen First-In-First-Out-Cache, welcher durch eine Hashtabelle mit verketteten Schlüsseln realisiert wird.\footnote{Es handelt sich um eine Erweiterung der Java-Datenstruktur \texttt{LinkedHashMap}. Dies kann unter \url{https://github.com/orientechnologies/orientdb/blob/1.5.1/core/src/main/java/com/orientechnologies/orient/core/cache/ODefaultCache.java?source=cc} nachvollzogen werden.} Der maximal nutzbare Hauptspeicher wird manuell festgelegt, bei Überschreitung dieser Grenze wird ein definierter Anteil der ältesten Einträge verdrängt. Alle Threads innerhalb der JVM können auf den Level-2-Cache zugreifen. Noch dazu ist jedem Thread ein dedizierter Level-1-Cache zugeordnet. Dieser wird durch eine Hashtabelle und die Verwendung schwacher Referenzen realisiert.

Ein Lesezugriff prüft zunächst, ob das angeforderte Dokument im Level-1-Cache vorhanden ist. Ist dies nicht der Fall, erfolgt der Zugriff auf den Level-2-Cache. Befindet sich das Dokument dort, wird es in den Level-1-Cache bewegt. Ist das Dokument in keinem der Caches vorhanden, erfolgt der Zugriff auf das Speichersystem, welches einen eigenen Cache besitzt, in dem die Ergebnisse von Lesezugriffen zwischengespeichert werden. Erst wenn der Record in diesem Cache nicht vorhanden ist, erfolgt der Zugriff auf den Hintergrundspeicher. Wie bereits erwähnt, verwendet \texttt{OStorageLocal} Memory Mapped Files für die Abbildung der Daten auf den Externspeicher. Dies kann dazu führen, dass ein Lesezugriff ebenfalls aus dem Hauptspeicher beantwortet wird. 

%Durch die client-seitige Ausführung von Transaktionen werden Änderungen an Dokumenten nicht unmittelbar im Cache reflektiert, die Aktualisierung erfolgt erst nach erfolgreicher Beendigung der Transaktion. Auf Grund der Verwendung eines dedizierten Level-1-Caches pro Thread kann jedoch der Fall eintreten, dass sich ein Dokument in verschiedenen Versionen in mehreren Level-1-Caches befindet. Um diesem Problem zu begegnen, kann entweder der Level-1-Cache deaktiviert oder das Zwischenspeichern eines Dokumentes explizit verboten werden. Bei der Verwendung mehrerer JVMs in Verbindung mit einer gemeinsamen physischen Speicherschicht gilt gleiches auch für den Level-2-Cache.

\subsection{Verteilung und Skalierbarkeit}

OrientDB lässt sich als verteiltes GDBMS einsetzen und unterstützt dabei die vollständige Replikation der Datenbasis. Realisiert wird dies durch Hazelcast\footnote{\url{http://www.hazelcast.com/}}, einer quelloffenen, skalierbaren Verteilungsplattform für Java-Anwendungen. Anders als Neo4j verwendet OrientDB eine Muli-Master-Architektur\cite{rahm_masterslave}. Diese zeichnet sich dadurch aus, dass alle Rechner im Cluster gleichberechtigt sind, d.h. Lese- und insbesondere Schreibzugriffe können an allen Rechnern direkt ausgeführt werden. Nachfolgend wird die Architektur anhand der internen Ausführung von Änderungs- und Lesetransaktionen kurz beschrieben.\footnote{Die offizielle Dokumentation enthält bezüglich der Datenverteilung nur wenig Informationen. Die vollständige Evaluation des Quelltextes würde das Gewicht der Verteilung innerhalb der Evaluation nicht rechtfertigen.}

Erhält eine Instanz eine Änderungstransaktion, führt sie diese zunächst lokal durch. Anschließend erfolgt die Verteilung der Änderungen nach dem Push-Prinzip entweder synchron oder asynchron. Im synchronen Fall erhält der Client erst dann eine Bestätigung, wenn die Änderungen an allen Instanzen durchgeführt sind und folglich eine konsistente Sicht auf die Daten innerhalb des Clusters besteht. Im asynchronen Fall erfolgt die Bestätigung unmittelbar nachdem die Daten lokal geschrieben wurden, die Replikation der Änderungen erfolgt parallel bzw. verzögert. Dies entspricht dem Konzept der Eventual Consistency, bei der das GDBMS für jede Instanz eine letztendlich konsistente Sicht auf die Daten garantiert.\\
Das Ausführen von Lesezugriffen ist ebenfalls an allen Rechnern im Cluster möglich. Erfolgt die Replikation von Änderungen asynchron, können gelesene Daten eventuell veraltet sein, bei einer synchronen Replikation hingegen werden stets die aktuellen Daten gelesen.

Jede GDBMS-Instanz besitzt Informationen über alle weiteren Teilnehmer im Cluster, gleiches gilt auch für Client-Anwendungen. Beim Entfernen oder Hinzufügen einer Instanz wird die zugehörige Information an alle beteiligten Rechner propagiert. Dies bedeutet, dass sich Clients beim Ausfall einer GDBMS-Instanz automatisch zu einer neuen Instanz verbinden und die Kommunikation fortsetzen können. Tritt eine neue Instanz dem Cluster bei, sendet diese zunächst eine Anfrage zum Datenabgleich mit dem Verbund. Der Abgleich erfolgt auf Basis der Log-Informationen mit einer der verfügbaren Instanzen, welche der neuen Instanz die entsprechende Differenzmenge an Änderungen zusendet.

% Skalierbarkeit
\paragraph*{Skalierbarkeit}

Die Multi-Master-Replikation erlaubt das horizontale Skalieren von Lese- und Schreibzugriffen. Zu beachten ist jedoch, dass dies für Schreibzugriffe nur im Fall einer asynchronen Replikation und auch da nur eingeschränkt gilt. Änderungsoperationen müssen an allen Instanzen durchgeführt werden, was je nach Anzahl der Rechner zu einer hohen Antwortzeit und somit bei hoher Schreiblast zu Performance-Problemen führen kann. Darüber hinaus muss die Korrektheit paralleler Schreibzugriffe generell und insbesondere auch beim Ausfall mehrerer Rechner sichergestellt sein, insbesondere bezüglich des maximalen Datenvolumens ist die Architektur ausschließlich vertikal skalierbar, da die Datenbasis an allen Instanzen komplett hinterlegt ist. Eine Partitionierung des Graphen wird aktuell entwickelt, ist jedoch weder dokumentiert noch in einer stabilen Version verfügbar.\footnote{Der aktuelle Entwicklungsstand kann unter \url{https://github.com/orientechnologies/orientdb/tree/1.5.1/distributed/src/main/java/com/orientechnologies/orient/server/hazelcast} eingesehen werden.}