\section{OrientDB}

% Firma + Lizenz
OrientDB ist ein quelloffenes GDBMS, das von der Firma Orient Technologies\footnote{\url{http://www.orientechnologies.com
}} entwickelt wird. Der Quellcode steht unter Apache 2.0 Lizenz\footnote{\url{http://www.apache.org/licenses/LICENSE-2.0.html}}, was bedeutet, dass er in freien, aber auch auch in kommerziellen Anwendungen verwendet werden darf. Das GDBMS wurde 2010 veröffentlicht, die erste stabile Version 1.0 erschien 2012. Für die Implementierung wird ausschließlich Java verwendet, die Ausführung ist somit analog zu Neo4j und HyperGraphDB an die JVM gebunden und auf kompatiblen Plattformen möglich. OrientDB ist ein Graphdatenbanksystem, in dem Modellierung und Zugriff graphenorientiert erfolgen, für die Speicherung wird ein dokumentorientiertes Speicherkonzept eingesetzt.\\
Das GDBMS lässt sich in Java-Anwendungen einbetten oder alternativ in einer Client-Server-Konfiguration verwenden, entsprechende Clients stehen zur Verfügung.\footnote{Für den Zugriff via Rest wird eine Vielzahl von Client-Implementierungen angeboten. Diese sind unter \url{https://github.com/orientechnologies/orientdb/wiki/Programming-Language-Bindings} gelistet. Ein Binärprotokoll wird ebenfalls angeboten, jedoch aktuell nur von C/C++, PHP und nodejs unterstützt: \url{https://github.com/orientechnologies/orientdb/wiki/Network-Binary-Protocol}.} Neben einer zentralen Verwendung ist auch der Einsatz als verteiltes System möglich. Hierfür wird eine Master-Master-Replikation realisiert, die eine horizontale Skalierbarkeit von Lese- und Schreibanfragen sowie eine erhöhte Ausfallsicherheit verspricht. Die Speicherung der Datenbasis erfolgt disk-zentriert, das System bietet zwar die ausschließliche Nutzung des Hauptspeichers an, dies entspricht jedoch nicht der definierten hauptspeicher-zentrierten Speicherung, sondern ist für die Verwendung im Rahmen von Unit-Tests vorgesehen.

% Besonderheiten (Dokumente, Typsystem) + Anwendungsfall
Eine besonderes Merkmal von OrientDB ist die Möglichkeit, die Datenbank mit verschiedenen Datenmodellen nutzen zu können. Die Speicherung der Informationen erfolgt grundlegend in Form von Dokumenten. Ein darauf aufbauendes graphenorientiertes Datenmodell ermöglicht die Definition von Beziehungen zwischen Dokumenten. Darüber hinaus lässt sich OrientDB als objektorientiertes Datenbanksystem einsetzen, wobei Objektinstanzen ebenfalls auf Dokumente abgebildet werden. In allen drei Datenmodellen ist die Definition eines Schemas zur Modellierung einer Anwendungsdomäne und zur Festlegung von Integritätsbedingungen möglich. Der vollständige Verzicht auf ein Schema und die Kombination eines Schemas mit semi-strukturierten Daten wird hingegen ebenfalls unterstützt. Weitere Alleinstellungsmerkmale sind die Verwendung und Erweiterung des SQL-Standards und die systemseitige Implementierung einer Rechteverwaltung.

% Ausführungen beziehen sich auf ... + Quellen
Die nachfolgende Evaluation basiert auf der im September 2013 freigegebenen Version 1.5.1. Der Großteil der Informationen stammt aus den Ausführungen zu OrientDB in \cite{EdlichFriedlandHampeBrauer201010}, \cite{tesorierogetting} und der offiziellen Dokumentation\cite{Orient_doku:2013}. Es werden ausschließlich das Dokumenten- und das darauf aufbauende Graphdatenmodell berücksichtigt, da insbesondere letzteres für die Evaluation relevant ist.

\subsection{Datenmodell, Typsystem und Rechteverwaltung}

Die Basiseinheit zur Darstellung von Informationen ist das \textit{Dokument}, welches sich aus einer Menge von Schlüssel-Wert-Paaren zusammensetzt. Schlüssel sind innerhalb eines Dokumentes eindeutige Bezeichner vom Typ \texttt{String}, zugehörige Werte sind typisiert und dienen zur Speicherung der Nutzdaten. Das System unterstützt eine Vielzahl vordefinierter Typen, wie zum Beispiel \texttt{int} oder \texttt{float}, und erlaubt darüber hinaus die Definition eigener Typen.\footnote{Eine Liste aller vordefinierter Datentypen kann unter \url{https://github.com/orientechnologies/orientdb/wiki/Types} eingesehen werden.} Ein Wert kann auch ein Dokument bzw. eine Menge von Dokumenten sein, wodurch sich beliebige Einbettungen realisieren lassen.

% Graphenmodell
Für die Modellierung von Graphen bietet OrientDB das Property-Graph-Modell an. Dieses kann entsprechend der Definition schemalos verwendet werden, analog zu Neo4j wird jedoch die Definition eines Schemas empfohlen um das Formulieren von Anfragen zu vereinfachen und gleichzeitig deren effizientere Ausführung zu ermöglichen. Die Knoten innerhalb des Graphen und ihre Attribute werden auf Dokumente abgebildet. Ist die Vergabe von Knotenbezeichnern erforderlich, kann dies entweder durch ein dediziertes Schlüssel-Wert-Paar oder durch die Zuordnung des Knotens zu einer \textit{Klasse} erfolgen.

Für die Repräsentation von Beziehungen unterscheidet OrientDB zwei Arten: Referenzierte und eingebettete Beziehungen. Beziehungsinformationen werden generell als Schlüssel-Wert-Paare am Knoten abgelegt. Eine referenzierte Beziehung entspricht dem Konzept einer gerichteten Kante. Der Schlüssel ist der Kantenbezeichner, welcher sich aus dem Typ der entsprechenden Kante ergibt. Werden keine Kantenattribute verwendet, so ist der zugehörige Wert die Menge der Identitäten aller Zielknoten, die über eine entsprechend bezeichnete Kante mit dem Startknoten verbunden sind. Besitzt die Kante hingegen Attribute, so wird sie durch ein eigenes Dokument in der Datenbasis repräsentiert. Der Wert am Startknoten ist in diesem Fall eine Menge der Kanten-Identitäten. In beiden Fällen kann diese Menge unsortiert oder geordnet sein. Die Zielknoten enthalten ebenfalls dedizierte Schlüssel-Wert-Paare, welche Informationen über die eingehenden Kanten speichern. Auch hier wird entweder direkt auf Startknoten oder auf Kanten-Dokumente verwiesen.\footnote{Die dargelegten Informationen basieren auf der Untersuchung der physischen Repräsentation des in Anhang \ref{anh:domain_example} gezeigten Beispiels.} Daraus geht hervor, dass auch in OrientDB eine einzelne Kante zur Darstellung einer bidirektionalen Beziehung ausreicht.

Eine zweite Art, Abhängigkeiten zwischen Informationen zu modellieren, ist die Verwendung eingebetteter Beziehungen. Diese werden üblicherweise in dokumentenorientierten Datenbanken eingesetzt in denen das Konzept der Fremdschlüssel nicht vorhanden ist. Die Beziehung zwischen zwei Objekten A und B wird durch das Einbetten von B in A oder umgekehrt modelliert und ist vergleichbar mit der Komposition in der UML. Das eingebettete Objekt besitzt keine eigene Identität innerhalb der Datenbasis. Der Schlüssel bezeichnet die Art der Beziehung, der Wert die referenzierte Information. Sollen mehrere Werte mit dem gleichen Schlüssel eingebettet werden, so ist dies analog zu referenzierten Beziehungen in geordneten Listen oder unsortierten Mengen möglich. Generell bietet sich diese Art der Modellierung an, wenn die eingebetteten Informationen nur für den jeweiligen Knoten relevant sind und nicht mehreren Knoteninstanzen zugeordnet sein können. Letzteres würde zu Redundanz führen und folglich die Konsistenzerhaltung erschweren.

% Identität
Die Identität eines Dokumentes wird systemseitig vergeben und ist unveränderbar. Dokumente können mittels ihrer Identität adressiert werden, sie entspricht somit dem Konzept des Primärschlüssels. Aus den vorhergehenden Ausführungen geht hervor, dass sowohl Knoten als auch Kanten in Form von referenzierten Beziehungen eine Identität besitzen. Bei nicht-attributierten Kanten setzt sich diese aus den Identitäten der Start- und Zielknoten zusammen. Anzumerken ist, dass eine Identität nach dem Löschen der zugehörigen Instanz neu vergeben werden kann. Der detaillierte Aufbau wird im Zusammenhang mit der physischen Repräsentation des Graphen erläutert.

% Datenbank
Im Gegensatz zu den bisher vorgestellten GDBMS erlaubt OrientDB das Verwalten mehrere Datenbanken in einer GDBMS-Instanz. Dabei benötigt jede Datenbank einen eindeutigen Bezeichner, ein Datenbank-übergreifender Zugriff innerhalb von Anfragen ist jedoch nicht möglich. Beim Initialisieren einer Datenbank kann festgelegt werden, ob sich diese lokal im Dateisystem oder entfernt im Netzwerk befindet, alternativ kann sie für Testzwecke komplett im Hauptspeicher gehalten werden.

\paragraph*{Typsystem} 

Anzahl und Struktur der Schlüssel-Wert-Paare können für jedes Dokument individuell verschieden sein oder aber durch ein Schema festgelegt werden. Darüber hinaus ist es in OrientDB möglich, nur einen Teil der Informationen durch ein Schema zu beschreiben und dieses beliebig zu erweitern. Folglich ist auch hier eine hohe Flexibilität hinsichtlich der Schemaevolution innerhalb einer Anwendung gegeben.\\
Ein Schema definiert sich in OrientDB durch eine Menge von Klassen, wobei eine Klasse an das entsprechende Konzept in der Objektorientierung angelehnt ist. Eine Klasse legt den Typ eines Dokumentes fest und definiert, welche Attribute dieses besitzt und welche Integritätsbedingungen sie aufweisen. Beispielweise kann der Wertebereich durch den entsprechenden Typ implizit eingeschränkt werden. Darüber hinaus lassen sich Wertebereiche numerischer Datentypen durch das Angeben von Intervallen oder im Fall von alphanumerischen Typen durch das Formulieren regulärer Ausdrücke explizit einschränken. Zusätzlich lässt sich festlegen, ob ein Attribut obligatorisch ist und ob es den Wert \texttt{null} annehmen darf. Wird ein Attribut als \texttt{UNIQUE} deklariert, erzeugt das System einen Index und das Attribut kann neben der eigentlichen Identität des Dokuments als Primärschlüssel verwendet werden. Durch das Konzept der eingebetteten Beziehungen können auch Typen verschachtelt werden um die Struktur entsprechender Dokumente beschreiben zu können.

Das Modellieren von Vererbungshierarchien ist ebenfalls möglich: Attribute von Oberklassen werden an alle Unterklassen weitergegeben, eine Einschränkung der Sichtbarkeit ist nicht vorgesehen. OrientDB erlaubt das Anlegen abstrakter Klassen, welche analog zur Objektorientierung nicht instanziiert werden, sondern ausschließlich Attribute für ihre Spezialisierungen vorgeben. Mehrfachvererbungen sind generell nicht möglich.

\paragraph*{Rechteverwaltung} Als einziges der evaluierten Systeme bietet OrientDB eine integrierte Nutzer- und Rollenverwaltung auf Datenbankebene an. Ein Nutzer wird durch einen Namen und ein optionales Passwort identifiziert und besitzt eine oder mehrere Rollen. Eine Rolle definiert sich wiederum durch eine Menge von Regeln die entweder nach Whitelist-Prinzip erlaubt oder nach Blacklist-Prinzip verboten werden. Eine Rolle \texttt{Reader} verbietet zum Beispiel alle Regeln bis auf das Lesen anwendungsspezifischer Datenbanken, wohingegen eine Rolle \texttt{Writer} alles erlaubt bis auf das Lesen und Schreiben von Nutzerinformationen. Innerhalb des Systems existiert ein Nutzer \texttt{admin} dessen Rolle alle Regeln erlaubt. Da Rollen selbst in Form typisierter Dokumente verwaltet werden, unterstützen sie auch das Konzept der Vererbung. Die Granularität einer Regel lässt sich standardmäßig bis auf Klassenebene einstellen, durch das Erben einer dedizierten Klasse erlaubt OrientDB darüber hinaus eine Rechteverwaltung auf Instanzebene. Letzteres ist insbesondere dann sinnvoll, wenn innerhalb einer Datenbank nutzerabhängige Sichten auf den Graphen definiert werden sollen. Die im Forschungsprojekt beschriebene Verwaltung extrahierter Teilgraphen in einer Datenbasis ist somit realisierbar. Mit einer entsprechenden Rolle sind Teilgraph-übergreifende Anfragen möglich.

\subsection{Zugriffsmechanismen, Transaktionen und Indexverwaltung}

Das GDBMS bietet mehrere Optionen für den Zugriff auf die Datenbasis: Wie HyperGraphDB und Neo4j enthält auch OrientDB eine Java API für die Verwaltung des Graphen mittels CRUD-Operationen. Hierfür implementiert das GDBMS die Blueprints API\footnote{An dieser Stelle sei angemerkt, dass es sich bei der Blueprints API um einen Quasi-Standard für GDBMS handelt. Viele Anbieter, u.a. Neo4j, Dex und InfiniteGraph, bieten neben ihren proprietären APIs eine Implementierung der Blueprints API an. Diese Implementierung bildet CRUD-Operationen auf die jeweilige proprietäre API ab und stellt somit eine zusätzliche Indirektion im Aufruf dar. Teilweise kann hierdurch nicht der volle Funktionsumfang des GDBMS genutzt werden. OrientDB und Titan implementieren die Blueprints API hingegen nativ, was bedeutet, dass Aufrufe unmittelbar an das GDBMS weitergegeben werden und der komplette Funktionsumfang zur Verfügung steht. Eine Beschreibung der API kann unter \url{https://github.com/tinkerpop/blueprints/wiki} eingesehen werden.}, eine im TinkerPop-Projekt definierte Referenz-Schnittstelle für das PGM.\footnote{OrientDB enthält auch eine eigene Core API, diese wurde jedoch in Version 1.4 als veraltet deklariert und wird folglich in der Evaluation nicht betrachtet.} Infolgedessen lässt sich auch die Anfragesprache Gremlin in OrientDB verwenden. Die primäre Anfragesprache ist jedoch der deklarative OrientDB-SQL-Dialekt, welcher einen Teil des SQL-92-Standards\cite{SQL_92:2013} übernimmt und mit graphenspezifischen Operatoren erweitert.\footnote{Zu beachten ist, dass der Orient-SQL-Dialekt nicht mit dem ANSI SQL Standard konform ist\cite{tesorierogetting}.}

\paragraph*{CRUD-Operationen via Blueprints API}

Die Blueprints API ist eine imperative Java API und der Core API von Neo4j sehr ähnlich. Es stehen Methoden zum Erzeugen und Lesen von Knoten und Kanten zur Verfügung, deren Ergebnis ist eine Referenz auf das persistente Objekt mit einer eindeutigen Identität. Kanten können nur unter Angabe existierender Knoten erzeugt werden, ihre Reihenfolge bei der Parameterangabe bestimmt die Kantenrichtung. Die Spezifikation eines Kantenbezeichners ist obligatorisch, dieser ist ein Wert vom Typ \texttt{String} und kann folglich statisch in der Anwendung oder dynamisch zur Laufzeit festgelegt werden. Sowohl Knoten als auch Kanten verfügen über Methoden zum Anlegen von Attributen, werden Arrays, Mengen oder assoziative Arrays unterstützter Datentypen als Wert angegeben, erzeugt das GDBMS automatisch eine eingebettete Beziehung. Knoten- und Kantenattribute können aktualisiert oder gelöscht werden. Knoten verfügen über zusätzliche Funktionen zum Auslesen inzidenter Kanten und adjazenter Knoten, Kanten verfügen wiederum über Methoden zum Auslesen von Start- und Zielknoten sowie ihres Bezeichners. Sowohl Knoten als auch Kanten lassen sich aus der Datenbasis entfernen, dabei stellt das GDBMS die referentielle Integrität sicher.

% Vertex Query
Für das Formulieren lokaler Anfragen innerhalb des Graphen bietet die Blueprints API das Konzept der Knoten-zentrierten Anfragen, bei denen der Graph aus der Sicht eines Knotens untersucht werden kann. Das Konzept bietet die Möglichkeit, die Menge der inzidenten Kanten eines Knotens durch die Angabe von Richtung, Bezeichner und Prädikaten auf Attributen einzuschränken. Vorteil der Einschränkung ist eine Minimierung der Datenmenge, die vom Hintergrundspeicher geladen werden muss. Dies ist insbesondere dann relevant, wenn es sich um Knoten mit einem überdurchschnittlich hohen Grad handelt, welche typischerweise in realen Netzwerken vorkommen und als Hubs bezeichnet werden\cite{Newman:2010:NI:1809753}. Voraussetzung ist jedoch, dass das jeweilige GDBMS eine Einschränkung der inzidenten Kanten unterstützt. In OrientDB sind Kanten anhand ihres Bezeichner innerhalb eines Dokumentes gruppiert gespeichert, eine Indexierung von Kantenattributen ist jedoch nicht möglich.

% Klassen
OrientDB erweitert die API um Methoden zum Verwalten von Klassen. Diese werden unter Angabe eines Namens erzeugt, anschließend lassen sich Attributdefinitionen, bestehend aus Attributname und Typ sowie eventueller Integritätsbedingungen, für die Klasse festlegen. Wird diese als strikt deklariert, sind alle Attribute obligatorisch und müssen von den Instanzen angegeben werden. Eine Klasse ohne jegliche Attribute entspricht hingegen dem Konzept des Knotenlabels in Neo4j. Beim Erzeugen einer Klasse kann diese als abstrakt deklariert und wahlweise eine Oberklasse angegeben werden. Die Zuordnung einer Knoten- oder Kanteninstanz zu einer Klasse erfolgt beim Erzeugen, der Knoten- bzw. Kantenbezeichner entspricht dabei dem Klassennamen; Pflichtattribute müssen unmittelbar, optionale Attribute können nachträglich angegeben werden. Wird ein Schema definiert, erlaubt dies die Verwendung zusätzlicher API-Methoden für die Selektion von Instanzen anhand ihrer Klasse. Hierbei ist zu beachten, dass die Methoden polymorph sind und folglich auch die Instanzen aller Unterklassen im Ergebnis enthalten sind. Ein Beispiel für die Verwendung der API in Verbindung mit dem Typsystem findet sich in Anhang \ref{anh:orientdb_blueprints_api}.

% Algorithmen
Aus den Ausführungen geht hervor, dass sich unter Verwendung der Blueprints API beliebige Graphalgorithmen anwendungsseitig implementieren lassen, OrientDB selbst bietet keine Implementierungen an. Innerhalb des Blueprints-Projektes stellt jedoch das Paket Furnace\footnote{\url{https://github.com/tinkerpop/furnace/wiki}} bereits einige Algorithmen zur Verfügung. So werden Suchverfahren, wie der A*-Algorithmus und die Tiefen- bzw. Breitensuche, genauso angeboten, wie der Dijkstra- und Bellman-Ford-Algorithmus für das Finden kürzester Pfade in gewichteten Graphen. Neben den Pfadsuchalgorithmen wird mit dem Bron-Kerbosch-Algorithmus\cite{Bron:1973:AFC:362342.362367} auch ein Verfahren zum Auffinden von Cliquen implementiert. Anzumerken ist, dass keines der implementierten Verfahren Einschränkungen hinsichtlich zu berücksichtigender Knoten- oder Kantenklassen zulässt.

\paragraph*{CRUD-Operationen via OrientDB-SQL}

OrientDB verwendet einen eigenen SQL-Dialekt für Schemadefinition, Anfrageformulierung, Datenmanipulation und Nutzerverwaltung. Die Entwickler entschieden sich für SQL, da es eine im Bereich der relationalen Datenbanksysteme etablierte Sprache ist und den Einstieg in das GDBMS erleichtern soll. Nachfolgend bezeichnet SQL den in OrientDB verwendeten Dialekt, Standard-SQL hingegen bezieht sich auf SQL-92. Ziel ist es nicht, den Standard komplett zu erläutern, sondern auf die Besonderheiten hinsichtlich der graphenorientierten Verwendung in OrientDB einzugehen. Dies erfolgt analog zu Cypher an einem einfachen Beispiel und bezieht sich dabei ausschließlich auf das Graphdatenmodell. Eine ausführlichere Beschreibung der Sprache findet sich in der offiziellen Dokumentation\cite{Orient_doku:2013} sowie in \cite{tesorierogetting}.

\begin{figure}[h] 
	\centering
		\includegraphics[scale=1]{orientdb_example.pdf}
	\caption[OrientDB: Beispielgraph]{Einfaches Beispiel eines Graphen mit den Knotenklassen \texttt{Employee} und \texttt{Project} sowie den Kantenklassen \texttt{WorksWith}, \texttt{WorksIn} und \texttt{ResponsibleFor}. Die \texttt{WorksWith}-Beziehung besitzt ein zusätzliches Attribut, welches den Erstellzeitpunkt der Beziehung datiert.}
	\label{fig:orientdb_example}
\end{figure}

Abbildung \ref{fig:orientdb_example} zeigt einen schematisierten Graphen, welcher die Beziehungen zwischen Mitarbeitern und Projekten repräsentiert, sowohl Knoten als auch Kanten sind Klassen zugeordnet. Für deren Definition stellt OrientDB den \texttt{CREATE CLASS}-Operator zur Verfügung. Nachfolgend wird eine Klasse \texttt{Employee} erzeugt, dieser wird ein Pflichtattribut \texttt{name} vom Typ \texttt{STRING} und ein optionales Attribut \texttt{age} vom Typ \texttt{INTEGER} zugewiesen. Mit der Angabe der Integritätsbedingung \texttt{MIN} erfolgt für Letzteres die Einschränkung zulässiger Werte.
Die Klasse selbst erbt von \texttt{V}, welche alle Knoten innerhalb des Graphen repräsentiert. Die Definition der Klasse \texttt{Project} erfolgt analog.

\texttt{CREATE CLASS Employee EXTENDS V;}\newline
\texttt{CREATE PROPERTY Employee.name STRING;}\newline
\texttt{CREATE PROPERTY Employee.age INTEGER;}\newline
\texttt{ALTER PROPERTY Employee.name MANDATORY true;}\newline
\texttt{ALTER PROPERTY Employee.age MIN 18;}

Das Definieren von Kantentypen erfolgt ebenfalls mit dem gezeigten Operator, sie erben jedoch von \texttt{E}, der Klasse aller Kanten. Attribute werden wie bereits für Knoten gezeigt definiert. Nachfolgend ist stellvertretend der Befehl für das Anlegen des Kantentyps \texttt{WorksWith} dargestellt:

\texttt{CREATE CLASS WorksWith EXTENDS E;}

Für die Manipulation der Datenbasis stehen in Standard-SQL die Befehle \texttt{INSERT}, \texttt{UPDATE} und \texttt{DELETE} zur Verfügung. Diese werden auch in OrientDB angeboten, \texttt{INSERT} ist jedoch nur für die Verwendung mit Dokumenten vorgesehen, das Erzeugen von Knoten- und Kanteninstanzen erfolgt mit den Befehlen \texttt{CREATE VERTEX} bzw. \texttt{CREATE EDGE}. Die folgende Anweisung fügt dem Graphen eine attributierte Knoteninstanz vom Typ \texttt{Employee} hinzu:

\texttt{CREATE VERTEX Employee SET name=\string"Alice\string", age=25;}

Das Erzeugen einer Kanteninstanz erfordert die Angabe der Identitäten von Start- und Zielknoten, diese können entweder direkt angegeben, oder durch eine geschachtelte Selektion gelesen werden. Nachfolgend wird stellvertretend die Instanz der \texttt{WorksWith}-Beziehung zwischen den Mitarbeitern \texttt{Alice} und \texttt{Bob} eingefügt, Kantenattribute können ohne Beachtung der Schemadefinition angefügt werden:

\texttt{CREATE EDGE WorksWith}\newline
\texttt{FROM (SELECT FROM Employee WHERE name=\string"Alice\string")}\newline
\texttt{TO (SELECT FROM Employee WHERE name=\string"Bob\string")}\newline
\texttt{SET since=2011;}

\paragraph*{Mengenorientierte Operationen via OrientDB-SQL}

Die Informationsextraktion erfolgt entweder über den \texttt{SELECT}- oder den \texttt{TRAVERSE}-Operator. Analog zu Standard-SQL können diese beliebig geschachtelt werden. Die folgende Anfrage selektiert die Namen der Mitarbeiter zu denen \texttt{Alice} eine ausgehende Kante vom Typ \texttt{WorksWith} besitzt:

\texttt{SELECT name FROM}\newline
\texttt{(SELECT expand(out(\string"WorksWith\string")) FROM Employee WHERE name=\string"Alice\string");} 

Die Funktion \texttt{out} legt dabei die Richtung der Kante fest und kann wahlweise durch \texttt{in} oder \texttt{both} ersetzt werden. Das Ergebnis der drei Funktionen ist eine Menge von Knoten-Identitäten, deren Instanzen durch \texttt{expand} aufgelöst werden und damit in übergeordneten Anfragen verwendbar sind.\footnote{Sollen inzidente Kanten-Identitäten selektiert werden, so ist dies mit den Funktionen \texttt{outE}, \texttt{inE} und \texttt{bothE} ebenfalls möglich.} Das gezeigte Beispiel entspricht einer Verbundoperation in einem RDBMS. Der wesentliche Unterschied ist, dass die Beziehungsinformationen materialisiert an Knoten gespeichert sind und nicht zur Laufzeit berechnet werden müssen. Ersetzt man die Projektion der inneren \texttt{SELECT}-Anweisung durch: 

\texttt{expand(out(\string"WorksWith\string").out(\string"ResponsibleFor\string"))}

werden die Namen der Projekte ausgegeben, für welche die Kollegen von \texttt{Alice} verantwortlich sind. Handelt es sich bei beiden Beziehungen um $n:m$ Relationen, erfordert diese Anfrage in einer relationalen Datenbank vier Verbundoperationen. In OrientDB ist die Berechnung ausschließlich von der Anzahl der Beziehungen zwischen den einzelnen Knoteninstanzen abhängig.

Eine etwas komplexere Anfrage bezieht Kantenattribute mit ein und selektiert alle Kollegen von \texttt{Bob} mit denen er seit 2012 zusammenarbeitet und die älter als 25 sind:

\texttt{SELECT since, in.name as name, in.age as age FROM}\newline
\texttt{(SELECT expand(outE(\string"WorksWith\string")) FROM Employee WHERE name=\string"Bob\string")}\newline
\texttt{WHERE since > 2011 AND in.age > 25;}

Die innere Anfrage selektiert mittels \texttt{outE} alle ausgehenden Kanten von \texttt{Bob}, welche anschließend durch das Prädikat \texttt{since > 2011} eingeschränkt werden. Die Funktion \texttt{in} verweist auf die Zielknoten der inzidenten Kanten, diese müssen den Attributschlüssel \texttt{age} mit einem zugehörigen Wert größer als 25 aufweisen.

Aus den gezeigten Beispiel geht hervor, dass die Selektion durch die optionale Angabe einer \texttt{WHERE}-Klausel möglich ist. OrientDB stellt vergleichende, boolesche und mathematische Operatoren für die Definition und Verknüpfung von Prädikaten zur Verfügung. Diese können in Verbindung mit einzelnen oder mehreren Attributwerten definiert werden. Ein Prädikat berücksichtigt ausschließlich Dokumente an denen das Attribut vorhanden ist, alle anderen sind nicht in der Ergebnismenge enthalten.\\
Die Projektion erlaubt die Auswahl einzelner Attribute aus der Ergebnismenge und ermöglicht die Berechnung von Aggregaten und das Ausführen von Funktionen.\\
Verschiedene Aggregatfunktionen, wie zum Beispiel \texttt{count}, \texttt{min}, \texttt{max} und \texttt{avg} stehen zur Verfügung. Analog zu Neo4j erlaubt OrientDB die Verwendung zusätzlicher skalarer, mathematischer, string-basierter und mengenorientierter Funktionen.\footnote{Eine vollständige Übersicht über Operatoren und Funktionen findet sich unter \url{https://github.com/orientechnologies/orientdb/wiki/SQL-Where}.} Die Ergebnismenge kann gruppiert\footnote{In OrientDB 1.5.1 ist die Gruppierung nur für ein Attribut möglich.}, sortiert sowie durch \texttt{SKIP} und \texttt{LIMIT} eingeschränkt werden.

% Traversierung
\paragraph*{Traversierung via OrientDB-SQL}

Das Prüfen der Erreichbarkeit und das Berechnen von Pfaden ist in SQL ebenfalls möglich. Der \texttt{TRAVERSE}-Operator führt eine Traversierung ausgehend von einem konkreten Knoten oder einer Knotenmenge durch. Ein mehrfaches Besuchen von Knoten- und Kanteninstanzen wird durch das GDBMS verhindert, Möglichkeiten einer feingranularen Einstellung wie bei Neo4j oder einer manuellen Definition analog zu HyperGraphDB bestehen nicht. Folgende Anfrage selektiert alle Knoten, die über eine \texttt{WorksWith}-Beziehung mit einem Startknoten verbunden sind und einen maximalen Abstand von drei zu diesem aufweisen:

\texttt{TRAVERSE out(\string"WorksWith\string") FROM \#11:0 WHILE \$depth<=3;}

Der Ausgangsknoten ist hierbei durch seine Identität \texttt{\#11:0} vorgegeben, alternativ können Klassen oder eingebettete Anfragen angegeben werden. Die Traversierung definiert einen abstrakten Weg, bei dem alle Kanten gerichtet und vom Typ \texttt{WorksWith} sind. Der Abstand zum Startknoten beträgt höchstens drei und wird sowohl zur Laufzeit als auch im Ergebnis an die Systemvariable \texttt{\$depth} gebunden. Das Ergebnis dieses Operators ist die Menge aller Knoten und Kanten, welche in den Instanzen des beschriebenen Weges enthalten sind. Diese lassen sich in übergeordneten Anfragen weiter verarbeiten:

\texttt{SELECT name, min(\$depth) as dist FROM}\newline
\texttt{(TRAVERSE out(\string"WorksWith\string") FROM \#11:0 WHILE \$depth<=3 STRATEGY breadth\_first)}\newline
\texttt{GROUP BY name ORDER BY dist;}

Die gezeigte Anfrage listet alle Kollegen eines Mitarbeiters sortiert nach ihrem minimalen Abstand zueinander auf. Die \texttt{TRAVERSE}-Operation berechnet unter Verwendung der Breitensuche alle Pfadinstanzen.\footnote{Standardmäßig entspricht die Reihenfolge der zu traversierenden Knoten einem Tiefendurchlauf. Da Knoten jedoch systemseitig nicht mehrfach besucht werden können, weisen die gefundenen Pfadinstanzen nicht zwingend die minimale Länge auf.} Da zwei Mitarbeiter über mehrere Pfade verbunden sein können, werden diese anschließend nach dem Namen des Kollegen gruppiert. Die Projektion schränkt die Ergebnismenge durch Aggregation der Pfadlängen mittels \texttt{min} ein.\\
Die Definition von Filterkriterien hinsichtlich Bezeichnern und Attributen erfolgt mittels Verwendung einer Selektion. Nachfolgend sollen alle Projekte, mit denen ein Mitarbeiter direkt oder transitiv verbunden ist, zusammen mit dem Abstand zum Mitarbeiter ausgegeben werden:

\texttt{SELECT name, min(\$depth) FROM}\newline
\texttt{(TRAVERSE both() FROM \#11:0 WHILE \$depth<=4 STRATEGY breadth\_first)}\newline
\texttt{WHERE @Class=\string"Project\string" GROUP BY name;}

In dieser Anfrage werden durch die Verwendung von \texttt{both} ein- und ausgehende Kanten jeglichen Typs traversiert. Die Knotenmenge wird durch das Prädikat \texttt{@Class=\string"Project\string"} auf Projekte eingeschränkt.

Für das Berechnen kürzester Pfade stellt OrientDB die Funktionen \texttt{shortestPath} für ungewichtete und \texttt{dijkstra} für gewichtete Graphen zur Verfügung. Beide Funktionen unterstützen lediglich das Festlegen einer Kantenrichtung, Typ- oder Attributeinschränkungen sind weder für Knoten noch für Kanten möglich.

%\paragraph*{Besonderheiten}
%
%- Hooks (Trigger)
%	- \url{https://github.com/orientechnologies/orientdb/wiki/Hook}
%- Functions 
%	- \url{https://github.com/orientechnologies/orientdb/wiki/Functions}
%	- Stored Procedures in JavaScript
%	- können via REST und auch embedded ausgeführt werden
%	- gegenseitiger Aufruf + Rekursion


\paragraph*{Transaktionen}

OrientDB unterstützt die Ausführung von Zugriffen innerhalb von Transaktionen. Im Fall von SQL werden diese für Änderungen implizit erzeugt, der Commit erfolgt unmittelbar nach der Ausführung. Alternativ können Transaktionen explizit begonnen, beendet und zurückgesetzt werden. Bei der Verwendung der Java API ist die Ausführung von Änderungen nur in Verbindung mit dem expliziten Verwalten einer Transaktion möglich. Analog zu HyperGraphDB lässt sich die Transaktionsverwaltung beim Systemstart deaktivieren um zum Beispiel den Datenimport zu beschleunigen.

Im Gegensatz zu den bisher betrachteten Systemen wird das Schachteln von Transaktionen in OrientDB nicht unterstützt. Pro Thread im eingebetteten Betrieb bzw. pro Datenbankverbindung im Client-Server-Betrieb ist zu jedem Zeitpunkt nur eine Transaktion möglich. Ist zum Beginn einer Transaktion bereits eine weitere aktiv, wird diese zurückgesetzt.

OrientDB bezeichnet sich selbst als ACID-konformes GDBMS: Zur Vermeidung von Mehrbenutzeranomalien wird das optimistische Synchronisationsverfahren MVCC eingesetzt, welches bereits im Zusammenhang mit HyperGraphDB beschrieben wurde. Die Ausführung einer Transaktion erfolgt zunächst ausschließlich innerhalb der Anwendung bzw. beim Client. Werden Objekte erzeugt, so erhalten sie eine temporäre Identität, Änderungen an gelesenen Objekten erfolgen ebenfalls unabhängig vom GDBMS im Kontext der Anwendung.  Beim Commit werden alle Operationen an das Datenbanksystem übertragen, dort werden sie chronologisch ausgeführt und die Änderungen in die Datenbasis eingebracht.\footnote{Die Speicherschicht ist während des Ausführung des Commit exklusiv gesperrt, Dirty Reads werden somit vermieden. Dies kann im Quelltext unter \url{https://github.com/orientechnologies/orientdb/blob/1.5.1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/OStorageLocalTxExecuter.java\#L83-L88} nachvollzogen werden.} Ein Konflikt liegt vor, wenn ein von der Transaktion geändertes Objekt innerhalb der Datenbasis eine neue Version aufweist, in diesem Fall wird die Transaktion zurückgesetzt.\footnote{Dies kann im Quelltext unter \url{https://github.com/orientechnologies/orientdb/blob/1.5.1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/OStorageLocal.java\#L1839-L1854} nachvollzogen werden.}\\
Im Gegensatz zu HyperGraphDB berücksichtigen Lesezugriffe nicht ausschließlich jene Objektversionen, die zu Beginn der Transaktion aktuell waren, stattdessen wird beim ersten Zugriff auf ein Objekt die neueste Version aus der Datenbasis geladen.\footnote{Dies entspricht dem Konzept der chronologieerhaltenden Serialisierbarkeit\cite{DBLP:books/sp/HarderR01}.} Alle nachfolgenden Lesezugriffe beziehen sich auf diese Objektversion. Daraus geht hervor, dass alle Mehrbenutzeranomalien vermieden werden, dies entspricht der Isolationsebene \texttt{SERIALIZABLE}.\footnote{Zu beachten ist, dass dies ausschließlich für die eingebettete Verwendung gilt. Im Client-Server-Betrieb werden Lesezugriffe immer vom Server beantwortet, folglich können die Anomalien Non-Repeatable Read und Phantom Problem auftreten. Dies entspricht der Isolationsebene \texttt{READ COMMITTED}. Die getroffenen Annahmen wurden durch den Entwickler bestätigt\cite{Orient_acid:2013}.}

Kommt es vor dem Commit einer Transaktion zum Ausfall des GDBMS oder des Clients, so sind die bis zu diesem Zeitpunkt erfolgten Änderungen nicht in der Datenbasis vorhanden, folglich ist in den genannten Situationen die atomare Ausführung der Transaktion sichergestellt. Kommt es hingegen beim Ausführen des Commit zum Ausfall des GDBMS, können bereits Teile einer Transaktion in der Datenbasis vorhanden sein. Um diese Änderungen widerrufen zu können, wird vor dem Ausführen jeder Änderung ein zugehöriger UNDO-Eintrag in ein Transaktions-Log geschrieben. Beim Löschen oder Ändern eines Datensatzes enthält der Eintrag eine Kopie des ursprünglichen Datensatzes.\footnote{Dies entspricht dem Konzept des physischen Loggings\cite{DBLP:books/sp/HarderR01} und kann für das Aktualisieren im Quelltext unter \url{https://github.com/orientechnologies/orientdb/blob/1.5.1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/OStorageLocalTxExecuter.java\#L115} nachvollzogen werden.} Das Ausschreiben der Log-Daten auf den Externspeicher erfolgt unmittelbar, beim Neustart des GDBMS kann somit ein konsistenter Zustand wiederhergestellt werden.\\
Bei der Betrachtung der Wiederholbarkeit erfolgreich beendeter Transaktionen muss zwischen den zwei verschiedenen, in OrientDB auswählbaren, Speichermechanismen unterschieden werden: \texttt{OStorageLocal} und \texttt{OLocalPaginatedStorage}. Erstgenanntes nutzt Memory Mapped Files und überlässt es folglich dem Betriebssystem, wann ausgeschriebene Änderungen tatsächlich auf den Externspeicher geschrieben werden. Das zugehörige Transaktions-Log enthält jedoch keine REDO-Informationen erfolgreich beendeter Transaktionen. Folglich sind deren Änderungen verloren, wenn diese sich zum Zeitpunkt eines Systemausfalls noch nicht auf dem Externspeicher befinden.\footnote{Das GDBMS ermöglicht das Aktivieren einer FORCE-Strategie, bei der sowohl Log-Informationen als auch Änderungen an der Datenbasis unmittelbar auf den Externspeicher geschrieben werden. Dies kann jedoch mit Performance-Einbußen verbunden sein\cite{DBLP:books/sp/HarderR01}.} Im Gegensatz dazu verwaltet \texttt{OLocalPaginatedStorage} den Zugriff auf den Externspeicher unabhängig vom Betriebssystem und führt ein Transaktions-Log in dem sowohl UNDO- als auch REDO-Informationen gespeichert werden. Das Log selbst wird beim Commit auf den Externspeicher geschrieben, das Ausschreiben der eigentlichen Änderungen kann asynchron erfolgen, da die Log-Informationen ein Wiederherstellen im Fehlerfall ermöglichen.

\paragraph*{Indexverwaltung}

OrientDB unterstützt die Verwendung von Indexstrukturen für den effizienten Zugriff auf die gespeicherten Dokumente. Ein Index kann auf einem oder mehreren Attributen definiert werden und besitzt einen eindeutigen Bezeichner. Handelt es sich um ein schematisiertes Attribut, übernimmt das GDBMS die Aktualisierung des Index, bei Attributen die nicht im Schema definiert sind, erfolgt die Verwaltung hingegen manuell. Es werden Befehle für das Einfügen von Dokumenten, das Ausführen von Punkt- und Bereichsanfragen und das Löschen einzelner oder mehrerer Einträge bereitgestellt. Darüber hinaus kann ein Index vollständig entfernt werden.

Indizes können sowohl via Java API als auch in SQL definiert werden. Der nachfolgende Befehl erzeugt einen mehrdimensionalen Index auf den Attributen Name und Alter eines Mitarbeiters:

\texttt{CREATE INDEX idx1 ON Employee (name, age) UNIQUE;}

Der Indextyp \texttt{UNIQUE} erlaubt die Verwendung als Primärindex. Anzumerken ist, dass mehrdimensionale Indizes auch dann berücksichtigt werden, wenn nur eine der Dimensionen in einer \texttt{WHERE}-Klausel angegeben wird.

OrientDB beinhaltet zwei Index-Implementierungen: MVRB-Baum und Hash-Index. Der MVRB-Baum ist eine von Orient Technologies entwickelte Datenstruktur, welche die Eigenschaften des B$^+$-Baumes mit denen eines Rot-Schwarz-Baumes\cite{ottmann2002algorithmen} kombiniert. Die Struktur unterstützt Punkt- und Bereichsanfragen und kann als Indextyp \texttt{UNIQUE}, \texttt{NONUNIQUE}, \texttt{FULLTEXT} und \texttt{DICTIONARY} verwendet werden.\footnote{\texttt{DICTIONARY} ist identisch zu \texttt{UNIQUE}, existiert beim Einfügen bereits ein entsprechender Eintrag wird dieser jedoch überschrieben.} Indexoperationen sind logarithmisch von der Anzahl der Einträge und der Höhe des Baumes abhängig.\\
Eine zweite Implementierung basiert auf der Verwendung einer Hashtabelle, welche ausschließlich Punktanfragen unterstützt. Indexoperationen sind im besten Fall in konstanter Zeit möglich, die nutzbaren Indextypen sind analog zum MVRB-Baum.
	
\subsection{Persistenz- und Cacheverwaltung}

Wie bereits im Zusammenhang mit Transaktionen genannt, unterstützt OrientDB zwei Speichermechanismen. Nachfolgend wird die Persistenzverwaltung anhand der Standardeinstellung \texttt{OStorageLocal} erläutert. Laut Aussage der Entwickler soll \texttt{OLocalPaginatedStorage} in einer der folgenden Versionen die standardmäßige Implementierung sein\cite{Orient_acid:2013}, die offizielle Dokumentation enthält bisher jedoch keine detaillierten Informationen über den Speichermechanismus.

Knoten und attributierte Kanten werden auf Dokumente abgebildet, die innerhalb der Speicherschicht als \textit{Record} bezeichnet werden. Ein Record ist genau einem \textit{Cluster} zugeordnet: Ein Cluster ist die physische Gruppierung von Records anhand einer definierten Eigenschaft. Dies kann der Typ oder ein beliebiges Attribut des Dokumentes sein. Bei der Verwendung des Typsystems wird für jede Klasse automatisch ein Cluster erzeugt.\footnote{Wird auf ein Schema verzichtet, werden alle Dokumente einem Cluster zugeordnet.} Darüber hinaus erlaubt das GDBMS aber auch das manuelle Zuweisen mehrerer Cluster zu einer Klasse:

\texttt{CREATE CLUSTER Projects2012;}\newline
\texttt{CREATE CLUSTER Projects2013;}\newline
\texttt{CREATE CLASS Project EXTENDS V CLUSTER Projects2012,Projects2013;}\newline
\texttt{CREATE VERTEX Project CLUSTER Projects2012 SET year=2012;}\newline
\texttt{CREATE VERTEX Project CLUSTER Projects2013 SET year=2013;}\newline
\texttt{SELECT FROM Project WHERE year=2013; // scans all clusters}\newline
\texttt{SELECT FROM cluster:Project2013; // scans one cluster}

In diesem Beispiel sind der Klasse \texttt{Project} zwei Cluster zugewiesen: \texttt{Projects2012} und \texttt{Projects2013}. Zwei Knoteninstanzen werden erzeugt und ihrem entsprechenden Cluster zugeordnet. Die gezeigten Leseanfragen besitzen eine identische Ergebnismenge, die zweite Anfrage kann jedoch effizienter ausgeführt werden, da lediglich ein Cluster berücksichtigt werden muss. Folglich lässt sich durch Cluster eine semantische Gruppierung physisch abbilden. An dieser Stelle wird auch deutlich, warum OrientDB das Verwenden eines Schemas empfiehlt: Knoten und Kanten werden im Speichersystem gruppiert nach Typ verwaltet wodurch entsprechend eingeschränkte Anfragen effizienter beantwortet werden können.\\
Die Identität eines Records, die sog. \textit{RecordID} setzt sich aus der Identität des Clusters und der absoluten Position des Records innerhalb des Clusters zusammen: Ist zum Beispiel der Knoten \texttt{Alice} an Position 37 im Mitarbeiter-Cluster mit der Identität 13 gespeichert, dann ist die RecordID \texttt{\#13:37}.

Analog zu Neo4j wird die Datenbasis in OrientDB auf mehrere Dateien aufgeteilt. Hierbei erfolgt jedoch keine explizite Trennung in Topologie und Nutzdaten, stattdessen orientiert sich die Speicherung am Dokumentenmodell. Ein Cluster wird durch eine oder mehrere Dateien repräsentiert. Jeder Eintrag innerhalb eines Clusters besitzt ein festes Format, was bedeutet, dass analog zu Neo4j die Berechnung der physischen Position effizient möglich ist. Im Cluster werden keine Nutzdaten gespeichert, sie dienen lediglich der Gruppierung von Records, Cluster-Einträge verweisen auf deren Nutzdaten. Diese befinden sich in der zweiten Komponente des Speichersystems, dem \textit{Data Segment}. 

\begin{figure}[h] 
	\centering
		\includegraphics[scale=0.75]{orientdb_cluster_record.pdf}
	\caption[OrientDB: Datensatz eines Clusters]{Physische Repräsentation eines Eintrags in einem Cluster in OrientDB. Der Datensatz hat eine feste Länge von 15 Byte.\footnote{\url{https://github.com/orientechnologies/orientdb/blob/1.5.1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/OClusterLocal.java?source=cc}}}
	\label{fig:orientdb_cluster_record}
\end{figure}

Abbildung \ref{fig:orientdb_cluster_record} zeigt den schematischen Aufbau eines Satzes in einem Cluster:
Die ersten zwei Byte verweisen auf das Data Segment, in welchem die Nutzdaten zu diesem Record hinterlegt sind, die nachfolgenden acht Byte legen die physische Position innerhalb des Data Segment fest. Die letzten fünf Byte speichern Typ\footnote{Damit ist nicht der Datentyp gemeint. Ein Record kann entweder ein Dokument oder ein sog. Plain-Objekt sein. Letzteres ist für die Evaluation nicht relevant.} und Version des Dokumentes. Beim Löschen eines Datensatzes wird dessen Position in einer zusätzlichen Datei vermerkt und steht für neue Dokumente zur Verfügung.

Das Data Segment speichert die Nutzdaten eines Record und wird ebenfalls durch eine oder mehrere Dateien repräsentiert. Da verfügbare Informationen an Dokumenten individuell verschieden sein können, ist auch die Länge eines Datensatzes variabel. Abbildung \ref{fig:orientdb_datasegment_record} zeigt dies schematisch.

\begin{figure}[h] 
	\centering
		\includegraphics[scale=0.75]{orientdb_datasegment_record.pdf}
	\caption[OrientDB: Datensatz eines Datensegmentes]{Physische Repräsentation eines Eintrags im Data Segment zur Speicherung der Nutzdaten. Der statische Teil des Datensatzes hat eine Länge von 14 Byte, der dynamische Teil variiert je nach Umfang der hinterlegten Daten.}
	\label{fig:orientdb_datasegment_record}
\end{figure}

Ein Datensatz besteht aus einem Abschnitt fester Länge und einem dynamischen Teil, welcher je nach Umfang der Nutzdaten verschieden groß sein kann.\footnote{\url{https://github.com/orientechnologies/orientdb/blob/1.5.1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/ODataLocal.java}} Die ersten vier Byte speichern die Länge der Nutzdaten. Diese Information ermöglicht es, die Rohdaten aus dem Datensatz zu extrahieren um sie anschließend zu deserialisieren. Die nachfolgenden zehn Byte sind ebenfalls fest vergeben und enthalten Informationen über das zugeordnete Cluster. Der Rest des Datensatzes ist für die Speicherung der Rohdaten vorgesehen.

Das Auslesen der physischen Adressen im Cluster und im Datensegment ist in konstanter Zeit möglich.
Daraus geht hervor, dass sich die Nachbarschaft eines Knotens $v$ analog zu Neo4j in $\mathcal{O}(\left|N_v\right|)$ berechnen lässt. Dabei ist jedoch zu beachten, dass Beziehungsinformationen ebenfalls als Attribute in einem Dokument hinterlegt sind. Beim Lesen eines Records werden die kompletten Rohdaten geladen\footnote{Nachzuvollziehen unter \url{https://github.com/orientechnologies/orientdb/blob/1.5.1/core/src/main/java/com/orientechnologies/orient/core/storage/impl/local/ODataLocal.java?source=cc\#L248}}, das Deserialisieren der Nutzdaten erfolgt jedoch erst beim Zugriff auf das entsprechende Attribut.\footnote{Nachzuvollziehen unter \url{https://github.com/orientechnologies/orientdb/blob/1.5.1/core/src/main/java/com/orientechnologies/orient/core/record/impl/ODocumentHelper.java?source=c\#L224}.}  Folglich müssen beim Traversieren des Graphen die kompletten Rohdaten gelesen und die angefragten Kanten deserialisiert werden. Darüber hinaus stellen attributierte Kanten eine zusätzliche Indirektion dar, da sie in einem dedizierten Dokument und damit auch in einem physisch unabhängigen Record gespeichert sind.

Beim Löschen eines Datensatzes im Data Segment werden Position und Länge des Satzes in einer zusätzlichen Datei hinterlegt und der somit definierte Bereich steht als freier Speicher zur Verfügung. Aus der dynamischen Länge des Satzes ergeben sich jedoch weitere Aufgaben: Beim Aktualisieren eines Dokumentes kann der zur Verfügung stehende Speicher zu gering sein und das Löschen führt zur Entstehung von freien Bereichen unterschiedlicher Länge. Das GDBMS implementiert hierfür eine Freispeicherverwaltung und eine automatische Defragmentierung. Eine detaillierte Betrachtung dieser Prozesse geht jedoch über den Rahmen dieser Arbeit hinaus und kann bei Bedarf anhand des Quelltextes nachvollzogen werden.

Eine dritte Komponente des Speichersystems ist der \textit{Storage}. Dieser nimmt Anfragen der Datenbankschicht entgegen und orchestriert den Zugriff auf Cluster und Data Segments.% Abbildung \ref{fig:orientdb_storage_sequence} fasst die Funktionsweise der Persistenzverwaltung am Beispiel des Lesens eines Dokumentes zusammen.

\paragraph*{Cacheverwaltung}

Für den effizienten wahlfreien Zugriff auf deserialisierte Dokumente verwendet OrientDB mehrere Caches. Nachfolgend wird die Architektur im Kontext der eingebetteten Verwendung erläutert.\\
Records werden aus dem Speichersystem geladen, deserialisiert und im Level-2-Cache abgelegt. Dabei handelt es sich um einen First-In-First-Out-Cache, welcher durch eine Hashtabelle mit verketteten Schlüsseln realisiert wird.\footnote{Es handelt sich um eine Erweiterung der Java-Datenstruktur \texttt{LinkedHashMap}. Dies kann unter \url{https://github.com/orientechnologies/orientdb/blob/1.5.1/core/src/main/java/com/orientechnologies/orient/core/cache/ODefaultCache.java?source=cc} nachvollzogen werden.} Der maximal nutzbare Hauptspeicher wird manuell festgelegt und bei Überschreiten dieser Grenze wird ein definierter Anteil der ältesten Einträge verdrängt. Alle Threads innerhalb der JVM können auf den Level-2-Cache zugreifen. Darüber hinaus ist jedem Thread ein dedizierter Level-1-Cache exklusiv zugeordnet. Dieser wird, vergleichbar mit HyperGraphDB, durch eine Hashtabelle und die Verwendung schwacher Referenzen realisiert.

Ein Lesezugriff prüft zunächst, ob das angeforderte Dokument im Level-1-Cache vorhanden ist. Sollte dies nicht der Fall sein, erfolgt der Zugriff auf den Level-2-Cache. Befindet sich das Dokument dort, wird es in den Level-1-Cache bewegt. Ist das Dokument in keinem der Caches vorhanden, erfolgt der Zugriff auf das Speichersystem. Dieses besitzt einen eigenen Cache in dem die Ergebnisse von Lesezugriffen zwischengespeichert werden. Erst wenn der Record in diesem Cache nicht vorhanden ist, erfolgt der Zugriff auf den Hintergrundspeicher. Wie bereits erwähnt, verwendet \texttt{OStorageLocal} Memory Mapped Files für die Abbildung der Daten auf den Externspeicher. Dies kann dazu führen, dass ein Lesezugriff ebenfalls aus dem Hauptspeicher beantwortet wird. 

Durch die client-seitige Ausführung von Transaktionen, werden Änderungen an Dokumenten nicht unmittelbar im Cache reflektiert, die Aktualisierung erfolgt erst nach erfolgreicher Beendigung der Transaktion. Durch die Verwendung eines dedizierten Level-1-Caches pro Thread kann jedoch der Fall eintreten, dass sich ein Dokument mit verschiedenen Versionen in mehreren Level-1-Caches befindet. Um diesem Problem zu begegnen, kann entweder der Level-1-Cache vollständig deaktiviert, oder das Zwischenspeichern eines Dokumentes explizit verboten werden. Bei der Verwendung mehrerer JVMs in Verbindung mit einer gemeinsamen physischen Speicherschicht, gilt gleiches auch für den Level-2-Cache.

\subsection{Verteilung und Skalierbarkeit}

OrientDB lässt sich als verteiltes GDBMS einsetzen und unterstützt dabei die vollständige Replikation der Datenbasis. Realisiert wird dies durch Hazelcast\footnote{\url{http://www.hazelcast.com/}}, einer quelloffenen, skalierbaren Verteilungsplattform für Java-Anwendungen. Im Gegensatz zu Neo4j verwendet OrientDB eine Muli-Master-Architektur\cite{rahm_masterslave}. Diese zeichnet sich dadurch aus, dass alle Rechner im Cluster gleichberechtigt sind: Lese- und insbesondere Schreibzugriffe können an allen Rechnern direkt ausgeführt werden. Nachfolgend wird die Architektur anhand der internen Ausführung von Änderungs- und Lesetransaktionen kurz beschrieben.\footnote{Die offizielle Dokumentation enthält bezüglich der Datenverteilung nur wenig Informationen. Die vollständige Evaluation des Quelltextes würde das Gewicht der Verteilung innerhalb der Evaluation nicht rechtfertigen.}

Erhält eine Instanz eine Änderungstransaktion, führt sie diese zunächst lokal durch. Anschließend erfolgt die Verteilung der Änderungen nach dem Push-Prinzip entweder synchron oder asynchron: Im synchronen Fall erhält der Client erst dann eine Bestätigung, wenn die Änderungen an allen Instanzen durchgeführt sind und folglich eine konsistente Sicht auf die Daten innerhalb des Clusters besteht. Im asynchronen Fall erfolgt die Bestätigung unmittelbar nachdem die Daten lokal geschrieben wurden, die Replikation der Änderungen erfolgt parallel bzw. verzögert. Dies entspricht dem Konzept der Eventual Consistency, bei der das GDBMS für jede Instanz eine letztendlich konsistente Sicht auf die Daten garantiert.\\
Das Ausführen von Lesezugriffen ist ebenfalls an allen Rechnern im Cluster möglich. Erfolgt die Replikation von Änderungen asynchron, können gelesene Daten eventuell veraltet sein, bei einer synchronen Replikation werden stets die aktuellen Daten gelesen.

Jede GDBMS-Instanz besitzt Informationen über alle weiteren Teilnehmer im Cluster, gleiches gilt auch für Client-Anwendungen. Beim Entfernen oder Hinzufügen einer Instanz wird die zugehörige Information an alle beteiligten Rechner propagiert. Daraus geht hervor, dass sich Clients beim Ausfall einer GDBMS-Instanz automatisch zu einer neuen Instanz verbinden und die Kommunikation fortsetzen können. Tritt eine neue Instanz dem Cluster bei, sendet diese zunächst eine Anfrage zum Datenabgleich mit dem Verbund. Der Abgleich erfolgt auf Basis der Log-Informationen mit einer der verfügbaren Instanzen. Diese sendet der neuen Instanz die entsprechende Differenzmenge an Änderungen zu.

% Skalierbarkeit
\paragraph*{Skalierbarkeit}

Die Multi-Master-Replikation erlaubt das horizontale Skalieren von Lese- und Schreibzugriffen. Zu beachten ist jedoch, dass dies für Schreibzugriffe nur im Fall einer asynchronen Replikation und auch da nur eingeschränkt gilt. Änderungsoperationen müssen an allen Instanzen durchgeführt werden, was je nach Anzahl der Rechner zu einer hohen Antwortzeit und somit bei hoher Schreiblast zu Performance-Problemen führen kann. Darüber hinaus muss die Korrektheit paralleler Schreibzugriffe generell und insbesondere auch beim Ausfall mehrerer Rechner sichergestellt sein. Bezüglich des maximalen Datenvolumens ist die Architektur ausschließlich vertikal skalierbar, da die Datenbasis an allen Instanzen komplett hinterlegt ist. Eine Partitionierung des Graphen wird aktuell entwickelt, ist jedoch weder dokumentiert noch in einer stabilen Version verfügbar.\footnote{Der aktuelle Entwicklungsstand kann unter \url{https://github.com/orientechnologies/orientdb/tree/1.5.1/distributed/src/main/java/com/orientechnologies/orient/server/hazelcast} eingesehen werden.}